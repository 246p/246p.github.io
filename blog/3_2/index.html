<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>3. Syntax analysis (2) | Junlog</title>
<meta name=keywords content="컴파일러,Syntax analysis,Parser,Bottom-up,CFG"><meta name=description content="Bottom-up bottom-up parsing을 수행할때는 소괄호를 지원하는 조금 다른 CFG를 사용한다
피 연산자로 id만 지원함 left-recursion이 있어도 됨 Top-down parsing은 다음과 같은 방식으로 시작된다.
tree를 만드는 동안 token을 하나씩 읽는다. 끝이 난다면 root node는 start symbol이 된다. 다음은 id1 * id2 에 대한 예시이다. 즉 reversed order Rightmost Derivation이라고 볼 수 있다.
LR(1) Parsing 매 단계마다 다음 token을 받아올지 production rule을 적용할지 정해야 한다. top-down parsing과 동일하게 parsing table을 사용한다. Three Types of LR(1) Parsing Left-to-right, Rightmost derivation, 1 token lookahead SLR(1) Parsing : Simple LR(1) Parsing 우리가 다룰것 LALR(1) Parsing : Look-Ahead LR(1) Parsing SLR(1)보다 많은 grammar에 적용 가능하다."><meta name=author content="Kim-Minjoon"><link rel=canonical href=https://246p.github.io/blog/3_2/><meta name=google-site-verification content="GTM-524D7HPF"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="3. Syntax analysis (2)"><meta property="og:description" content="Bottom-up bottom-up parsing을 수행할때는 소괄호를 지원하는 조금 다른 CFG를 사용한다
피 연산자로 id만 지원함 left-recursion이 있어도 됨 Top-down parsing은 다음과 같은 방식으로 시작된다.
tree를 만드는 동안 token을 하나씩 읽는다. 끝이 난다면 root node는 start symbol이 된다. 다음은 id1 * id2 에 대한 예시이다. 즉 reversed order Rightmost Derivation이라고 볼 수 있다.
LR(1) Parsing 매 단계마다 다음 token을 받아올지 production rule을 적용할지 정해야 한다. top-down parsing과 동일하게 parsing table을 사용한다. Three Types of LR(1) Parsing Left-to-right, Rightmost derivation, 1 token lookahead SLR(1) Parsing : Simple LR(1) Parsing 우리가 다룰것 LALR(1) Parsing : Look-Ahead LR(1) Parsing SLR(1)보다 많은 grammar에 적용 가능하다."><meta property="og:type" content="article"><meta property="og:url" content="https://246p.github.io/blog/3_2/"><meta property="og:image" content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-01-10T21:32:30+09:00"><meta property="article:modified_time" content="2024-01-10T21:32:30+09:00"><meta property="og:site_name" content="Junlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta name=twitter:title content="3. Syntax analysis (2)"><meta name=twitter:description content="Bottom-up bottom-up parsing을 수행할때는 소괄호를 지원하는 조금 다른 CFG를 사용한다
피 연산자로 id만 지원함 left-recursion이 있어도 됨 Top-down parsing은 다음과 같은 방식으로 시작된다.
tree를 만드는 동안 token을 하나씩 읽는다. 끝이 난다면 root node는 start symbol이 된다. 다음은 id1 * id2 에 대한 예시이다. 즉 reversed order Rightmost Derivation이라고 볼 수 있다.
LR(1) Parsing 매 단계마다 다음 token을 받아올지 production rule을 적용할지 정해야 한다. top-down parsing과 동일하게 parsing table을 사용한다. Three Types of LR(1) Parsing Left-to-right, Rightmost derivation, 1 token lookahead SLR(1) Parsing : Simple LR(1) Parsing 우리가 다룰것 LALR(1) Parsing : Look-Ahead LR(1) Parsing SLR(1)보다 많은 grammar에 적용 가능하다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://246p.github.io/post/"},{"@type":"ListItem","position":2,"name":"3. Syntax analysis (2)","item":"https://246p.github.io/blog/3_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"3. Syntax analysis (2)","name":"3. Syntax analysis (2)","description":"Bottom-up bottom-up parsing을 수행할때는 소괄호를 지원하는 조금 다른 CFG를 사용한다\n피 연산자로 id만 지원함 left-recursion이 있어도 됨 Top-down parsing은 다음과 같은 방식으로 시작된다.\ntree를 만드는 동안 token을 하나씩 읽는다. 끝이 난다면 root node는 start symbol이 된다. 다음은 id1 * id2 에 대한 예시이다. 즉 reversed order Rightmost Derivation이라고 볼 수 있다.\nLR(1) Parsing 매 단계마다 다음 token을 받아올지 production rule을 적용할지 정해야 한다. top-down parsing과 동일하게 parsing table을 사용한다. Three Types of LR(1) Parsing Left-to-right, Rightmost derivation, 1 token lookahead SLR(1) Parsing : Simple LR(1) Parsing 우리가 다룰것 LALR(1) Parsing : Look-Ahead LR(1) Parsing SLR(1)보다 많은 grammar에 적용 가능하다.","keywords":["컴파일러","Syntax analysis","Parser","Bottom-up","CFG"],"articleBody":"Bottom-up bottom-up parsing을 수행할때는 소괄호를 지원하는 조금 다른 CFG를 사용한다\n피 연산자로 id만 지원함 left-recursion이 있어도 됨 Top-down parsing은 다음과 같은 방식으로 시작된다.\ntree를 만드는 동안 token을 하나씩 읽는다. 끝이 난다면 root node는 start symbol이 된다. 다음은 id1 * id2 에 대한 예시이다. 즉 reversed order Rightmost Derivation이라고 볼 수 있다.\nLR(1) Parsing 매 단계마다 다음 token을 받아올지 production rule을 적용할지 정해야 한다. top-down parsing과 동일하게 parsing table을 사용한다. Three Types of LR(1) Parsing Left-to-right, Rightmost derivation, 1 token lookahead SLR(1) Parsing : Simple LR(1) Parsing 우리가 다룰것 LALR(1) Parsing : Look-Ahead LR(1) Parsing SLR(1)보다 많은 grammar에 적용 가능하다. 많은 언어에서 사용된다. Canonical LR(1) Parsing LALR(1)보다 더 많은 grammar에 적용 가능하다. 복잡하다. LR(1) Grammar 위에서 소개한 CFG는 SLR(1)에 포함된다. LR(1) Parsing Overview LR(1) Parsing을 하기 위해서 두가지 작업을 수행한다.\nshift : input token을 Stack에 push 한다. reduce : Stack의 top에 있는 변수를 rule에 맞게 변형한다. 다음은 id1 * id2 에 대한 예시이다.\nStack Input Tokens id1 * id2 $ id1 *id2 $ F *id2 $ T *id2 $ T* id2 $ T*id2 $ … … E $ LR(1) Parsing 하지만 실제 LR(1) Parsing은 매우 복잡하게 작동한다.\n효율성을 위하여 state를 저장하는 Stack을 추가로 구현한다.\n또한 LR(1)의 parsing table은 LL(1)과 다르다\nRow : top element in the state stack Column : next token or reduced variable 추가로 CFG의 Rule을 새롭게 정의한다.\nCFG R1 E -\u003e E + T R2 E -\u003e T R3 T -\u003e T * F R4 F -\u003e (E) R5 F -\u003e id Parsing Table\nstate\\input id * F $ … 0 s5 g3 … accept 5 r6 … Shift action : s5\ns5 : shift a symbol and push state 5 Reduce action : r6\nreduce with rule 6 and pop state lookup table [0,F]=g3, push state 3 State Stack Symbol Stack Input Tokens Action 0 id1 * id2 $ 0 5 id1 * id2 $ s5 0 3 F * id2 $ r6 … 0 2 T * id2 $ 0 1 E $ SLR(1) Parsing Table ","wordCount":"330","inLanguage":"en","datePublished":"2024-01-10T21:32:30+09:00","dateModified":"2024-01-10T21:32:30+09:00","author":{"@type":"Person","name":"Kim-Minjoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://246p.github.io/blog/3_2/"},"publisher":{"@type":"Organization","name":"Junlog","logo":{"@type":"ImageObject","url":"https://246p.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://246p.github.io/ accesskey=h title="HOME (Alt + H)"><img src=https://246p.github.io/apple-touch-icon.png alt aria-label=logo height=35>HOME</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://246p.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://246p.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://246p.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://246p.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1Di1J0LxHNuXNiDbwFhOh2XMLAgUJtYlh/view?usp=drive_link" title=CV><span>CV</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://246p.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://246p.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">3. Syntax analysis (2)</h1><div class=post-meta><span title='2024-01-10 21:32:30 +0900 KST'>January 10, 2024</span>&nbsp;·&nbsp;Kim-Minjoon</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#bottom-up>Bottom-up</a></li><li><a href=#lr1-parsing>LR(1) Parsing</a><ul><li><a href=#three-types-of-lr1-parsing>Three Types of LR(1) Parsing</a></li><li><a href=#lr1-grammar>LR(1) Grammar</a></li><li><a href=#lr1-parsing-overview>LR(1) Parsing Overview</a></li><li><a href=#lr1-parsing-1>LR(1) Parsing</a></li><li><a href=#slr1-parsing-table>SLR(1) Parsing Table</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=bottom-up>Bottom-up<a hidden class=anchor aria-hidden=true href=#bottom-up>#</a></h2><p>bottom-up parsing을 수행할때는 소괄호를 지원하는 조금 다른 CFG를 사용한다</p><ul><li>피 연산자로 id만 지원함</li><li>left-recursion이 있어도 됨</li></ul><p><img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_2.CFG.png?raw=true" alt=CFG></p><p>Top-down parsing은 다음과 같은 방식으로 시작된다.</p><ol><li>tree를 만드는 동안 token을 하나씩 읽는다.</li><li>끝이 난다면 root node는 start symbol이 된다.</li></ol><p>다음은 id1 * id2 에 대한 예시이다.
<img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_2.Parse.png?raw=true" alt=Parse></p><p>즉 reversed order Rightmost Derivation이라고 볼 수 있다.</p><h2 id=lr1-parsing>LR(1) Parsing<a hidden class=anchor aria-hidden=true href=#lr1-parsing>#</a></h2><ul><li>매 단계마다 다음 token을 받아올지 production rule을 적용할지 정해야 한다.</li><li>top-down parsing과 동일하게 parsing table을 사용한다.</li></ul><h3 id=three-types-of-lr1-parsing>Three Types of LR(1) Parsing<a hidden class=anchor aria-hidden=true href=#three-types-of-lr1-parsing>#</a></h3><ul><li><strong>L</strong>eft-to-right, <strong>R</strong>ightmost derivation, <strong>1</strong> token lookahead</li><li>SLR(1) Parsing : <strong>S</strong>imple <strong>LR(1)</strong> Parsing<ul><li>우리가 다룰것</li></ul></li><li>LALR(1) Parsing : <strong>L</strong>ook-<strong>A</strong>head <strong>LR(1)</strong> Parsing<ul><li>SLR(1)보다 많은 grammar에 적용 가능하다.</li><li>많은 언어에서 사용된다.</li></ul></li><li>Canonical LR(1) Parsing<ul><li>LALR(1)보다 더 많은 grammar에 적용 가능하다.</li><li>복잡하다.</li></ul></li></ul><h3 id=lr1-grammar>LR(1) Grammar<a hidden class=anchor aria-hidden=true href=#lr1-grammar>#</a></h3><ul><li>위에서 소개한 CFG는 SLR(1)에 포함된다.</li></ul><p><img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_2.Grammar_diagram.png?raw=true" alt=Grammar_diagram></p><h3 id=lr1-parsing-overview>LR(1) Parsing Overview<a hidden class=anchor aria-hidden=true href=#lr1-parsing-overview>#</a></h3><p>LR(1) Parsing을 하기 위해서 두가지 작업을 수행한다.</p><ul><li>shift : input token을 Stack에 push 한다.</li><li>reduce : Stack의 top에 있는 변수를 rule에 맞게 변형한다.</li></ul><p>다음은 id1 * id2 에 대한 예시이다.</p><table><thead><tr><th style=text-align:left>Stack</th><th style=text-align:right>Input Tokens</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:right>id1 * id2 $</td></tr><tr><td style=text-align:left>id1</td><td style=text-align:right>*id2 $</td></tr><tr><td style=text-align:left>F</td><td style=text-align:right>*id2 $</td></tr><tr><td style=text-align:left>T</td><td style=text-align:right>*id2 $</td></tr><tr><td style=text-align:left>T*</td><td style=text-align:right>id2 $</td></tr><tr><td style=text-align:left>T*id2</td><td style=text-align:right>$</td></tr><tr><td style=text-align:left>&mldr;</td><td style=text-align:right>&mldr;</td></tr><tr><td style=text-align:left>E</td><td style=text-align:right>$</td></tr></tbody></table><h3 id=lr1-parsing-1>LR(1) Parsing<a hidden class=anchor aria-hidden=true href=#lr1-parsing-1>#</a></h3><p>하지만 실제 LR(1) Parsing은 매우 복잡하게 작동한다.</p><p>효율성을 위하여 state를 저장하는 Stack을 추가로 구현한다.</p><p>또한 LR(1)의 parsing table은 LL(1)과 다르다</p><ul><li>Row : top element in the state stack</li><li>Column : next token or reduced variable</li></ul><p>추가로 CFG의 Rule을 새롭게 정의한다.</p><table><thead><tr><th style=text-align:left>CFG</th><th></th></tr></thead><tbody><tr><td style=text-align:left>R1</td><td style=text-align:left>E -> E + T</td></tr><tr><td style=text-align:left>R2</td><td style=text-align:left>E -> T</td></tr><tr><td style=text-align:left>R3</td><td style=text-align:left>T -> T * F</td></tr><tr><td style=text-align:left>R4</td><td style=text-align:left>F -> (E)</td></tr><tr><td style=text-align:left>R5</td><td style=text-align:left>F -> id</td></tr></tbody></table><p>Parsing Table</p><table><thead><tr><th style=text-align:center>state\input</th><th style=text-align:center>id</th><th style=text-align:center>*</th><th style=text-align:center>F</th><th style=text-align:center>$</th><th style=text-align:center>&mldr;</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>s5</td><td style=text-align:center></td><td style=text-align:center>g3</td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>&mldr;</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>accept</td><td style=text-align:center></td></tr><tr><td style=text-align:center>5</td><td style=text-align:center></td><td style=text-align:center>r6</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr><tr><td style=text-align:center>&mldr;</td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>Shift action : s5</p><ul><li>s5 : shift a symbol and push state 5</li></ul><p>Reduce action : r6</p><ul><li>reduce with rule 6 and pop state</li><li>lookup table [0,F]=g3, push state 3<table><thead><tr><th style=text-align:left>State Stack</th><th style=text-align:left>Symbol Stack</th><th style=text-align:right>Input Tokens</th><th style=text-align:right>Action</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left></td><td style=text-align:right>id1 * id2 $</td><td style=text-align:right></td></tr><tr><td style=text-align:left>0 5</td><td style=text-align:left>id1</td><td style=text-align:right>* id2 $</td><td style=text-align:right>s5</td></tr><tr><td style=text-align:left>0 3</td><td style=text-align:left>F</td><td style=text-align:right>* id2 $</td><td style=text-align:right>r6</td></tr><tr><td style=text-align:left>&mldr;</td><td style=text-align:left></td><td style=text-align:right></td><td style=text-align:right></td></tr><tr><td style=text-align:left>0 2</td><td style=text-align:left>T</td><td style=text-align:right>* id2 $</td><td style=text-align:right></td></tr><tr><td style=text-align:left>0 1</td><td style=text-align:left>E</td><td style=text-align:right>$</td><td style=text-align:right></td></tr></tbody></table></li></ul><h3 id=slr1-parsing-table>SLR(1) Parsing Table<a hidden class=anchor aria-hidden=true href=#slr1-parsing-table>#</a></h3><p><img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_2.SLR_Table.png?raw=true" alt=SLR_Table></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://246p.github.io/tags/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC/>컴파일러</a></li><li><a href=https://246p.github.io/tags/syntax-analysis/>Syntax analysis</a></li><li><a href=https://246p.github.io/tags/parser/>Parser</a></li><li><a href=https://246p.github.io/tags/bottom-up/>Bottom-up</a></li><li><a href=https://246p.github.io/tags/cfg/>CFG</a></li></ul><nav class=paginav><a class=next href=https://246p.github.io/blog/3_1/><span class=title>Next »</span><br><span>3. Syntax analysis (1)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://246p.github.io/>Junlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>