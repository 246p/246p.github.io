<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution | Junlog</title>
<meta name=keywords content="2024,학부연구생,논문,symbolic execution,dynamic taint analysis"><meta name=description content="All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution
0. Abstract Dynamic taint analysis & forward Symbolic execution을 이용하여 다음과 같은 일을 많이 수행함
1. Input Filter Generation 2. Test case generation 3. Vulnerabiliry discovery 이와 관련하여 이 논문은 두가지 파트로 되어있음
1. dynamic taint analysis와 forward symbolic execution을 수행할 수 있는 general language 제시 2. 이를 구현함에 있어서 important implementation choices, common pitfalls, considerations 1."><meta name=author content="Kim-Minjoon"><link rel=canonical href=https://246p.github.io/blog/paper_1/><meta name=google-site-verification content="GTM-524D7HPF"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution"><meta property="og:description" content="All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution
0. Abstract Dynamic taint analysis & forward Symbolic execution을 이용하여 다음과 같은 일을 많이 수행함
1. Input Filter Generation 2. Test case generation 3. Vulnerabiliry discovery 이와 관련하여 이 논문은 두가지 파트로 되어있음
1. dynamic taint analysis와 forward symbolic execution을 수행할 수 있는 general language 제시 2. 이를 구현함에 있어서 important implementation choices, common pitfalls, considerations 1."><meta property="og:type" content="article"><meta property="og:url" content="https://246p.github.io/blog/paper_1/"><meta property="og:image" content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-02-02T01:26:10+09:00"><meta property="article:modified_time" content="2024-02-02T01:26:10+09:00"><meta property="og:site_name" content="Junlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta name=twitter:title content="1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution"><meta name=twitter:description content="All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution
0. Abstract Dynamic taint analysis & forward Symbolic execution을 이용하여 다음과 같은 일을 많이 수행함
1. Input Filter Generation 2. Test case generation 3. Vulnerabiliry discovery 이와 관련하여 이 논문은 두가지 파트로 되어있음
1. dynamic taint analysis와 forward symbolic execution을 수행할 수 있는 general language 제시 2. 이를 구현함에 있어서 important implementation choices, common pitfalls, considerations 1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://246p.github.io/post/"},{"@type":"ListItem","position":2,"name":"1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution","item":"https://246p.github.io/blog/paper_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution","name":"1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution","description":"All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution\n0. Abstract Dynamic taint analysis \u0026amp; forward Symbolic execution을 이용하여 다음과 같은 일을 많이 수행함\n1. Input Filter Generation 2. Test case generation 3. Vulnerabiliry discovery 이와 관련하여 이 논문은 두가지 파트로 되어있음\n1. dynamic taint analysis와 forward symbolic execution을 수행할 수 있는 general language 제시 2. 이를 구현함에 있어서 important implementation choices, common pitfalls, considerations 1.","keywords":["2024","학부연구생","논문","symbolic execution","dynamic taint analysis"],"articleBody":"All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution\n0. Abstract Dynamic taint analysis \u0026 forward Symbolic execution을 이용하여 다음과 같은 일을 많이 수행함\n1. Input Filter Generation 2. Test case generation 3. Vulnerabiliry discovery 이와 관련하여 이 논문은 두가지 파트로 되어있음\n1. dynamic taint analysis와 forward symbolic execution을 수행할 수 있는 general language 제시 2. 이를 구현함에 있어서 important implementation choices, common pitfalls, considerations 1. Introduction Dynamic analysis Dynamic analysis는 actual excution에 대한 추론을 가능하게함 한번에 하나의 실행에 대해서 고려함 다음 두가지 사항이 일반적으로 사용됨\n1. dynamic taint analysis - 미리 정의된 taint sources (ex user input)가 미치는 영향을 관찰함 2. forward symbolic execution - logical formula를 자동으로 형성하여 논리 축약을 실행함 이 두가지 분석은 다음과 같이 함께 사용되기도 한다.\nUnkown Vulnerability Detection 알려지지 않은 취약점을 탐지한다, code injection을 막을 수 있다.\nAutomatic Input Filter Generation 입력에서 exploite을 탐지하고 제거하는 Input Filter를 자동으로 생성하는데 사용된다.\nMalware Analysis Malware Binary를 통하여 정보가 어떻게 이동하는지 확인할 수 있다.\nTest Case Generation 프로그램을 테스트 하기 위한 입력을 자동으로 생성하는데 사용된다.\n이를 실제로 구현화는 과정속에서 여러 한계점, 구현 요령, 타협점을 찾게 된다. 따라서 이 논문은 다음과 같은 내용을 소개한다.\n1. Dynamic taint Analysis 와 forward symbolic exceution을 공식화한다. 2. 공식화한 내용을 바탕으로 implementation details, caveats, and choices 를 설명한다. 2. A General Language Overview dynamic taint analysis과 forward symbolilc execution은 는 특정 언어에 대해서 정의되어왔다.\n이 논문에서 SimpIL (Simple Intermediate Language)을 제시하고 있다.\n이 언어는 다양한 프로그래밍 언어에 대한 컴파일러에서 사용하는 내부 표현을 표현할 수 있다.\n이 언어는 numbered statements로 이루어져 있고 assignments, assertions, jumps, conditional jump로 이루어져 있다. 또한 get_input을 통하여 사용자의 입력을 받을 수 있다. 또한 32-bit정수에 대해서만 교려한다. 이를 확장하는것은 간단하다.\nOperational Semantics Operation semantics는 해당 언어로 작성된 프로그램을 어떻게 실행할지 엄밀하게 정의한다. 이를 통하여 실행을 기반으로 정의되는 dynamic program analyses를 정의하는 방법이 된다.\n프로그램을 실행할때 패턴 매칭을 통하여 statement에 맞는 applicable rule을 찾는다.\nLanguage Discussion 이 언어는 Dynamic taint analysis와 forward symbolic execution을 보이기 위하여 디자인 되었기 때문에 function, scope에 대한 구현을 하지 않았다. 이러한 생략은 다음과 같은 두가지 접근방법으로 간단하게 추가할 수 있다.\n1. high-level 언어를 SimpIL로 컴파일 함수, 버퍼에 대한 추상화는 BAP, BitBlaze와 같은 도구를 이용하여 가능하다. 이전 다른 연구를 통하여 이를 증명하였다.\n2. higher-level constructs를 SimpIL에 추가 예를들어 Call, RET 명령을 추가하여 직접 function을 지원할 수 있다.\n3. Dynamic Taint Analysis Dynamic taint analysis는 sources(input)와 sinks(중요한곳) 사이의 흐름을 추적하는 것이다. taint source에서 파상된 데이터에 의존하는 모든 값은 taint되었다고 간주한다.\ntaint policy는 taint된 값이 실행중에 어떻게 이동하는지, 어떤 종류의 작업이 taint를 도입하는지, taint된 값에 대한 어떤 검사를 수행하는지를 의미한다.\n이는 taint analysis application에 따라 다르다. 하지만 원론적인 concepts는 같다.\n이와 관련하여 두가지 오류가 존재한다.\n1. Oveertainted - 값이 taint source에서 파생되지 않음에도 오염된것으로 판단함 2. Undertainted - taint된 값임에도 불구하고 이를 탐지하지 못함 이 두 오류를 줄여야 한다.\nDynamic Taint Analysis Sematntics 각 프로그램의 taint된 상태를 확인하기 위하여 우리의 언어의 값들을 다음과 같이 튜플 로 재 정의한다. v는 기존 언어에서 의미하는 값이고 τ는 taint되어 있는지를 의미한다.\n아래와 같이 taint analysis policy를 확인한다.\nDynamic Taint Policies taint policty는 3가지 성질을 지정한다.\n1. 새로운 taint의 도입 2. taint의 전파 3. taint의 확인 Taint Introduction 일반적으로 모든 변수, 메모리의 값이 초기화될때 taint되지 않았다고 가정한다.\nSimpIL에서 get_input이라는 하나의 input source만 가지고 있다.\n하지만 실제 구현에서 여러가지 input source를 가지고 있다. 일반적으로 input source들을 구분한다. 예를들어 인터넷을 통해 들어오는 네트워크 입력은 taint를 도입할 수 있지만 신뢰할수 있는 파일에서 읽는 정보는 그렇지 않다.\n특정 taint source를 독립적으로 추적할 수 있다.\nTaint Propagation taint policy는 기존 데이터에섯 파생된 데이터의 오염상태를 지정한다. 예를 들어 t_1 or t_2는 t_1 또는 t_2가 taint 되어있을때 결과가 taint 되어있음을 의미한다.\nTaint Checking 값이 taint되었는지 확인하기 위하여 taint checking을 수행한다. 예를들어 P_gotocheck(t)는 해당 주소가 taint된 값을 가질때 jump를 수행하는것이 안전하면 T를 반환한다. 만약 F가 반환되면 프로그램이 비정상적으로 종료된다.\nA Typical Taint Policy 아래와 같은 typical attack detection policy를 tainted jump policy라고 한다.\ntainted jump policy는 control flow hijacking 공격을 방어하기 위함이다.\n주요 아이디어는 입력에서 파생된 값이 return address나 function pointer을 덮어쓰지 않게 한다. 즉 jump에 대한 안정성을 보장하는 것이다.\n이 를 구현하기 위하여 get_input에 의해 반환된 모든 값에 taint를 도입한다. 이후 taint된 값이 이항 연산등을 통하여 프로그램으로 직접적으로 퍼지게 된다.\nDifferent Policies for Different Applications 응용프로그램에 맞게 taint policy를 정해야 한다. 특히 Table III에 설명된 typical taint policy는 메모리 주소 오염에 대한 고려를 하지 못한다.\nDynamic Taint Analysis Challenges and Opportunities dynamic taint analysis와 관련하여 고려할 사항들이 있다.\nTainted Addresses 메모리 연산은 메모리 셀의 주소와 해당 셀에 저장된 값이 관여한다.\nTable III의 tainted jump policy는 이를 독립적으로 추적한다.\n예를들어 다음과 같은 프로그램을 생각해보자.\n1 2 3 x := get_input(·) y := load(z+x) goto y 이와같은 코드는 모든 메모리 주소에 접근할 수 있다.\n기존 tainted jump policy는 이를 탑지하지 못할 수 있다. 이를 해결하기 위하여 tainted address policy를 사용할 수 있다.\n물론 이와같이 확장할경우 overtaint의 위혐이 있다. 즉 jump에 대한 검사의 undertaint와 address에 대한 검사의 overtaint를 잘 조절해야한다.\nControl-flow taint control-flow를 통하여 data flow가 변할 수 있다. 이를 고려하지 않으면 taint를 결정할 수 업시게 전체 분석이 undertaint될 수 있다. 불행히 순수한 dynamical taint analysis를 통해서는 contro-flow taint를 계산할 수 없다. 왜냐하면 단일 execution에서는 하나의 path만 실행되기 때문이다.\n이 문제를 해결하기 위해선 다음과 같은 해결방법이 있다.\n1. static analysis 사용 - static analysis를 통하여 control-flow를 계산할 수 있다. 2. heuristics 사용 - heuristics을 사용하여 상황에따라 overtaitn, undertaint할지 결정한다. Sanitization Dynamic taint analysis는 taint를 추가 한다. (제거하지 않는다) 이는 프로그램이 실행될때 계속 더 많은 값이 taint 되는 taint spread 문제를 발생시킨다.\ntaint analysis에서는 값에서 taint를 제거하는것 또한 중요하다. 예를 들어서 b = a ^ a 는 b를 0으로 초기화 되는 의미이지만 taint하다고 판단할 수 있다. 이를 방지하여야 한다.\nTime of Detection vs Time of Attack taint가 전파되는 시간과 그 taint가 발생하는 시간과의 차이가 존재한다.\n4. Forward Symbolic Execution Forward Symbolic Execution은 다양한 입력에 따라 프로그램의 동작을 한번에 추론할 수 있도록 한다.\nApplications and Advantages Multiple Input\n한번에 여러 입력에 대해 분석할 수 있다.\nSemantics of Forward Symbolic Execution 일반 실행과 Forward Symbolic Execution의 차이점은 get_input()의 결과가 구체적인 값 대신 기호를 반환한다. 기호를 포함하는 표현식은 구체적인 값으로 평가될 수 없다. SimpIL언어를 Table VI와 같이 확장된다.\nForward Symbolic Execution Challenges and Opportunities Symbolic Memory Addresses 메모리에서 값을 저장하거나 불러올때 참조되는 주소가 구체적인 값이 아닌 사용자 입력에 파생된 표현식(기호)일때 발생하는 문제이다.\n실제 프로그램에서도 사용자 입력에 따라 달라지는 테이블 조회 등 여러 형태로 빈번하게 발생하는 문제이다.\nSymbolic Memory Addresses는 Single path에 대한 execution에서도 aliasing issues를 발생할 수 있다. 두 값이 동일한 주소를 참조할때 발생한다.\n이를 해결하기위하여 메모리를 참조할때 두가지 방법이 사용된다\n1. Symbolic Memory Address를 제거하기 위하여 건전하지 않는 가정을 한다. 이 논문에서는 코드를 변형하였다. 2. SMT Solver에서 이를 수행하도록 한다. 3. 두 값이 동일한 주소를 가르키고 있는지 추론하기위하여 alias analysis를 수행한다. Path Selection 경로가 분기될때 어떠한 분기를 먼저 탐색할지 결정해야 한다. Smmbolic Execution을 수행할때 이를 tree로 생각할 수 있다. 분석은 tree의 root node에서 시작하여 fork가 발생할때 child node를 생성한다. 이때 다음 탐색할 node를 결정하는 것은 중요하다 왜냐하면 무한 루프에 빠질 수 있기 때문이다.\n이와 같은 “stuck\"인 상황을 회피하기 위하여 다음과 같은 방법을 사용할 수 있다.\nDepth-First-Search 탐색시 maximum depth를 설정하여 무한 루프를 방지한다.\nConcolic Testing Concolic Testing은 구체적인 실행을 사용하여 프로그램 실행을 추적하는 것이다. Forward Symbolic Execution과 동일한 경로를 따르지만 조건을 선택하고 해당 조건문을 부정하여 다른 경로로 강제할 구체적 입력을 생성할 수 있다.\nRandom Paths random하게 탐색을 할 경우 더 낮은 상태에 대해 더 높은 가중치를 부여하여 stuck을 방지할 수 있다.\nHeuristics 아직 다루지 않은 코드에 도달할 가능성이 높은 상태에 더 많은 가중치를 준다. 실행되지 않은 명령어까지의 거리 등을 변수로 한다.\nSymbolic Jumps GOTO 규칙은 LOAD및 STORE와 비슷하다. 하지만 Forward Symbolic Execution에서는 Jump target이 구체적인 위치가 아닌 표현식 일 수 있다. 이와같은 문제를 Symblic jump problem 이라고 한다.\n이 문제는 많은 연구에서 직접적으로 다루지 않고 있다. 다음은 Symblic jump을 다루는 3가지 방법이다.\nUse Concolic analysis Concolic analysis를 사용하여 간접적으로 jump targets을 확인한다. concrete execution 에서 점프 대상이 확인되면 이를 symbolic execution에 적용하는 것이다.\n단점은 알려진 jump targets만 탐색하기 때문에 프로그램의 전체를 탐색하기는 더 어려워진다.\nUse SMT solver SMT solver를 이용하여 변수에 대한 값 할당(구체적인 점프 대상)을 얻고 이 값을 부정하는 합집합을 다시 SMT solver에 요청한다. 효육적이지 못하다.\nUse Static analysis 정적분석을 사용하여 전체 프로그램에 대한 추론과 가능한 jump target을 찾을 수 있다. Binary-level jump static analyses는 해당 식에서 참조될 수 있는 값들에 대해 추론할 수 있다.\nHandling System and Library Calls C 언어의 read와 같은 함수로 interupt가 발생할 수 있다. 이때 read가 새로운 기호 입력을 반환하게 하게 한다.\nconcolic 기반으로 접근한다면 간단하다는 장점을 갖고 있다.\n구현하기 쉽고 프로그램이 환경과 상호작용하는 문제를 우회한다. 반면 완벅한 분석을 제공하지 않는다. 왜냐하면 일부 호출은 동일한 입력을 받더라도 같은 결과를 반환하지 않기 때문이다.\nPerformance 이 방법의 효율성에 대해서 생각해보면\n1. exponential number of program branches 2. exponential number of formulas 3. exponentially sized formula per branch 각 분기지점에서 fork가 발생하기 때문에 expontential 하게 늘어난다. 이를 해결하기 위하여 다음과 같은 방법이 사용된다\n더 좋은 하드웨어 사용 치환으로 expotential하지 않게 변형 formula의 중복을 제거 subformula에 대한 정보를 cache에 저장하여 재사용 weakest precondition 사용 Mixed Execution 실제로 사용되는 프로그램의 유형에 따라 symbolic input을 특정 형식의 입력으로 제한할 수 있다.\n일부 입력은 구체적으로 허용하고 일부 입력을 기호적으로 허용한 것을 mixed execution이라고 한다.\n이는 구체적인 값에 관한 계산을 프로세서에서 수행할 수 있도록 한다. 즉 사용자 입력에 의존하지 않는 부분은 concrete execution의 속도로 실행할 수 있다.\n5. Related Work Formalization and Systematization Dynamic Security mechanisms은 새로운것은 아니지만 이전 연구들은 dynamic taint analysis와 forward symbolic execution을 형식화 하지 않았다.\n이 논문은 프로그래밍 언어를 정의하여 의미론적 모호성을 해소하였다.\nApplications Automatic Test-case Generation Automatic Filter Generation Automatic Network Protocol Understanding Malware Analysis Web Applications Taint Performance \u0026 Frameworks Extensions to Taint Analysis ","wordCount":"1548","inLanguage":"en","datePublished":"2024-02-02T01:26:10+09:00","dateModified":"2024-02-02T01:26:10+09:00","author":{"@type":"Person","name":"Kim-Minjoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://246p.github.io/blog/paper_1/"},"publisher":{"@type":"Organization","name":"Junlog","logo":{"@type":"ImageObject","url":"https://246p.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://246p.github.io/ accesskey=h title="HOME (Alt + H)"><img src=https://246p.github.io/apple-touch-icon.png alt aria-label=logo height=35>HOME</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://246p.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://246p.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://246p.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://246p.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1Di1J0LxHNuXNiDbwFhOh2XMLAgUJtYlh/view?usp=drive_link" title=CV><span>CV</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://246p.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://246p.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution</h1><div class=post-meta><span title='2024-02-02 01:26:10 +0900 KST'>February 2, 2024</span>&nbsp;·&nbsp;Kim-Minjoon</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#dynamic-analysis>Dynamic analysis</a><ul><li><a href=#unkown-vulnerability-detection>Unkown Vulnerability Detection</a></li><li><a href=#automatic-input-filter-generation>Automatic Input Filter Generation</a></li><li><a href=#malware-analysis>Malware Analysis</a></li><li><a href=#test-case-generation>Test Case Generation</a></li></ul></li></ul><ul><li><a href=#overview>Overview</a></li><li><a href=#operational-semantics>Operational Semantics</a></li><li><a href=#language-discussion>Language Discussion</a><ul><li><a href=#1-high-level-언어를-simpil로-컴파일>1. high-level 언어를 SimpIL로 컴파일</a></li><li><a href=#2-higher-level-constructs를-simpil에-추가>2. higher-level constructs를 SimpIL에 추가</a></li></ul></li></ul><ul><li><a href=#dynamic-taint-analysis-sematntics>Dynamic Taint Analysis Sematntics</a></li><li><a href=#dynamic-taint-policies>Dynamic Taint Policies</a><ul><li><a href=#taint-introduction>Taint Introduction</a></li><li><a href=#taint-propagation>Taint Propagation</a></li><li><a href=#taint-checking>Taint Checking</a></li></ul></li><li><a href=#a-typical-taint-policy>A Typical Taint Policy</a><ul><li><a href=#different-policies-for-different-applications>Different Policies for Different Applications</a></li></ul></li><li><a href=#dynamic-taint-analysis-challenges-and-opportunities>Dynamic Taint Analysis Challenges and Opportunities</a><ul><li><a href=#tainted-addresses>Tainted Addresses</a></li><li><a href=#control-flow-taint>Control-flow taint</a></li><li><a href=#sanitization>Sanitization</a></li><li><a href=#time-of-detection-vs-time-of-attack>Time of Detection vs Time of Attack</a></li></ul></li></ul><ul><li><a href=#applications-and-advantages>Applications and Advantages</a></li><li><a href=#semantics-of-forward-symbolic-execution>Semantics of Forward Symbolic Execution</a></li><li><a href=#forward-symbolic-execution-challenges-and-opportunities>Forward Symbolic Execution Challenges and Opportunities</a><ul><li><a href=#symbolic-memory-addresses>Symbolic Memory Addresses</a></li><li><a href=#path-selection>Path Selection</a></li><li><a href=#symbolic-jumps>Symbolic Jumps</a></li><li><a href=#handling-system-and-library-calls>Handling System and Library Calls</a></li><li><a href=#performance>Performance</a></li><li><a href=#mixed-execution>Mixed Execution</a></li></ul></li></ul><ul><li><a href=#formalization-and-systematization>Formalization and Systematization</a></li><li><a href=#applications>Applications</a></li></ul></nav></div></details></div><div class=post-content><p><a href=https://users.ece.cmu.edu/~aavgerin/papers/Oakland10.pdf>All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution</a></p><h1 id=0-abstract>0. Abstract<a hidden class=anchor aria-hidden=true href=#0-abstract>#</a></h1><p>Dynamic taint analysis & forward Symbolic execution을 이용하여 다음과 같은 일을 많이 수행함</p><pre><code>1. Input Filter Generation
2. Test case generation
3. Vulnerabiliry discovery
</code></pre><p>이와 관련하여 이 논문은 두가지 파트로 되어있음</p><pre><code>1. dynamic taint analysis와 forward symbolic execution을 수행할 수 있는 general language 제시
2. 이를 구현함에 있어서 important implementation choices, common pitfalls, considerations 
</code></pre><h1 id=1-introduction>1. Introduction<a hidden class=anchor aria-hidden=true href=#1-introduction>#</a></h1><h2 id=dynamic-analysis>Dynamic analysis<a hidden class=anchor aria-hidden=true href=#dynamic-analysis>#</a></h2><ul><li>Dynamic analysis는 actual excution에 대한 추론을 가능하게함</li><li>한번에 하나의 실행에 대해서 고려함</li></ul><p>다음 두가지 사항이 일반적으로 사용됨</p><pre><code>1. dynamic taint analysis
    - 미리 정의된 taint sources (ex user input)가 미치는 영향을 관찰함
2. forward symbolic execution
    - logical formula를 자동으로 형성하여 논리 축약을 실행함
</code></pre><p>이 두가지 분석은 다음과 같이 함께 사용되기도 한다.</p><h3 id=unkown-vulnerability-detection>Unkown Vulnerability Detection<a hidden class=anchor aria-hidden=true href=#unkown-vulnerability-detection>#</a></h3><p>알려지지 않은 취약점을 탐지한다, code injection을 막을 수 있다.</p><h3 id=automatic-input-filter-generation>Automatic Input Filter Generation<a hidden class=anchor aria-hidden=true href=#automatic-input-filter-generation>#</a></h3><p>입력에서 exploite을 탐지하고 제거하는 Input Filter를 자동으로 생성하는데 사용된다.</p><h3 id=malware-analysis>Malware Analysis<a hidden class=anchor aria-hidden=true href=#malware-analysis>#</a></h3><p>Malware Binary를 통하여 정보가 어떻게 이동하는지 확인할 수 있다.</p><h3 id=test-case-generation>Test Case Generation<a hidden class=anchor aria-hidden=true href=#test-case-generation>#</a></h3><p>프로그램을 테스트 하기 위한 입력을 자동으로 생성하는데 사용된다.</p><p>이를 실제로 구현화는 과정속에서 여러 한계점, 구현 요령, 타협점을 찾게 된다. 따라서 이 논문은 다음과 같은 내용을 소개한다.</p><pre><code>1. Dynamic taint Analysis 와 forward symbolic exceution을 공식화한다.
2. 공식화한 내용을 바탕으로 implementation details, caveats, and choices 를 설명한다. 
</code></pre><h1 id=2-a-general-language>2. A General Language<a hidden class=anchor aria-hidden=true href=#2-a-general-language>#</a></h1><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>dynamic taint analysis과 forward symbolilc execution은 는 특정 언어에 대해서 정의되어왔다.</p><p>이 논문에서 SimpIL (<strong>Simp</strong>le <strong>I</strong>ntermediate <strong>L</strong>anguage)을 제시하고 있다.</p><p><img loading=lazy src=./../../image/paper_1_table1.png alt=table1></p><p>이 언어는 다양한 프로그래밍 언어에 대한 컴파일러에서 사용하는 내부 표현을 표현할 수 있다.</p><p>이 언어는 numbered statements로 이루어져 있고 assignments, assertions, jumps, conditional jump로 이루어져 있다. 또한 get_input을 통하여 사용자의 입력을 받을 수 있다. 또한 32-bit정수에 대해서만 교려한다. 이를 확장하는것은 간단하다.</p><h2 id=operational-semantics>Operational Semantics<a hidden class=anchor aria-hidden=true href=#operational-semantics>#</a></h2><p>Operation semantics는 해당 언어로 작성된 프로그램을 어떻게 실행할지 엄밀하게 정의한다. 이를 통하여 실행을 기반으로 정의되는 dynamic program analyses를 정의하는 방법이 된다.</p><p><img loading=lazy src=./../../image/paper_1_figure1.png alt=figure1>
프로그램을 실행할때 패턴 매칭을 통하여 statement에 맞는 applicable rule을 찾는다.</p><h2 id=language-discussion>Language Discussion<a hidden class=anchor aria-hidden=true href=#language-discussion>#</a></h2><p>이 언어는 Dynamic taint analysis와 forward symbolic execution을 보이기 위하여 디자인 되었기 때문에 function, scope에 대한 구현을 하지 않았다. 이러한 생략은 다음과 같은 두가지 접근방법으로 간단하게 추가할 수 있다.</p><h3 id=1-high-level-언어를-simpil로-컴파일>1. high-level 언어를 SimpIL로 컴파일<a hidden class=anchor aria-hidden=true href=#1-high-level-언어를-simpil로-컴파일>#</a></h3><p>함수, 버퍼에 대한 추상화는 BAP, BitBlaze와 같은 도구를 이용하여 가능하다. 이전 다른 연구를 통하여 이를 증명하였다.</p><h3 id=2-higher-level-constructs를-simpil에-추가>2. higher-level constructs를 SimpIL에 추가<a hidden class=anchor aria-hidden=true href=#2-higher-level-constructs를-simpil에-추가>#</a></h3><p>예를들어 Call, RET 명령을 추가하여 직접 function을 지원할 수 있다.</p><h1 id=3-dynamic-taint-analysis>3. Dynamic Taint Analysis<a hidden class=anchor aria-hidden=true href=#3-dynamic-taint-analysis>#</a></h1><p>Dynamic taint analysis는 sources(input)와 sinks(중요한곳) 사이의 흐름을 추적하는 것이다. taint source에서 파상된 데이터에 의존하는 모든 값은 taint되었다고 간주한다.</p><p>taint policy는 taint된 값이 실행중에 어떻게 이동하는지, 어떤 종류의 작업이 taint를 도입하는지, taint된 값에 대한 어떤 검사를 수행하는지를 의미한다.</p><p>이는 taint analysis application에 따라 다르다. 하지만 원론적인 concepts는 같다.</p><p>이와 관련하여 두가지 오류가 존재한다.</p><pre><code>1. Oveertainted
 - 값이 taint source에서 파생되지 않음에도 오염된것으로 판단함
2. Undertainted
 - taint된 값임에도 불구하고 이를 탐지하지 못함
</code></pre><p>이 두 오류를 줄여야 한다.</p><h2 id=dynamic-taint-analysis-sematntics>Dynamic Taint Analysis Sematntics<a hidden class=anchor aria-hidden=true href=#dynamic-taint-analysis-sematntics>#</a></h2><p>각 프로그램의 taint된 상태를 확인하기 위하여 우리의 언어의 값들을 다음과 같이 튜플 &lt;v,τ> 로 재 정의한다. v는 기존 언어에서 의미하는 값이고 τ는 taint되어 있는지를 의미한다.</p><p><img loading=lazy src=./../../image/paper_1_table2.png alt=table2></p><p>아래와 같이 taint analysis policy를 확인한다.</p><p><img loading=lazy src=./../../image/paper_1_figure5.png alt=figure5></p><h2 id=dynamic-taint-policies>Dynamic Taint Policies<a hidden class=anchor aria-hidden=true href=#dynamic-taint-policies>#</a></h2><p>taint policty는 3가지 성질을 지정한다.</p><pre><code>1. 새로운 taint의 도입
2. taint의 전파
3. taint의 확인
</code></pre><h3 id=taint-introduction>Taint Introduction<a hidden class=anchor aria-hidden=true href=#taint-introduction>#</a></h3><p>일반적으로 모든 변수, 메모리의 값이 초기화될때 taint되지 않았다고 가정한다.</p><p>SimpIL에서 get_input이라는 하나의 input source만 가지고 있다.</p><p>하지만 실제 구현에서 여러가지 input source를 가지고 있다. 일반적으로 input source들을 구분한다. 예를들어 인터넷을 통해 들어오는 네트워크 입력은 taint를 도입할 수 있지만 신뢰할수 있는 파일에서 읽는 정보는 그렇지 않다.</p><p>특정 taint source를 독립적으로 추적할 수 있다.</p><h3 id=taint-propagation>Taint Propagation<a hidden class=anchor aria-hidden=true href=#taint-propagation>#</a></h3><p>taint policy는 기존 데이터에섯 파생된 데이터의 오염상태를 지정한다. 예를 들어 t_1 or t_2는 t_1 또는 t_2가 taint 되어있을때 결과가 taint 되어있음을 의미한다.</p><h3 id=taint-checking>Taint Checking<a hidden class=anchor aria-hidden=true href=#taint-checking>#</a></h3><p>값이 taint되었는지 확인하기 위하여 taint checking을 수행한다.
예를들어 P_gotocheck(t)는 해당 주소가 taint된 값을 가질때 jump를 수행하는것이 안전하면 T를 반환한다. 만약 F가 반환되면 프로그램이 비정상적으로 종료된다.</p><h2 id=a-typical-taint-policy>A Typical Taint Policy<a hidden class=anchor aria-hidden=true href=#a-typical-taint-policy>#</a></h2><p>아래와 같은 typical attack detection policy를 tainted jump policy라고 한다.</p><p><img loading=lazy src=./../../image/paper_1_table3.png alt=table3></p><p>tainted jump policy는 control flow hijacking 공격을 방어하기 위함이다.</p><p>주요 아이디어는 입력에서 파생된 값이 return address나 function pointer을 덮어쓰지 않게 한다. 즉 jump에 대한 안정성을 보장하는 것이다.</p><p>이 를 구현하기 위하여 get_input에 의해 반환된 모든 값에 taint를 도입한다. 이후 taint된 값이 이항 연산등을 통하여 프로그램으로 직접적으로 퍼지게 된다.</p><h3 id=different-policies-for-different-applications>Different Policies for Different Applications<a hidden class=anchor aria-hidden=true href=#different-policies-for-different-applications>#</a></h3><p>응용프로그램에 맞게 taint policy를 정해야 한다.
특히 Table III에 설명된 typical taint policy는 메모리 주소 오염에 대한 고려를 하지 못한다.</p><h2 id=dynamic-taint-analysis-challenges-and-opportunities>Dynamic Taint Analysis Challenges and Opportunities<a hidden class=anchor aria-hidden=true href=#dynamic-taint-analysis-challenges-and-opportunities>#</a></h2><p>dynamic taint analysis와 관련하여 고려할 사항들이 있다.</p><h3 id=tainted-addresses>Tainted Addresses<a hidden class=anchor aria-hidden=true href=#tainted-addresses>#</a></h3><p>메모리 연산은 메모리 셀의 주소와 해당 셀에 저장된 값이 관여한다.</p><p>Table III의 tainted jump policy는 이를 독립적으로 추적한다.</p><p>예를들어 다음과 같은 프로그램을 생각해보자.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl>    <span class=n>x</span> <span class=p>:</span><span class=o>=</span> <span class=n>get_input</span><span class=p>(</span><span class=err>·</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=p>:</span><span class=o>=</span> <span class=nb>load</span><span class=p>(</span><span class=n>z</span><span class=o>+</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>goto</span> <span class=n>y</span>
</span></span></code></pre></td></tr></table></div></div><p>이와같은 코드는 모든 메모리 주소에 접근할 수 있다.</p><p>기존 tainted jump policy는 이를 탑지하지 못할 수 있다. 이를 해결하기 위하여 tainted address policy를 사용할 수 있다.</p><p><img loading=lazy src=./../../image/paper_1_table5.png alt=table5></p><p>물론 이와같이 확장할경우 overtaint의 위혐이 있다. 즉 jump에 대한 검사의 undertaint와 address에 대한 검사의 overtaint를 잘 조절해야한다.</p><h3 id=control-flow-taint>Control-flow taint<a hidden class=anchor aria-hidden=true href=#control-flow-taint>#</a></h3><p>control-flow를 통하여 data flow가 변할 수 있다. 이를 고려하지 않으면 taint를 결정할 수 업시게 전체 분석이 undertaint될 수 있다. 불행히 순수한 dynamical taint analysis를 통해서는 contro-flow taint를 계산할 수 없다. 왜냐하면 단일 execution에서는 하나의 path만 실행되기 때문이다.</p><p>이 문제를 해결하기 위해선 다음과 같은 해결방법이 있다.</p><pre><code>1. static analysis 사용
 - static analysis를 통하여 control-flow를 계산할 수 있다.
2. heuristics 사용
 - heuristics을 사용하여 상황에따라 overtaitn, undertaint할지 결정한다.
</code></pre><h3 id=sanitization>Sanitization<a hidden class=anchor aria-hidden=true href=#sanitization>#</a></h3><p>Dynamic taint analysis는 taint를 추가 한다. (제거하지 않는다) 이는 프로그램이 실행될때 계속 더 많은 값이 taint 되는 taint spread 문제를 발생시킨다.</p><p>taint analysis에서는 값에서 taint를 제거하는것 또한 중요하다.
예를 들어서 b = a ^ a 는 b를 0으로 초기화 되는 의미이지만 taint하다고 판단할 수 있다. 이를 방지하여야 한다.</p><h3 id=time-of-detection-vs-time-of-attack>Time of Detection vs Time of Attack<a hidden class=anchor aria-hidden=true href=#time-of-detection-vs-time-of-attack>#</a></h3><p>taint가 전파되는 시간과 그 taint가 발생하는 시간과의 차이가 존재한다.</p><h1 id=4-forward-symbolic-execution>4. Forward Symbolic Execution<a hidden class=anchor aria-hidden=true href=#4-forward-symbolic-execution>#</a></h1><p>Forward Symbolic Execution은 다양한 입력에 따라 프로그램의 동작을 한번에 추론할 수 있도록 한다.</p><h2 id=applications-and-advantages>Applications and Advantages<a hidden class=anchor aria-hidden=true href=#applications-and-advantages>#</a></h2><blockquote><p>Multiple Input</p></blockquote><p>한번에 여러 입력에 대해 분석할 수 있다.</p><h2 id=semantics-of-forward-symbolic-execution>Semantics of Forward Symbolic Execution<a hidden class=anchor aria-hidden=true href=#semantics-of-forward-symbolic-execution>#</a></h2><p>일반 실행과 Forward Symbolic Execution의 차이점은 get_input()의 결과가 구체적인 값 대신 기호를 반환한다. 기호를 포함하는 표현식은 구체적인 값으로 평가될 수 없다. SimpIL언어를 Table VI와 같이 확장된다.</p><p><img loading=lazy src=./../../image/paper_1_table6.png alt=table6></p><h2 id=forward-symbolic-execution-challenges-and-opportunities>Forward Symbolic Execution Challenges and Opportunities<a hidden class=anchor aria-hidden=true href=#forward-symbolic-execution-challenges-and-opportunities>#</a></h2><h3 id=symbolic-memory-addresses>Symbolic Memory Addresses<a hidden class=anchor aria-hidden=true href=#symbolic-memory-addresses>#</a></h3><p>메모리에서 값을 저장하거나 불러올때 참조되는 주소가 구체적인 값이 아닌 사용자 입력에 파생된 표현식(기호)일때 발생하는 문제이다.</p><p>실제 프로그램에서도 사용자 입력에 따라 달라지는 테이블 조회 등 여러 형태로 빈번하게 발생하는 문제이다.</p><p>Symbolic Memory Addresses는 Single path에 대한 execution에서도 aliasing issues를 발생할 수 있다. 두 값이 동일한 주소를 참조할때 발생한다.</p><p>이를 해결하기위하여 메모리를 참조할때 두가지 방법이 사용된다</p><pre><code>1. Symbolic Memory Address를 제거하기 위하여 건전하지 않는 가정을 한다. 이 논문에서는 코드를 변형하였다.
2. SMT Solver에서 이를 수행하도록 한다.
3. 두 값이 동일한 주소를 가르키고 있는지 추론하기위하여 alias analysis를 수행한다.
</code></pre><h3 id=path-selection>Path Selection<a hidden class=anchor aria-hidden=true href=#path-selection>#</a></h3><p>경로가 분기될때 어떠한 분기를 먼저 탐색할지 결정해야 한다. Smmbolic Execution을 수행할때 이를 tree로 생각할 수 있다. 분석은 tree의 root node에서 시작하여 fork가 발생할때 child node를 생성한다. 이때 다음 탐색할 node를 결정하는 것은 중요하다 왜냐하면 무한 루프에 빠질 수 있기 때문이다.</p><p>이와 같은 &ldquo;stuck"인 상황을 회피하기 위하여 다음과 같은 방법을 사용할 수 있다.</p><h4 id=depth-first-search>Depth-First-Search<a hidden class=anchor aria-hidden=true href=#depth-first-search>#</a></h4><p>탐색시 maximum depth를 설정하여 무한 루프를 방지한다.</p><h4 id=concolic-testing>Concolic Testing<a hidden class=anchor aria-hidden=true href=#concolic-testing>#</a></h4><p>Concolic Testing은 구체적인 실행을 사용하여 프로그램 실행을 추적하는 것이다. Forward Symbolic Execution과 동일한 경로를 따르지만 조건을 선택하고 해당 조건문을 부정하여 다른 경로로 강제할 구체적 입력을 생성할 수 있다.</p><h4 id=random-paths>Random Paths<a hidden class=anchor aria-hidden=true href=#random-paths>#</a></h4><p>random하게 탐색을 할 경우 더 낮은 상태에 대해 더 높은 가중치를 부여하여 stuck을 방지할 수 있다.</p><h4 id=heuristics>Heuristics<a hidden class=anchor aria-hidden=true href=#heuristics>#</a></h4><p>아직 다루지 않은 코드에 도달할 가능성이 높은 상태에 더 많은 가중치를 준다. 실행되지 않은 명령어까지의 거리 등을 변수로 한다.</p><h3 id=symbolic-jumps>Symbolic Jumps<a hidden class=anchor aria-hidden=true href=#symbolic-jumps>#</a></h3><p>GOTO 규칙은 LOAD및 STORE와 비슷하다. 하지만 Forward Symbolic Execution에서는 Jump target이 구체적인 위치가 아닌 표현식 일 수 있다. 이와같은 문제를 Symblic jump problem 이라고 한다.</p><p>이 문제는 많은 연구에서 직접적으로 다루지 않고 있다. 다음은 Symblic jump을 다루는 3가지 방법이다.</p><h4 id=use-concolic-analysis>Use Concolic analysis<a hidden class=anchor aria-hidden=true href=#use-concolic-analysis>#</a></h4><p>Concolic analysis를 사용하여 간접적으로 jump targets을 확인한다. concrete execution 에서 점프 대상이 확인되면 이를 symbolic execution에 적용하는 것이다.</p><p>단점은 알려진 jump targets만 탐색하기 때문에 프로그램의 전체를 탐색하기는 더 어려워진다.</p><h4 id=use-smt-solver>Use SMT solver<a hidden class=anchor aria-hidden=true href=#use-smt-solver>#</a></h4><p>SMT solver를 이용하여 변수에 대한 값 할당(구체적인 점프 대상)을 얻고 이 값을 부정하는 합집합을 다시 SMT solver에 요청한다. 효육적이지 못하다.</p><h4 id=use-static-analysis>Use Static analysis<a hidden class=anchor aria-hidden=true href=#use-static-analysis>#</a></h4><p>정적분석을 사용하여 전체 프로그램에 대한 추론과 가능한 jump target을 찾을 수 있다. Binary-level jump
static analyses는 해당 식에서 참조될 수 있는 값들에 대해 추론할 수 있다.</p><h3 id=handling-system-and-library-calls>Handling System and Library Calls<a hidden class=anchor aria-hidden=true href=#handling-system-and-library-calls>#</a></h3><p>C 언어의 read와 같은 함수로 interupt가 발생할 수 있다. 이때 read가 새로운 기호 입력을 반환하게 하게 한다.</p><p>concolic 기반으로 접근한다면 간단하다는 장점을 갖고 있다.</p><p>구현하기 쉽고 프로그램이 환경과 상호작용하는 문제를 우회한다. 반면 완벅한 분석을 제공하지 않는다. 왜냐하면 일부 호출은 동일한 입력을 받더라도 같은 결과를 반환하지 않기 때문이다.</p><h3 id=performance>Performance<a hidden class=anchor aria-hidden=true href=#performance>#</a></h3><p>이 방법의 효율성에 대해서 생각해보면</p><pre><code>1. exponential number of program branches
2. exponential number of formulas
3. exponentially sized formula per branch
</code></pre><p>각 분기지점에서 fork가 발생하기 때문에 expontential 하게 늘어난다. 이를 해결하기 위하여 다음과 같은 방법이 사용된다</p><ul><li>더 좋은 하드웨어 사용</li><li>치환으로 expotential하지 않게 변형</li><li>formula의 중복을 제거</li><li>subformula에 대한 정보를 cache에 저장하여 재사용</li><li>weakest precondition 사용</li></ul><h3 id=mixed-execution>Mixed Execution<a hidden class=anchor aria-hidden=true href=#mixed-execution>#</a></h3><p>실제로 사용되는 프로그램의 유형에 따라 symbolic input을 특정 형식의 입력으로 제한할 수 있다.</p><p>일부 입력은 구체적으로 허용하고 일부 입력을 기호적으로 허용한 것을 mixed execution이라고 한다.</p><p>이는 구체적인 값에 관한 계산을 프로세서에서 수행할 수 있도록 한다. 즉 사용자 입력에 의존하지 않는 부분은 concrete execution의 속도로 실행할 수 있다.</p><h1 id=5-related-work>5. Related Work<a hidden class=anchor aria-hidden=true href=#5-related-work>#</a></h1><h2 id=formalization-and-systematization>Formalization and Systematization<a hidden class=anchor aria-hidden=true href=#formalization-and-systematization>#</a></h2><p>Dynamic Security mechanisms은 새로운것은 아니지만 이전 연구들은 dynamic taint analysis와 forward symbolic execution을 형식화 하지 않았다.</p><p>이 논문은 프로그래밍 언어를 정의하여 의미론적 모호성을 해소하였다.</p><h2 id=applications>Applications<a hidden class=anchor aria-hidden=true href=#applications>#</a></h2><ul><li>Automatic Test-case Generation</li><li>Automatic Filter Generation</li><li>Automatic Network Protocol Understanding</li><li>Malware Analysis</li><li>Web Applications</li><li>Taint Performance & Frameworks</li><li>Extensions to Taint Analysis</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://246p.github.io/tags/2024/>2024</a></li><li><a href=https://246p.github.io/tags/%ED%95%99%EB%B6%80%EC%97%B0%EA%B5%AC%EC%83%9D/>학부연구생</a></li><li><a href=https://246p.github.io/tags/%EB%85%BC%EB%AC%B8/>논문</a></li><li><a href=https://246p.github.io/tags/symbolic-execution/>symbolic execution</a></li><li><a href=https://246p.github.io/tags/dynamic-taint-analysis/>dynamic taint analysis</a></li></ul><nav class=paginav><a class=prev href=https://246p.github.io/blog/paper_2/><span class=title>« Prev</span><br><span>2. Automated Whitebox Fuzz Testing</span>
</a><a class=next href=https://246p.github.io/blog/paper_0/><span class=title>Next »</span><br><span>0. 읽을 논문</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://246p.github.io/>Junlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>