<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>3. Angora: Efficient Fuzzing by Principled Search | Junlog</title>
<meta name=keywords content="2024,학부연구생,논문,LAVA-M,fuzzer"><meta name=description content="Angora: Efficient Fuzzing by Principled Search
0. Abstract fuzzing은 소프트웨어 버그를 찾기 위해 널리 사용되고 있다. 그러나 최신의 fuzzer의 성능은 기대에 못미치기도 한다.
symbolic execution 기반 : high quality input , 속도가 느림 random muatation 기반 : low quality input, 속도가 빠름 이 논문에서는 새로운 mutation-based fuzzer인 Angora를 제시한다.
Angora의 목표는 symbolic execution 없이 path constraint를 해결함으로 branch coverage를 증가시키는 것이다. 다음과 같은 핵심 기술을 도입하였다.
scalable byte-level taint tracking context-sensetive branch count search based on gradient descent input legnth exploration LAVA-M data set에서 거의 모든 injected bug를 찾았고 다른 모든 fuzzer보다 더 많은 bug를 찾았다."><meta name=author content="Kim-Minjoon"><link rel=canonical href=https://246p.github.io/blog/paper_3/><meta name=google-site-verification content="GTM-524D7HPF"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="3. Angora: Efficient Fuzzing by Principled Search"><meta property="og:description" content="Angora: Efficient Fuzzing by Principled Search
0. Abstract fuzzing은 소프트웨어 버그를 찾기 위해 널리 사용되고 있다. 그러나 최신의 fuzzer의 성능은 기대에 못미치기도 한다.
symbolic execution 기반 : high quality input , 속도가 느림 random muatation 기반 : low quality input, 속도가 빠름 이 논문에서는 새로운 mutation-based fuzzer인 Angora를 제시한다.
Angora의 목표는 symbolic execution 없이 path constraint를 해결함으로 branch coverage를 증가시키는 것이다. 다음과 같은 핵심 기술을 도입하였다.
scalable byte-level taint tracking context-sensetive branch count search based on gradient descent input legnth exploration LAVA-M data set에서 거의 모든 injected bug를 찾았고 다른 모든 fuzzer보다 더 많은 bug를 찾았다."><meta property="og:type" content="article"><meta property="og:url" content="https://246p.github.io/blog/paper_3/"><meta property="og:image" content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-02-07T10:13:45+09:00"><meta property="article:modified_time" content="2024-02-07T10:13:45+09:00"><meta property="og:site_name" content="Junlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta name=twitter:title content="3. Angora: Efficient Fuzzing by Principled Search"><meta name=twitter:description content="Angora: Efficient Fuzzing by Principled Search
0. Abstract fuzzing은 소프트웨어 버그를 찾기 위해 널리 사용되고 있다. 그러나 최신의 fuzzer의 성능은 기대에 못미치기도 한다.
symbolic execution 기반 : high quality input , 속도가 느림 random muatation 기반 : low quality input, 속도가 빠름 이 논문에서는 새로운 mutation-based fuzzer인 Angora를 제시한다.
Angora의 목표는 symbolic execution 없이 path constraint를 해결함으로 branch coverage를 증가시키는 것이다. 다음과 같은 핵심 기술을 도입하였다.
scalable byte-level taint tracking context-sensetive branch count search based on gradient descent input legnth exploration LAVA-M data set에서 거의 모든 injected bug를 찾았고 다른 모든 fuzzer보다 더 많은 bug를 찾았다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://246p.github.io/post/"},{"@type":"ListItem","position":2,"name":"3. Angora: Efficient Fuzzing by Principled Search","item":"https://246p.github.io/blog/paper_3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"3. Angora: Efficient Fuzzing by Principled Search","name":"3. Angora: Efficient Fuzzing by Principled Search","description":"Angora: Efficient Fuzzing by Principled Search\n0. Abstract fuzzing은 소프트웨어 버그를 찾기 위해 널리 사용되고 있다. 그러나 최신의 fuzzer의 성능은 기대에 못미치기도 한다.\nsymbolic execution 기반 : high quality input , 속도가 느림 random muatation 기반 : low quality input, 속도가 빠름 이 논문에서는 새로운 mutation-based fuzzer인 Angora를 제시한다.\nAngora의 목표는 symbolic execution 없이 path constraint를 해결함으로 branch coverage를 증가시키는 것이다. 다음과 같은 핵심 기술을 도입하였다.\nscalable byte-level taint tracking context-sensetive branch count search based on gradient descent input legnth exploration LAVA-M data set에서 거의 모든 injected bug를 찾았고 다른 모든 fuzzer보다 더 많은 bug를 찾았다.","keywords":["2024","학부연구생","논문","LAVA-M","fuzzer"],"articleBody":" Angora: Efficient Fuzzing by Principled Search\n0. Abstract fuzzing은 소프트웨어 버그를 찾기 위해 널리 사용되고 있다. 그러나 최신의 fuzzer의 성능은 기대에 못미치기도 한다.\nsymbolic execution 기반 : high quality input , 속도가 느림 random muatation 기반 : low quality input, 속도가 빠름 이 논문에서는 새로운 mutation-based fuzzer인 Angora를 제시한다.\nAngora의 목표는 symbolic execution 없이 path constraint를 해결함으로 branch coverage를 증가시키는 것이다. 다음과 같은 핵심 기술을 도입하였다.\nscalable byte-level taint tracking context-sensetive branch count search based on gradient descent input legnth exploration LAVA-M data set에서 거의 모든 injected bug를 찾았고 다른 모든 fuzzer보다 더 많은 bug를 찾았다.\nwho 프로그램에서는 두번째로 좋은 fuzzer보다 8배 많은 버그를 찾았다. 또한 LAVA 제작자가 injected 하였지만 trigger하지 못한 103개의 버그를 찾아내었다.\n또한 8개의 널리 사용되는 open source program에서 Angora를 테스트하여 다음과 같은 버그를 발견하였다.\nprogram name number of bug file 6 jhead 52 nm 29 objdump 40 size 48 1. Introduction Fuzzer는 소프트웨어 버그를 찾는 인기있는 기술이다. Coverage-based fuzzer는 program state를 탐색하기 위한 input을 만드는 문제에 직면하였다.\n1.1. AFL 몇몇 fuzzer는 symbolic execution을 사용하여 path constraint를 해결하지만 symbolic execution은 느리고 많은 종류의 constraint 를 효과적으로 해결할 수 없다. AFL은 symbolic execution과 같은 heavy weight program analysis를 사용하지 않음으로 이러한 문제를 피했다.\n프로그램을 계측하여 어떤 input이 새로운 program branch를 탐색하는지를 관측한다. 그리고 이러한 input에 muatation을 주고 seed에 추가한다. AFL은 프로그램 실행에 있어서 낮은 overhead를 갖지만 AFL이 생성하는 대부분의 input은 효과가 없다. (새로운 program state를 탐색하지 못함) 왜냐하면 program의 data flow를 고려하지 않고 input을 맹목적으로 mutate하기 때문이다.\n몇몇 Fuzzer들은 AFL에 heuristic을 이용하여 “magic byte\"와 같은 간단한 predicates을 추가하였다.\n1.2. Angora 우리는 symbolic execution을 사용하지 않고 path constraint를 해결하기위하여 Angora 라는 fuzzer를 설계하고 구현하였다.\nAngora는 탐색되지 않은 branch를 추적하고 이러한 branch의 path constraint를 해결하려고 한다. 이를 위해 다음과 같은 기술을 도입하여 현존하는 fuzzer보다 상당히 좋은 결과를 얻었다.\n1.2.1 Context-sensetive branch count AFL은 context-insensitive bran count를 사용한다. 우리의 실험에 의하면 context를 branch coverage에 추가하면 Angora가 더 효과적으로 프로그램을 탐색한다.\n1.2.2. Scalable byte-level taint tracking 많은 path constraint는 input의 몇 byte에 의존한다. 어떠한 input byte가 path constraint에 영향을 주는지 추적하여 Angora는 이러한 byte에만 mutate를 수행한다. 이러한 방식으로 탐색할 공간을 줄인다.\n1.2.3. Search based on gradient descent Angora는 symbolic execution을 사용하지 않고input을 path constraint를 만족하도록 mutate 한다. symbolic execution은 cost가 높고 많은 종류의 constraint를 해결하지 못한다.\nAngora는 ML분야의 gradient descent algorithm을 사용하여 path constraint를 해결한다.\n1.2.4. Type and shape inference input의 많은 byte는 하나의 값으로 사용 된다. 예를 들어 4 byte의 input은 32 bit signed integer로 사용된다.\n검색에 gradient descent를 효율적으로 사용하기 위해서 Angora는 group의 유형을 추론한다.\n1.2.5. Input length exploration 어떤 프로그램은 input의 길이가 특정 값을 초과할때에만 특정 state를 탐색할 수 있다. symbolic execution이나 gradient descent는 input의 길이를 증가시켜야 하는지 알려주지 않는다.\nAngora는 input의 길이가 path constraint에 영향을 미칠 수 있는 경우를 감지하고 input 길이를 증가시킨다.\n2. Background: American Fuzzy Lop (AFL) fuzzing은 bug를 찾기 위한 자동화된 테스트 기술이다. AFL은 mutation-based graybox fuzzer로 compile-time instrumentation과 genetic algorithm을 사용하여 새로운 internal state를 실행할것으로 예상되는 test case를 자동으로 생성한다.\nAFL은 coverge-based fuzzer이고 다양한 path를 탐색하고 bug를 발생하기 위한 입력을 생성한다.\n2.1. Branch coverage AFL은 branch를 기반으로 path를 측정한다. AFL은 실행중 각 branch가 몇번 실행되었는지 센다. AFL은 branch를 튜플 (l_prev,l_cur)로 나타낸다. (l_prev = 이전, l_prev = 이후의 block ID)\nAFL은 간단한 instrumentation을 사용하여 branch coverage정보를 얻는다. instrumentation은 compile time에 각 branch point에 삽입되고 AFL은 모든 조건문의 각 branch가 실행된 횟수를 세는 path trace table을 할당한다. table에는 분기의 hash인 h(l_prev,l_cur)이다. (h는 hash function)\nAFL은 global branch coverage table을 유지한다. branch가 다른 실행에서 실행된 횟수를 기록하는 8bit vector를 포함한다.\nb[0-7] = { [1], [2], [3], [4-7], [8-15], [16-31], [32-127], [128,∞)} AFL은 path trace table과 branch coverage table을 비교하여 새로운 input이 새로운 internal state를 실행하는지 heuristically하게 결정한다. 다음중 하나가 발생할때 새로운 state를 실행한다\n새로운 branch를 실행할때 : path trace table에는 있지만 branch coverage table에는 없을때 이 전 실행과 다른 횟수로 실행되는 branch가 있을때 2.2. Mutation strategies AFL은 다음과 같은 muatation 전략을 사용한다\nbit or byte flip “intersting” byte or word or dword 사용 byte or word or dword에 대한 작은 정수의 덧셈 뺄셈 single-byte를 random 결정 blcok 삭제, 복제(덮어쓰기, 삽입), memset random location에서 두 input file 이어붙이기 3. Design 3.1. Overview AFL과 유사한 fuzzer들은 branch coverage를 지표로 사용한다. branch coverage를 계산할때 context를 고려하지 않는다. 우리의 경험에 따르면 context 없이는 branch coverage와 program state를 충분히 탐색하지 못한다. 따라서 우리는 coverage의 지표로 context-sensitive branch coverage를 제안한다.\nAlgorithm of Angora Algorithm 1은 Angora의 두 단계인 계측과 fuzzing loop를 보여준다.\n![Algorithm1]\nfuzzing loop는 탐색되지 않은 branch를 선택하고 해당 branch를 탐색하는 input을 찾는다. input을 효율적으로 찾기 위한 기술은 다음과 같다.\n대부분의 조건문의 경우 조건은 input의 몇 byte에 의해서만 영향을 받는다. 즉 전체 input을 mutate하는것은 비생산적이다. 분기를 탐색할때 Angora는 해당 조건문의 input bytes flow를 결정하고 이러한 byte의 muate에만 집중한다.\nmuate할 input byte를 결정한 후 이 byte를 어떻게 mutate할지 결정한다. 무작위 또는 heuristic하게 결정한다면 알맞는 값을 효율적을 찾기 어렵다. 대신 우리는 path constraint를 입력에 대한 blackbox function의 constraint로 본다. 이를 gradient descent algorithm을 사용하여 해결한다.\ngradient descent를 사용할때 blackbox function의 argument에 대해서 평가한다. 예르 들어 input의 연속된 4byte가 정수로 사용될때 우리는 이 4byte를 독립적인 argument가 아닌 하나의 argument로 고려해야 한다. 이 방법을 사용하기 위하여 input의 byte의 유형과 단일 또는 공동으로 사용되는지 여부를 추론해야한다.\n일부 버그는 input이 특정 임계값보다 길어졌을때 발생한다. 따라서 input의 byte만을 변형하는것이 아닌 길이를 변경해야 한다. 하지만 이는 딜레마를 생성한다.input이 너무 짧다면 특정 버그를 발생시키지 못할 수 있다. 반면 너무 길다면 프로그램이 느려질 수 있다. 대부분의 fuzzer는ㄴ adhoc을 사용하여 input의 길이를 변경한다. 반면 Angora는 새로운 branch를 탐색할 수 있는 더 긴 input이 필요할때를 감지하고 최소 필요 길이를 결정하는 코드로 프로그램을 계측한다.\n다음은 조건문을 fuzzing하는 단계의 diagram과 코드이다.\n![Figure1]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void foo(int i, int j) { if (i * i - j * 2 \u003e 0) {/* some code*/} else{/* some code*/} } int main() { char buf[1024]; int i = 0, j = 0; if(fread(buf, sizeof(char), 1024, fp)\u003c 1024) return 1; if(fread(\u0026i, sizeof(int), 1, fp) \u003c 1) return 1; if(fread(\u0026j, sizeof(int), 1, fp) \u003c 1) return 1; foo(i, j); } 다음과 같은 내용을 확인할 수 있다.\nByte-level taint tracking Angora는 2번째줄의 if문을 fuzzing할때 byte-level taint tracking을 사용하여 1024-1031번째 byte flow가 표현식을 결정함을 확인하여 이 byte들만 변형한다.\nSearch algorithm based on gradient descent Angora는 2번째 줄의 조건문의 두 분기를 각각 실행하는 입력을 찾아야 한다. 조건문 내 표현식을 입력 x에 대한 f(x)로 처리하고 gradient descent algorithm을 사용하여 f(x)\u003e0, f(x’)\u003c=0인 두 input x, x’을 찾는다.\nShape and type inference f(x)는 vector x에 대한 함수이다. gradient descent를 적용할때 Angora는 x의 각 component에 대해 편미분을 계산해야 하므로 각 component와 유형을 결정해야한다.\nInput length exploration input이 1032byte보다 작을때 mian은 foo를 호출하지 않는다. 무작정 긴 input을 시도하는 대신 input에서 읽는 일반적인 함수들을 계측하고 더 긴 입력이 새로우 state를 탐색할 지 결정한다.\n3.2. Context-sensitive branch count context-insensetive 위에서 AFL의 branch coverage table에 대해서 설명한다. 이러한 설계는 다음과 같은 장점이 있다.\n공간을 효율적으로 사용한다. branch의 수는 프로그램의 크기에 선형적이다. range를 사용하여 branch execution count를 사용하면 다음 실행이 새로운 내부 상태를 나타내는지에 대한 heuristic을 제공한다. 하지만 이러한 설계는 한계가 있다. AFL의 branch는 context-insensetive이기 때문에 같은 branch의 다른 context에서의 실행을 구분하지 못하며 프로그램의 내부 새로운 내부 상태를 넘어갈 수 있다. 다음은 이에 대한 예시이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void f(bool x){ static bool trigger = false; if (x) if(trigger) if(input[2]) // crash else if (!trigger) trigger = true; } bool [] input; int main(){ f(input[0]); ... f(input[1]); } if(x)의 branch coverage를 고려해 보자. 첫번째 입력이 10이라면 19번째 줄에서 f()를 호출할때 true branch를 실행히킨다. 이후 21줄에서 f()를 실행시킬때 10번째줄의 false를 실행시킨다.\nAFL의 branch가 context-insensetive 이기에 두 input 모두 실행되었다고 생각한다.\n그 이후 01이 입력으로 들어온다면 AFL은 이전 입력에서도 역시 3,10 branch 모두 실행되었기 때문에 이 입력은 새로운 내부 state를 trigger하지 않는다고 생각한다. 하지만 이 입력은 새로운 내부 상태를 trigger 한다. input[2]==1일때 crash를 발생시킨다.\n※ 논문에서 오타가 있는것 같다. 코드와 설명 모두 input[2]가 아닌 input[1]로 해석해야 할것 같다.\ncontext-sensetive 우리는 branch를 tuple (l_prev, l_cur, context)로 정의하여 context를 포함한다.\nl_prev와 l_cur는 조건문 전 후의 baisc block의 ID 이고 context는 h(stack)이다. 예를들어 위 코드를 10으로 실행할때 19줄의 f()로 들어간 이후에는 branch (l_3, l_4, [l19])를 실행한다. 이후 21줄의 f()를 실행한 경우에는 branch (l_3, l_10, [l21])을 실행한다. 반면 01의 input으로 실행될 때에는 (l_3, l_10, [l19])를 실행한 후 (l_3, l_4, [l21])을 실행하기 때문에 barnch의 정의에 context를 포함시킴으로서 Angora는 두번째 input이 새로운 내부 state를 trigger한다는것을 감지할 수 있다.\nusing hash function branch에 context를 추가한다면 unique branch의 수가 증가하며 deep recursion이 발생할 수 있다. 현재 구현은 call stack의 hash를 계산하기 위하여 hash function h를 사용함으로 이 문제를 완화한다.\nh는 stack상의 모든 call site의 ID의 xor을 계산한다. Angora가 프로그램을 계측할때 각 call site에 랜덤 ID를 할당한다. 함수가 f가 자신을 재귀적으로 호출할때 Angora가 동일한 call site의 ID를 call stack 얼마나 많이 push하든 h(stack)은 최대 2개의 고유값을 출력한다.\n즉 함수 f 내의 unique branch의 수를 최대 2배까지만 증가시킨다. 실제 프로그램에 대한 평가는 context를 포함한 후 unique branch가 최대 7.21배 까지 증가한다는 것을 보여준다. 이는 code coverage가 증가한다는 이점을 얻기 위한 대가이다.\n3.3. Byte-level taint tracking taint tracking Angora는 탐색되지 않은 branch를 실행하는 입력을 생성하는것을 목표로 한다. 탐색되지 않은 branch를 실행하려고 할때 그 branch의 predicate에 따라 영향을 미치는 input내의 byte offset을 알아내야한다. 이를 위하여 byte-level taint analysis를 사용한다.\ntaint analysis는 비용이 많이 든다. 특히 개별 byte를 추적할때는 더욱 그렇다. 이로 인하여 AFL은 이를 사용하지 않는다.\n우리는 대부분의 프로그램 실행에서 taint tracking이 불필요하다고 생각한다. input에 대하여 한번 taint tracking을 실행한다면 각 조건문으로 흐르는 byte offset을 기록할 수 있다. 그 이후 byte를 mutate할때 taint tracking을 하지 않을 수 있다.\n이는 taint tarcking의 비용을 많은 mutation에 걸쳐 분산시킨다. 이로 인하여 Angora는 AFL과 유사한 양의 input execution을 처리할 수 있다.\ndata structure of taint label Angora는 프로그램내 각 변수 x를 taint label t_x와 연결한다. taint label의 data구조는 메모리사용량에 큰 영향을 미친다.\n단군한 구현 방법은 각 taint label을 bit vector로 표현하는 것이며 여기서 각 비트 i는 input의 i번째 byte를 나타낸다. 하지만 bit vector의 크기가 input의 크기에 선형적으로 증가하기 때문에 이러한 data구조는 큰 입력에 대해서 사용하기 힘들다.\ntaint label의 크기를 줄이기 위하여 bit vetor를 table에 저장하고 table의 index를 taint label로 사용할 수 있다. table 항목중 logarithm이 가장 긴 vector의 길이보다 작은 경우가 있는데 이를 이용하여 taint label의 크기를 크게 줄일 수 있다.\nusing table 하지만 다음과 같은 연산을 지원해야 한다.\nINSERT(b) : bit vector b를 삽입하고 그 라벨을 반환한다. FIND(t) : taint label t에 대한 bit vector를 반환한다. UNION(tx,ty) : t_x, t_y의 합집합을 표현하는 taint label을 반환한다. FIND는 저렴하지만 Union은은 비용이 많이든다. UNION은 다음과 같은 단계를 거친다.\n두 label의 bit vector를 찾아 합집합 u를 계산한다. u가 이미 존재하는지 여부를 결정하기 위하여 table을 검색한다. 존재하지 않는다면 u를 추가한다. 이때 선형 검색을 하는데 많은 비용이 든다. 이를 해결하기위하여 hash set을 구축할 수 있겠지만 많은 bit vector가 존재하고 각 bit vector가 길다면 hash code를 계산하는데 많은 시간이 걸리고 hash set을 저장하는데 많은 공간이 필요하다.\n산술 표현힉에서 taint data를 추적할때 UNION이 흔한 연산이므로 효율적이여야 한다. 서로 다른 vector가 같은 위치에 1을 가질 수 있기 때문에 UNION-FIND 구조를 사용할 수 없다.\nusing binary tree bit vector를 저장하기 위한 data structure를 도입한다. 이 data structure는 효율적인 INSERT, FIND, UNION을 가능하게 한다. 각 bit vector는 부호 없는 정수를 사용하여 고유한 라벨을 할당한다. 새 bit vector를 삽입할때 다음으로 사용가능한 부호없는 정수를 할당한다. 이를 위하여 다음 두가지 요소를 사용해야한다.\nbinary tree를 사용하여 bit vector를 label로 mapping한다. look up table은 label을 bit vector로 mapping한다. 이 데이터 구조를 사용하여 bit vector를 효율적으로 관리하고 label을 사용하여 bit vector를 빠르게 찾아내며 UNION연산을 수행할때 필요한 bit vector의 합집합을 효과적으로 결정할 수 있다. 메모리 사용량을 최소화 하며 필요한 연산을 신속하게 수행할 수 있는 방법을 제공한다.\n이 data structure에서 tree의 모든 leaf는 bit vector를 대표한다. 내부 node는 bit vector를 표현하지 않는다. 그래서 tree 에는 불필요한 많은 node를 가 있다.\n예시를 들기 전에 regular expression에 대해 알아본다. 먼저 x* 는 x가 0개 이상 반복된다는 의미이다. 또한 [xy]는 x또는 y를 의미한다.\nx00*가 tree에 있다. x0[01]*1[01]*가 tree에 없다. 이때 x를 대표하는 어떤 node도 저장할 필요 없다. x는 오직 하나의 decedent를 가지며 그 decedent는 leaf이기 때문이다. 그리고 그것은 x00*로 표현된다. 따라서 우리는 tree에 vector를 삽입할때 다음과 같이 정리 할 수 있다.\n벡터 끝의 모든 0을 제거한다. 벡터의 첫 bit부터 마지막 bit까지 bit를 따라 tree를 순회한다. child가 없으면 생성한다. bit가 0이라면 left child 그렇지 않으면 right child 마지막으로 방문한 node에 vector의 label을 저장한다. 이 절차를 통하여 bit vector를 저장할때 필요없는 node의 생성을 방지하고 data structure의 효율성을 높일 수 있다. vector가 많고 긴 경우에도 효율적이다. Algorithm 2는 이 삽입 연산을 자세히 설명한다. Algorithm 3은 FIND, 4는 UNION연산을 설명한다. node를 생성할때 초기에는 label이 없음을 고려해야 한다. bit vector를 삽입할때 마지막으로 방문한 노드가 label이 없는 노드인 경우 우리는 이 node에 bit vecotr의 label을 저장한다. 이 tree는 다음 특성을 갖는다.\nleaf node는 label을 저장한다. 내부 node는 label을 포함할 수 있지만 내부 node의 label은 교체하지 않는다. 이 구조를 이용하여 bit vecotr를 저장하는데 필요한 메모리 사용량을 크게 줄인다.\n3.4. Search algorithm based on gradient descent byte-level taint tracking은 어떤 byte offset이 조건문으로 flow되는지 발견할 수 있다. input을 matate하여 탐색되지 않은 branch를 탐색한다. 대부분의 fuzzer는 무작 또는 조잡한 heuristic을 사용하지만 빠르게 적절한 input을 찾기 힘들다. 반면 이 논문에서는 이를 serach problem으로 보고 machine learning에서의 serach algorithm을 사용하였다. 여기서는 gradient descent를 사용하였지만 다른 search algorithm을 사용할 수 있다.\ntransform comparison into constraint 이 접근 방식에서 branch를 실행하기 위한 predicate를 blackbox funtion f(x) 에 대한 constraint로 본다. x는 predicate로 흐르는 input value들의 vector이고 *f()*는 프로그램 시작부터 이 predicate까지의 path에서의 계산을 감지한다. *f(x)*에는 3가지 constraint가 있다.\nf(x)\u003c0 *f(x)\u003c=0 f(x)=0 다음 표는 모든 형태의 비료를 3가지 유형의 constraint로 변환할 수 있음을 보여준다. 조거문의 조건에 논리연산자 \u0026\u0026또는 ||이 포함된 경우 Angora는 이 조건문을 여러 조건문으로 분할한다. 예를들어 if (a \u0026\u0026 b) {s} else {t} 를 if (a) { if (b) {s} else {t} } else {t}로 분할한다.\nComparison f Constraint a","wordCount":"4187","inLanguage":"en","datePublished":"2024-02-07T10:13:45+09:00","dateModified":"2024-02-07T10:13:45+09:00","author":{"@type":"Person","name":"Kim-Minjoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://246p.github.io/blog/paper_3/"},"publisher":{"@type":"Organization","name":"Junlog","logo":{"@type":"ImageObject","url":"https://246p.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://246p.github.io/ accesskey=h title="HOME (Alt + H)"><img src=https://246p.github.io/apple-touch-icon.png alt aria-label=logo height=35>HOME</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://246p.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://246p.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://246p.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://246p.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1Di1J0LxHNuXNiDbwFhOh2XMLAgUJtYlh/view?usp=drive_link" title=CV><span>CV</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://246p.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://246p.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">3. Angora: Efficient Fuzzing by Principled Search</h1><div class=post-meta><span title='2024-02-07 10:13:45 +0900 KST'>February 7, 2024</span>&nbsp;·&nbsp;Kim-Minjoon</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#11-afl>1.1. AFL</a></li><li><a href=#12-angora>1.2. Angora</a><ul><li><a href=#121-context-sensetive-branch-count>1.2.1 Context-sensetive branch count</a></li><li><a href=#122-scalable-byte-level-taint-tracking>1.2.2. Scalable byte-level taint tracking</a></li><li><a href=#123-search-based-on-gradient-descent>1.2.3. Search based on gradient descent</a></li><li><a href=#124-type-and-shape-inference>1.2.4. Type and shape inference</a></li><li><a href=#125-input-length-exploration>1.2.5. Input length exploration</a></li></ul></li></ul><ul><li><a href=#21-branch-coverage>2.1. Branch coverage</a></li><li><a href=#22-mutation-strategies>2.2. Mutation strategies</a></li></ul><ul><li><a href=#31-overview>3.1. Overview</a><ul><li><a href=#algorithm-of-angora>Algorithm of Angora</a></li><li><a href=#byte-level-taint-tracking>Byte-level taint tracking</a></li><li><a href=#search-algorithm-based-on-gradient-descent>Search algorithm based on gradient descent</a></li><li><a href=#shape-and-type-inference>Shape and type inference</a></li><li><a href=#input-length-exploration>Input length exploration</a></li></ul></li><li><a href=#32-context-sensitive-branch-count>3.2. Context-sensitive branch count</a><ul><li><a href=#context-insensetive>context-insensetive</a></li><li><a href=#context-sensetive>context-sensetive</a></li><li><a href=#using-hash-function>using hash function</a></li></ul></li><li><a href=#33-byte-level-taint-tracking>3.3. Byte-level taint tracking</a><ul><li><a href=#taint-tracking>taint tracking</a></li><li><a href=#data-structure-of-taint-label>data structure of taint label</a></li></ul></li><li><a href=#34-search-algorithm-based-on-gradient-descent>3.4. Search algorithm based on gradient descent</a><ul><li><a href=#transform-comparison-into-constraint>transform comparison into constraint</a></li><li><a href=#gradient-decent>Gradient decent</a></li><li><a href=#problem-of-gradient-decent>Problem of Gradient decent</a></li><li><a href=#numerical-approximation-of-gradient-decent>numerical approximation of gradient decent</a></li></ul></li><li><a href=#35-shape-and-type-inference>3.5. Shape and type inference</a><ul><li><a href=#shape-inference>shape inference</a></li><li><a href=#type-inference>type inference</a></li></ul></li><li><a href=#36-input-length-exploration>3.6. Input length exploration</a></li></ul><ul><li><a href=#41-instrumentation>4.1. Instrumentation</a></li><li><a href=#42-fuzzer>4.2. Fuzzer</a></li></ul><ul><li><a href=#51-compare-angora-with-other-fuzzers>5.1. Compare Angora with other fuzzers</a></li><li><a href=#52-evaluate-angora-on-unmodified-real-world-programs>5.2. Evaluate Angora on unmodified real world programs</a></li><li><a href=#53-context-sensitive-branch-count>5.3. Context-sensitive branch count</a><ul><li><a href=#531-performance>5.3.1. Performance</a></li><li><a href=#532-hash-collision>5.3.2. Hash collision</a></li></ul></li><li><a href=#54-search-based-on-gradient-descent>5.4. Search based on gradient descent</a></li><li><a href=#55-input-length-exploration>5.5. Input length exploration</a></li><li><a href=#56-execution-speed>5.6. Execution speed</a></li></ul><ul><li><a href=#61-prioritize-seed-inputs>6.1. Prioritize seed inputs</a></li><li><a href=#62-taint-based-fuzzing>6.2. Taint-based fuzzing</a></li><li><a href=#63-symbolic-assisted-fuzzing>6.3. Symbolic-assisted fuzzing</a></li></ul></nav></div></details></div><div class=post-content><p><a href=https://web.cs.ucdavis.edu/~hchen/paper/chen2018angora.pdf>Angora: Efficient Fuzzing by Principled Search</a></p><h1 id=0-abstract>0. Abstract<a hidden class=anchor aria-hidden=true href=#0-abstract>#</a></h1><p>fuzzing은 소프트웨어 버그를 찾기 위해 널리 사용되고 있다. 그러나 최신의 fuzzer의 성능은 기대에 못미치기도 한다.</p><ul><li>symbolic execution 기반 : high quality input , 속도가 느림</li><li>random muatation 기반 : low quality input, 속도가 빠름</li></ul><p>이 논문에서는 새로운 mutation-based fuzzer인 Angora를 제시한다.</p><p>Angora의 목표는 symbolic execution 없이 path constraint를 해결함으로 branch coverage를 증가시키는 것이다. 다음과 같은 핵심 기술을 도입하였다.</p><ul><li>scalable byte-level taint tracking</li><li>context-sensetive branch count</li><li>search based on gradient descent</li><li>input legnth exploration</li></ul><p>LAVA-M data set에서 거의 모든 injected bug를 찾았고 다른 모든 fuzzer보다 더 많은 bug를 찾았다.</p><p><em>who</em> 프로그램에서는 두번째로 좋은 fuzzer보다 8배 많은 버그를 찾았다. 또한 LAVA 제작자가 injected 하였지만 trigger하지 못한 103개의 버그를 찾아내었다.</p><p>또한 8개의 널리 사용되는 open source program에서 Angora를 테스트하여 다음과 같은 버그를 발견하였다.</p><table><thead><tr><th style=text-align:center>program name</th><th style=text-align:center>number of bug</th></tr></thead><tbody><tr><td style=text-align:center>file</td><td style=text-align:center>6</td></tr><tr><td style=text-align:center>jhead</td><td style=text-align:center>52</td></tr><tr><td style=text-align:center>nm</td><td style=text-align:center>29</td></tr><tr><td style=text-align:center>objdump</td><td style=text-align:center>40</td></tr><tr><td style=text-align:center>size</td><td style=text-align:center>48</td></tr></tbody></table><h1 id=1-introduction>1. Introduction<a hidden class=anchor aria-hidden=true href=#1-introduction>#</a></h1><p>Fuzzer는 소프트웨어 버그를 찾는 인기있는 기술이다. Coverage-based fuzzer는 program state를 탐색하기 위한 input을 만드는 문제에 직면하였다.</p><h2 id=11-afl>1.1. AFL<a hidden class=anchor aria-hidden=true href=#11-afl>#</a></h2><p>몇몇 fuzzer는 symbolic execution을 사용하여 path constraint를 해결하지만 symbolic execution은 느리고 많은 종류의 constraint 를 효과적으로 해결할 수 없다. <em>AFL</em>은 symbolic execution과 같은 heavy weight program analysis를 사용하지 않음으로 이러한 문제를 피했다.</p><p>프로그램을 계측하여 어떤 input이 새로운 program branch를 탐색하는지를 관측한다. 그리고 이러한 input에 muatation을 주고 seed에 추가한다. AFL은 프로그램 실행에 있어서 낮은 overhead를 갖지만 AFL이 생성하는 대부분의 input은 효과가 없다. (새로운 program state를 탐색하지 못함) 왜냐하면 program의 data flow를 고려하지 않고 input을 맹목적으로 mutate하기 때문이다.</p><p>몇몇 Fuzzer들은 AFL에 heuristic을 이용하여 &ldquo;magic byte"와 같은 간단한 predicates을 추가하였다.</p><h2 id=12-angora>1.2. Angora<a hidden class=anchor aria-hidden=true href=#12-angora>#</a></h2><p>우리는 symbolic execution을 사용하지 않고 path constraint를 해결하기위하여 Angora 라는 fuzzer를 설계하고 구현하였다.</p><p>Angora는 탐색되지 않은 branch를 추적하고 이러한 branch의 path constraint를 해결하려고 한다. 이를 위해 다음과 같은 기술을 도입하여 현존하는 fuzzer보다 상당히 좋은 결과를 얻었다.</p><h3 id=121-context-sensetive-branch-count>1.2.1 Context-sensetive branch count<a hidden class=anchor aria-hidden=true href=#121-context-sensetive-branch-count>#</a></h3><p>AFL은 context-insensitive bran count를 사용한다. 우리의 실험에 의하면 context를 branch coverage에 추가하면 Angora가 더 효과적으로 프로그램을 탐색한다.</p><h3 id=122-scalable-byte-level-taint-tracking>1.2.2. Scalable byte-level taint tracking<a hidden class=anchor aria-hidden=true href=#122-scalable-byte-level-taint-tracking>#</a></h3><p>많은 path constraint는 input의 몇 byte에 의존한다. 어떠한 input byte가 path constraint에 영향을 주는지 추적하여 Angora는 이러한 byte에만 mutate를 수행한다. 이러한 방식으로 탐색할 공간을 줄인다.</p><h3 id=123-search-based-on-gradient-descent>1.2.3. Search based on gradient descent<a hidden class=anchor aria-hidden=true href=#123-search-based-on-gradient-descent>#</a></h3><p>Angora는 symbolic execution을 사용하지 않고input을 path constraint를 만족하도록 mutate 한다. symbolic execution은 cost가 높고 많은 종류의 constraint를 해결하지 못한다.</p><p>Angora는 ML분야의 gradient descent algorithm을 사용하여 path constraint를 해결한다.</p><h3 id=124-type-and-shape-inference>1.2.4. Type and shape inference<a hidden class=anchor aria-hidden=true href=#124-type-and-shape-inference>#</a></h3><p>input의 많은 byte는 하나의 값으로 사용 된다.
예를 들어 4 byte의 input은 32 bit signed integer로 사용된다.</p><p>검색에 gradient descent를 효율적으로 사용하기 위해서 Angora는 group의 유형을 추론한다.</p><h3 id=125-input-length-exploration>1.2.5. Input length exploration<a hidden class=anchor aria-hidden=true href=#125-input-length-exploration>#</a></h3><p>어떤 프로그램은 input의 길이가 특정 값을 초과할때에만 특정 state를 탐색할 수 있다. symbolic execution이나 gradient descent는 input의 길이를 증가시켜야 하는지 알려주지 않는다.</p><p>Angora는 input의 길이가 path constraint에 영향을 미칠 수 있는 경우를 감지하고 input 길이를 증가시킨다.</p><h1 id=2-background-american-fuzzy-lop-afl>2. Background: American Fuzzy Lop (AFL)<a hidden class=anchor aria-hidden=true href=#2-background-american-fuzzy-lop-afl>#</a></h1><p>fuzzing은 bug를 찾기 위한 자동화된 테스트 기술이다. AFL은 mutation-based graybox fuzzer로 compile-time instrumentation과 genetic algorithm을 사용하여 새로운 internal state를 실행할것으로 예상되는 test case를 자동으로 생성한다.</p><p>AFL은 coverge-based fuzzer이고 다양한 path를 탐색하고 bug를 발생하기 위한 입력을 생성한다.</p><h2 id=21-branch-coverage>2.1. Branch coverage<a hidden class=anchor aria-hidden=true href=#21-branch-coverage>#</a></h2><p>AFL은 branch를 기반으로 path를 측정한다. AFL은 실행중 각 branch가 몇번 실행되었는지 센다. AFL은 branch를 튜플 (l_prev,l_cur)로 나타낸다. (l_prev = 이전, l_prev = 이후의 block ID)</p><p>AFL은 간단한 instrumentation을 사용하여 branch coverage정보를 얻는다. instrumentation은 compile time에 각 branch point에 삽입되고 AFL은 모든 조건문의 각 branch가 실행된 횟수를 세는 path trace table을 할당한다. table에는 분기의 hash인 h(l_prev,l_cur)이다. (h는 hash function)</p><p>AFL은 global branch coverage table을 유지한다. branch가 다른 실행에서 실행된 횟수를 기록하는 8bit vector를 포함한다.</p><pre><code>b[0-7] = { [1], [2], [3], [4-7], [8-15], [16-31], [32-127], [128,∞)}
</code></pre><p>AFL은 path trace table과 branch coverage table을 비교하여 새로운 input이 새로운 internal state를 실행하는지 heuristically하게 결정한다. 다음중 하나가 발생할때 새로운 state를 실행한다</p><ul><li>새로운 branch를 실행할때 : path trace table에는 있지만 branch coverage table에는 없을때</li><li>이 전 실행과 다른 횟수로 실행되는 branch가 있을때</li></ul><h2 id=22-mutation-strategies>2.2. Mutation strategies<a hidden class=anchor aria-hidden=true href=#22-mutation-strategies>#</a></h2><p>AFL은 다음과 같은 muatation 전략을 사용한다</p><ul><li>bit or byte flip</li><li>&ldquo;intersting&rdquo; byte or word or dword 사용</li><li>byte or word or dword에 대한 작은 정수의 덧셈 뺄셈</li><li>single-byte를 random 결정</li><li>blcok 삭제, 복제(덮어쓰기, 삽입), memset</li><li>random location에서 두 input file 이어붙이기</li></ul><h1 id=3-design>3. Design<a hidden class=anchor aria-hidden=true href=#3-design>#</a></h1><h2 id=31-overview>3.1. Overview<a hidden class=anchor aria-hidden=true href=#31-overview>#</a></h2><p>AFL과 유사한 fuzzer들은 branch coverage를 지표로 사용한다. branch coverage를 계산할때 context를 고려하지 않는다. 우리의 경험에 따르면 context 없이는 branch coverage와 program state를 충분히 탐색하지 못한다. 따라서 우리는 coverage의 지표로 context-sensitive branch coverage를 제안한다.</p><h3 id=algorithm-of-angora>Algorithm of Angora<a hidden class=anchor aria-hidden=true href=#algorithm-of-angora>#</a></h3><p>Algorithm 1은 Angora의 두 단계인 계측과 fuzzing loop를 보여준다.</p><p>![Algorithm1]</p><p>fuzzing loop는 탐색되지 않은 branch를 선택하고 해당 branch를 탐색하는 input을 찾는다. input을 효율적으로 찾기 위한 기술은 다음과 같다.</p><ol><li><p>대부분의 조건문의 경우 조건은 input의 몇 byte에 의해서만 영향을 받는다. 즉 전체 input을 mutate하는것은 비생산적이다. 분기를 탐색할때 Angora는 해당 조건문의 input bytes flow를 결정하고 이러한 byte의 muate에만 집중한다.</p></li><li><p>muate할 input byte를 결정한 후 이 byte를 어떻게 mutate할지 결정한다. 무작위 또는 heuristic하게 결정한다면 알맞는 값을 효율적을 찾기 어렵다. 대신 우리는 path constraint를 입력에 대한 blackbox function의 constraint로 본다. 이를 gradient descent algorithm을 사용하여 해결한다.</p></li><li><p>gradient descent를 사용할때 blackbox function의 argument에 대해서 평가한다. 예르 들어 input의 연속된 4byte가 정수로 사용될때 우리는 이 4byte를 독립적인 argument가 아닌 하나의 argument로 고려해야 한다. 이 방법을 사용하기 위하여 input의 byte의 유형과 단일 또는 공동으로 사용되는지 여부를 추론해야한다.</p></li><li><p>일부 버그는 input이 특정 임계값보다 길어졌을때 발생한다. 따라서 input의 byte만을 변형하는것이 아닌 길이를 변경해야 한다. 하지만 이는 딜레마를 생성한다.input이 너무 짧다면 특정 버그를 발생시키지 못할 수 있다. 반면 너무 길다면 프로그램이 느려질 수 있다. 대부분의 fuzzer는ㄴ adhoc을 사용하여 input의 길이를 변경한다. 반면 Angora는 새로운 branch를 탐색할 수 있는 더 긴 input이 필요할때를 감지하고 최소 필요 길이를 결정하는 코드로 프로그램을 계측한다.</p></li></ol><p>다음은 조건문을 fuzzing하는 단계의 diagram과 코드이다.</p><p>![Figure1]</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>*</span> <span class=n>i</span> <span class=o>-</span> <span class=n>j</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span><span class=cm>/* some code*/</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>{</span><span class=cm>/* some code*/</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>1024</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nf>fread</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>),</span> <span class=mi>1024</span><span class=p>,</span> <span class=n>fp</span><span class=p>)</span><span class=o>&lt;</span> <span class=mi>1024</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nf>fread</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>),</span> <span class=mi>1</span><span class=p>,</span> <span class=n>fp</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nf>fread</span><span class=p>(</span><span class=o>&amp;</span><span class=n>j</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>),</span> <span class=mi>1</span><span class=p>,</span> <span class=n>fp</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>foo</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>다음과 같은 내용을 확인할 수 있다.</p><h3 id=byte-level-taint-tracking>Byte-level taint tracking<a hidden class=anchor aria-hidden=true href=#byte-level-taint-tracking>#</a></h3><p>Angora는 2번째줄의 if문을 fuzzing할때 byte-level taint tracking을 사용하여 1024-1031번째 byte flow가 표현식을 결정함을 확인하여 이 byte들만 변형한다.</p><h3 id=search-algorithm-based-on-gradient-descent>Search algorithm based on gradient descent<a hidden class=anchor aria-hidden=true href=#search-algorithm-based-on-gradient-descent>#</a></h3><p>Angora는 2번째 줄의 조건문의 두 분기를 각각 실행하는 입력을 찾아야 한다. 조건문 내 표현식을 입력 x에 대한 f(x)로 처리하고 gradient descent algorithm을 사용하여 f(x)>0, f(x&rsquo;)&lt;=0인 두 input x, x&rsquo;을 찾는다.</p><h3 id=shape-and-type-inference>Shape and type inference<a hidden class=anchor aria-hidden=true href=#shape-and-type-inference>#</a></h3><p>f(x)는 vector x에 대한 함수이다. gradient descent를 적용할때 Angora는 x의 각 component에 대해 편미분을 계산해야 하므로 각 component와 유형을 결정해야한다.</p><h3 id=input-length-exploration>Input length exploration<a hidden class=anchor aria-hidden=true href=#input-length-exploration>#</a></h3><p>input이 1032byte보다 작을때 mian은 foo를 호출하지 않는다. 무작정 긴 input을 시도하는 대신 input에서 읽는 일반적인 함수들을 계측하고 더 긴 입력이 새로우 state를 탐색할 지 결정한다.</p><h2 id=32-context-sensitive-branch-count>3.2. Context-sensitive branch count<a hidden class=anchor aria-hidden=true href=#32-context-sensitive-branch-count>#</a></h2><h3 id=context-insensetive>context-insensetive<a hidden class=anchor aria-hidden=true href=#context-insensetive>#</a></h3><p>위에서 AFL의 branch coverage table에 대해서 설명한다. 이러한 설계는 다음과 같은 장점이 있다.</p><ol><li>공간을 효율적으로 사용한다. branch의 수는 프로그램의 크기에 선형적이다.</li><li>range를 사용하여 branch execution count를 사용하면 다음 실행이 새로운 내부 상태를 나타내는지에 대한 heuristic을 제공한다.</li></ol><p>하지만 이러한 설계는 한계가 있다. AFL의 branch는 context-insensetive이기 때문에 같은 branch의 다른 context에서의 실행을 구분하지 못하며 프로그램의 내부 새로운 내부 상태를 넘어갈 수 있다. 다음은 이에 대한 예시이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>bool</span> <span class=n>x</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>bool</span> <span class=n>trigger</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>trigger</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=c1>// crash
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> 
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>trigger</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>trigger</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=p>[]</span> <span class=n>input</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>f</span><span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>if(x)</code>의 branch coverage를 고려해 보자.
첫번째 입력이 <code>10</code>이라면 19번째 줄에서 <code>f()</code>를 호출할때 true branch를 실행히킨다. 이후 21줄에서 <code>f()</code>를 실행시킬때 10번째줄의 false를 실행시킨다.</p><p>AFL의 branch가 context-insensetive 이기에 두 input 모두 실행되었다고 생각한다.</p><p>그 이후 <code>01</code>이 입력으로 들어온다면 AFL은 이전 입력에서도 역시 3,10 branch 모두 실행되었기 때문에 이 입력은 새로운 내부 state를 trigger하지 않는다고 생각한다. 하지만 이 입력은 새로운 내부 상태를 trigger 한다. input[2]==1일때 crash를 발생시킨다.</p><p>※ 논문에서 오타가 있는것 같다. 코드와 설명 모두 input[2]가 아닌 input[1]로 해석해야 할것 같다.</p><h3 id=context-sensetive>context-sensetive<a hidden class=anchor aria-hidden=true href=#context-sensetive>#</a></h3><p>우리는 branch를 tuple (l_prev, l_cur, context)로 정의하여 context를 포함한다.</p><p>l_prev와 l_cur는 조건문 전 후의 baisc block의 ID 이고 context는 h(stack)이다. 예를들어 위 코드를 <code>10</code>으로 실행할때 19줄의 <code>f()</code>로 들어간 이후에는 branch (l_3, l_4, [l19])를 실행한다. 이후 21줄의 <code>f()</code>를 실행한 경우에는 branch (l_3, l_10, [l21])을 실행한다.
반면 <code>01</code>의 input으로 실행될 때에는 (l_3, l_10, [l19])를 실행한 후 (l_3, l_4, [l21])을 실행하기 때문에 barnch의 정의에 context를 포함시킴으로서 Angora는 두번째 input이 새로운 내부 state를 trigger한다는것을 감지할 수 있다.</p><h3 id=using-hash-function>using hash function<a hidden class=anchor aria-hidden=true href=#using-hash-function>#</a></h3><p>branch에 context를 추가한다면 unique branch의 수가 증가하며 deep recursion이 발생할 수 있다. 현재 구현은 call stack의 hash를 계산하기 위하여 hash function h를 사용함으로 이 문제를 완화한다.</p><p>h는 stack상의 모든 call site의 ID의 xor을 계산한다. Angora가 프로그램을 계측할때 각 call site에 랜덤 ID를 할당한다. 함수가 f가 자신을 재귀적으로 호출할때 Angora가 동일한 call site의 ID를 call stack 얼마나 많이 push하든 h(stack)은 최대 2개의 고유값을 출력한다.</p><p>즉 함수 f 내의 unique branch의 수를 최대 2배까지만 증가시킨다. 실제 프로그램에 대한 평가는 context를 포함한 후 unique branch가 최대 7.21배 까지 증가한다는 것을 보여준다. 이는 code coverage가 증가한다는 이점을 얻기 위한 대가이다.</p><h2 id=33-byte-level-taint-tracking>3.3. Byte-level taint tracking<a hidden class=anchor aria-hidden=true href=#33-byte-level-taint-tracking>#</a></h2><h3 id=taint-tracking>taint tracking<a hidden class=anchor aria-hidden=true href=#taint-tracking>#</a></h3><p>Angora는 탐색되지 않은 branch를 실행하는 입력을 생성하는것을 목표로 한다. 탐색되지 않은 branch를 실행하려고 할때 그 branch의 predicate에 따라 영향을 미치는 input내의 byte offset을 알아내야한다. 이를 위하여 byte-level taint analysis를 사용한다.</p><p>taint analysis는 비용이 많이 든다. 특히 개별 byte를 추적할때는 더욱 그렇다. 이로 인하여 AFL은 이를 사용하지 않는다.</p><p>우리는 대부분의 프로그램 실행에서 taint tracking이 불필요하다고 생각한다. input에 대하여 한번 taint tracking을 실행한다면 각 조건문으로 흐르는 byte offset을 기록할 수 있다. 그 이후 byte를 mutate할때 taint tracking을 하지 않을 수 있다.</p><p>이는 taint tarcking의 비용을 많은 mutation에 걸쳐 분산시킨다. 이로 인하여 Angora는 AFL과 유사한 양의 input execution을 처리할 수 있다.</p><h3 id=data-structure-of-taint-label>data structure of taint label<a hidden class=anchor aria-hidden=true href=#data-structure-of-taint-label>#</a></h3><p>Angora는 프로그램내 각 변수 x를 taint label t_x와 연결한다. taint label의 data구조는 메모리사용량에 큰 영향을 미친다.</p><p>단군한 구현 방법은 각 taint label을 bit vector로 표현하는 것이며 여기서 각 비트 i는 input의 i번째 byte를 나타낸다. 하지만 bit vector의 크기가 input의 크기에 선형적으로 증가하기 때문에 이러한 data구조는 큰 입력에 대해서 사용하기 힘들다.</p><p>taint label의 크기를 줄이기 위하여 bit vetor를 table에 저장하고 table의 index를 taint label로 사용할 수 있다. table 항목중 logarithm이 가장 긴 vector의 길이보다 작은 경우가 있는데 이를 이용하여 taint label의 크기를 크게 줄일 수 있다.</p><h4 id=using-table>using table<a hidden class=anchor aria-hidden=true href=#using-table>#</a></h4><p>하지만 다음과 같은 연산을 지원해야 한다.</p><ul><li>INSERT(b) : bit vector b를 삽입하고 그 라벨을 반환한다.</li><li>FIND(t) : taint label t에 대한 bit vector를 반환한다.</li><li>UNION(tx,ty) : t_x, t_y의 합집합을 표현하는 taint label을 반환한다.</li></ul><p>FIND는 저렴하지만 Union은은 비용이 많이든다. UNION은 다음과 같은 단계를 거친다.</p><ol><li>두 label의 bit vector를 찾아 합집합 u를 계산한다.</li><li>u가 이미 존재하는지 여부를 결정하기 위하여 table을 검색한다. 존재하지 않는다면 u를 추가한다. 이때 선형 검색을 하는데 많은 비용이 든다.</li></ol><p>이를 해결하기위하여 hash set을 구축할 수 있겠지만 많은 bit vector가 존재하고 각 bit vector가 길다면 hash code를 계산하는데 많은 시간이 걸리고 hash set을 저장하는데 많은 공간이 필요하다.</p><p>산술 표현힉에서 taint data를 추적할때 UNION이 흔한 연산이므로 효율적이여야 한다. 서로 다른 vector가 같은 위치에 1을 가질 수 있기 때문에 UNION-FIND 구조를 사용할 수 없다.</p><h4 id=using-binary-tree>using binary tree<a hidden class=anchor aria-hidden=true href=#using-binary-tree>#</a></h4><p>bit vector를 저장하기 위한 data structure를 도입한다. 이 data structure는 효율적인 INSERT, FIND, UNION을 가능하게 한다. 각 bit vector는 부호 없는 정수를 사용하여 고유한 라벨을 할당한다. 새 bit vector를 삽입할때 다음으로 사용가능한 부호없는 정수를 할당한다. 이를 위하여 다음 두가지 요소를 사용해야한다.</p><ul><li>binary tree를 사용하여 bit vector를 label로 mapping한다.</li><li>look up table은 label을 bit vector로 mapping한다.</li></ul><p>이 데이터 구조를 사용하여 bit vector를 효율적으로 관리하고 label을 사용하여 bit vector를 빠르게 찾아내며 UNION연산을 수행할때 필요한 bit vector의 합집합을 효과적으로 결정할 수 있다. 메모리 사용량을 최소화 하며 필요한 연산을 신속하게 수행할 수 있는 방법을 제공한다.</p><p>이 data structure에서 tree의 모든 leaf는 bit vector를 대표한다. 내부 node는 bit vector를 표현하지 않는다. 그래서 tree 에는 불필요한 많은 node를 가 있다.</p><p>예시를 들기 전에 regular expression에 대해 알아본다. 먼저 <code>x*</code> 는 x가 0개 이상 반복된다는 의미이다. 또한 <code>[xy]</code>는 x또는 y를 의미한다.</p><ol><li><code>x00*</code>가 tree에 있다.</li><li><code>x0[01]*1[01]*</code>가 tree에 없다.</li></ol><p>이때 x를 대표하는 어떤 node도 저장할 필요 없다.
x는 오직 하나의 decedent를 가지며 그 decedent는 leaf이기 때문이다. 그리고 그것은 <code>x00*</code>로 표현된다. 따라서 우리는 tree에 vector를 삽입할때 다음과 같이 정리 할 수 있다.</p><ol><li>벡터 끝의 모든 0을 제거한다.</li><li>벡터의 첫 bit부터 마지막 bit까지 bit를 따라 tree를 순회한다. child가 없으면 생성한다.<ul><li>bit가 0이라면 left child</li><li>그렇지 않으면 right child</li></ul></li><li>마지막으로 방문한 node에 vector의 label을 저장한다.
이 절차를 통하여 bit vector를 저장할때 필요없는 node의 생성을 방지하고 data structure의 효율성을 높일 수 있다. vector가 많고 긴 경우에도 효율적이다.</li></ol><p>Algorithm 2는 이 삽입 연산을 자세히 설명한다. Algorithm 3은 FIND, 4는 UNION연산을 설명한다. node를 생성할때 초기에는 label이 없음을 고려해야 한다. bit vector를 삽입할때 마지막으로 방문한 노드가 label이 없는 노드인 경우 우리는 이 node에 bit vecotr의 label을 저장한다. 이 tree는 다음 특성을 갖는다.</p><ul><li>leaf node는 label을 저장한다.</li><li>내부 node는 label을 포함할 수 있지만 내부 node의 label은 교체하지 않는다.</li></ul><p><img loading=lazy src alt=Algorithm2></p><p><img loading=lazy src alt=Algorithm3></p><p><img loading=lazy src alt=Algorithm4></p><p>이 구조를 이용하여 bit vecotr를 저장하는데 필요한 메모리 사용량을 크게 줄인다.</p><h2 id=34-search-algorithm-based-on-gradient-descent>3.4. Search algorithm based on gradient descent<a hidden class=anchor aria-hidden=true href=#34-search-algorithm-based-on-gradient-descent>#</a></h2><p>byte-level taint tracking은 어떤 byte offset이 조건문으로 flow되는지 발견할 수 있다. input을 matate하여 탐색되지 않은 branch를 탐색한다. 대부분의 fuzzer는 무작 또는 조잡한 heuristic을 사용하지만 빠르게 적절한 input을 찾기 힘들다. 반면 이 논문에서는 이를 serach problem으로 보고 machine learning에서의 serach algorithm을 사용하였다. 여기서는 gradient descent를 사용하였지만 다른 search algorithm을 사용할 수 있다.</p><h3 id=transform-comparison-into-constraint>transform comparison into constraint<a hidden class=anchor aria-hidden=true href=#transform-comparison-into-constraint>#</a></h3><p>이 접근 방식에서 branch를 실행하기 위한 predicate를 blackbox funtion <em>f(x)</em> 에 대한 constraint로 본다. x는 predicate로 흐르는 input value들의 vector이고 *f()*는 프로그램 시작부터 이 predicate까지의 path에서의 계산을 감지한다. *f(x)*에는 3가지 constraint가 있다.</p><ol><li><em>f(x)</em>&lt;0</li><li>*f(x)&lt;=0</li><li><em>f(x)</em>=0</li></ol><p>다음 표는 모든 형태의 비료를 3가지 유형의 constraint로 변환할 수 있음을 보여준다. 조거문의 조건에 논리연산자 <code>&&</code>또는 <code>||</code>이 포함된 경우 Angora는 이 조건문을 여러 조건문으로 분할한다. 예를들어
<code>if (a && b) {s} else {t}</code> 를 <code>if (a) { if (b) {s} else {t} } else {t}</code>로 분할한다.</p><table><thead><tr><th style=text-align:left>Comparison</th><th style=text-align:left><em>f</em></th><th style=text-align:left>Constraint</th></tr></thead><tbody><tr><td style=text-align:left>a&lt;b</td><td style=text-align:left><em>f</em>=a-b</td><td style=text-align:left><em>f</em>&lt;0</td></tr><tr><td style=text-align:left>a&lt;=b</td><td style=text-align:left><em>f</em>=a-b</td><td style=text-align:left><em>f</em>&lt;=0</td></tr><tr><td style=text-align:left>a>b</td><td style=text-align:left><em>f</em>=b-a</td><td style=text-align:left><em>f</em>&lt;0</td></tr><tr><td style=text-align:left>a>=b</td><td style=text-align:left><em>f</em>=b-a</td><td style=text-align:left><em>f</em>&lt;=0</td></tr><tr><td style=text-align:left>a==b</td><td style=text-align:left><em>f</em>=abs(a-b)</td><td style=text-align:left><em>f</em>==0</td></tr><tr><td style=text-align:left>a!=b</td><td style=text-align:left><em>f</em>=-abs(a-b)</td><td style=text-align:left><em>f</em>&lt;=0</td></tr></tbody></table><h3 id=gradient-decent>Gradient decent<a hidden class=anchor aria-hidden=true href=#gradient-decent>#</a></h3><p>algorithm 5는 serach algorithm을 보여준다. 초기 x_0에서 시작하여 *f(x)*가 constraint를 만족하는 x를 찾는다. 각 유형의 constraint를 만족하기위해서 *f(x)*를 최소화 해야 하며 이때 gradient descent를 사용한다.</p><p>gradient descent는 반복적으로 작용하여 x에서 시작하여 *f(x)*의 기울기$∇_xf(x)$ 를 계산하고 x를 $x-ϵ∇_xf(x)$ 로 업데이트 한다. 여기서 $ϵ$는 learning rate이다.</p><p><img loading=lazy src alt=algorithm5></p><p>신경망을 훈련할때 연구자들은 훈련 오류를 최소화하는 가중치 집합을 찾기 위하여 gradient descent를 사용한다. 하지만 이 방법은 때때로 local minimum에 갇힐 수 있고 이는 global minimum이 아닐 수 있다. 다행이 fuzzing에서는 이는 문제가 되지 않는다. 우리는 global에서도 최적화 된 x 대신 적당히 좋은 x를 찾으면 되기 때문이다. 예를들어 constraint가 <em>f(x)</em>&lt;0 라면 f(x)가 global minimum이 아닌 <em>f(x)</em>&lt;0을 만족하는 x를 찾으면 되기 때문이다.</p><h3 id=problem-of-gradient-decent>Problem of Gradient decent<a hidden class=anchor aria-hidden=true href=#problem-of-gradient-decent>#</a></h3><p>fuzzing에 gradient descent를 사용할때는 새로운 문제점이 발생한다.</p><ol><li><p>$∇_xf(x)$ 를 계산하는 것이다. 신경망 에서는 $∇_xf(x)$ 를 analytic form으로 작성할 수 있지만 fuzzing에서는 <em>f(x)</em> 의 analytic form이 없다.</p></li><li><p>신경망에서 <em>f(x)</em> 는 연속 함수이지만 fuzzing 에서는 보통 이산함수이다. 대부분의 변수들이 이산적이기 때문에 x의 대부분의 요소가 이산적이기 때문이다.</p></li></ol><h3 id=numerical-approximation-of-gradient-decent>numerical approximation of gradient decent<a hidden class=anchor aria-hidden=true href=#numerical-approximation-of-gradient-decent>#</a></h3><p>이 문제를 numerical approximation을 이용하여 해결하였다. <em>f(x)</em> 의 gradient는 각 점에 x에서 어떤 단위 벡터 v와의 내적이 v방향으로의 *f(x)*의 directional diveration인 고유한 vector field 이다. 우리는 directional diveration을 다음과 같이 근사하였다.</p><p>$∂f(x)\over∂x_i$ $=$ $f(x+δv_i)-f(x)\overδ$</p><p>여기서 δ는 작은값 (ex 1) 이고 $v_i$는 i번째 차원의 단위벡터이다.</p><p>각 directional diveration을 계산하기 위하여 우리는 프로그램을 두번 실행해야 한다. 한번은 $x$로 두번째는 $x+δv_i$로 실행한다.</p><p>두번째 실행에서 $f(x+δv_i)$가 계산되는 프로그램의 지점에 도달하지 못할 수 있다. 이런 상황이 발생하면 우리는 $δ$를 작은 음수 값 (ex -1)로 설정하고 $f(x+δv_i)$를 다시 계산해보려고 한다. 이것이 성공한다면 directional diveration을 계산할 수 있다. 그렇지 않는다면 우리는 diveration을 0으로 설정하여 gradient decent가 x를 변경하지 못하도록 한다. 이 계산방법은 x의 길이에 비례한 시간이 걸린다.</p><p>이론적으로 gradient decent는 모든 constraint를 해결할 수 있다. 하지만 얼마나 빠르게 해결할 수 있는지는 mathmatical funtion의 복잡성에 달려있다.</p><ul><li>만약 $f(x)$가 단조롭거나 볼록하다면 $f(x)$가 복잡한 analytic form을 가지고 있더라도 해결책을 빠르게 찾을 수 있다.</li><li>gradient decent이 찾는 local minimum이 constraint를 만족한다면 solution을 찾는것도 빠르다.</li><li>만약 local minimum이 constraint를 만족하지 않는다면 Angora는 다른값 x&rsquo;으로 무작위 이동하여 거기서 다시 gradient decent를 수행하여 constraint를 만족하는 다른 local minimum을 찾기를 희망한다.</li></ul><p>Angora는 $f(x)$의 analytic form을 생성하지 않고 오히려 프로그램을 실행하며 $f(x)$를 계산한다.</p><h2 id=35-shape-and-type-inference>3.5. Shape and type inference<a hidden class=anchor aria-hidden=true href=#35-shape-and-type-inference>#</a></h2><p>단순히 x의 각 요소를 조건문으로 흐르는 input의 byte로 설정할 수 있다. 하지만 이는 type mismatch로 인하여 gradient decent에서 문제를 일으킬 수 있다. 예를들어 input의 연속된 4 byte $b_3b_2b_1b_0$을 정수로 처리하고 $x_i$가 이 값응ㄹ 대표하도록 하자. 우리는 $f(x+δv_i)$를 계산할때 δ를 더해야 한다.</p><p>하지만 만약 각 byte에 대하여 $x_i$로 단수히 할당한다면 각 byte에 대하여 $f(x+δv_i)$를 계산하게된다. 프로그램에서는 byte들을 단일 값으로 결합하고 표현식에서는 결합된 값을 사용하기에 LSB를 제외한 byte에 대해서 δ를 더하는 것은 값을 크게 변경하게 되며 편미분의 의미에서 벗어난다.</p><p>이 문제를 피하기위하여 (1)프로그램에서 항상 단일 값으로 함께 사용되는 input의 byte들과 (2)그 유형에 대하여 추론해야한다.</p><p>(1)의 문제를 shape inference, (2)의 문제를 type inference 라고 한다. 이는 dynamic taint analysis중에 해결된다.</p><h3 id=shape-inference>shape inference<a hidden class=anchor aria-hidden=true href=#shape-inference>#</a></h3><p>shape inference를 위하여 초기에 모든 입력을 독립적이라고 본다. taint analysis 동안 input byte를 sequence로 읽을때 Angora는 이러한 byte들을 같은 value에 포함되는것으로 tag한다. 만약 이 과정속에서 겹치는 것이 있다면 더 작은 크기를 선택한다.</p><h3 id=type-inference>type inference<a hidden class=anchor aria-hidden=true href=#type-inference>#</a></h3><p>type inference를 위하여 Angora는 값에 작용하는 명령어의 semantic에 의존한다. 예를들어 명령어가 signed integer에 작용한다면 Angora는 해당 피연산자를 signed integer로 추론한다. 같은 값이 signed, unsigned로 모두 사용될 경우 Angora는 unsigned로 처리한다. 만약 이러한 type inference가 실패하더라도 gradient descent를 이용하여 solution을 찾을 수 있다. 시간이 오래 걸릴 뿐이다.</p><h2 id=36-input-length-exploration>3.6. Input length exploration<a hidden class=anchor aria-hidden=true href=#36-input-length-exploration>#</a></h2><p>Angora는 다른 fuzzer에 비해 더 작은 input으로 fuzzing을 시작한다. 그러나 일부 branch는 input length가 특정 값보다 클때 실행된다.</p><p>fuzzer가 너무 짧은 input을 사용한다면 그 분기를 탐색할 수 없다. 하지만 너무 긴 input을 사용한다면 프로그램이 느려지고 메모리 부족으로 실행이 단될 수 있다. 대부분의 fuzzer는 adhoc 방식을 사용하여 다양한 입력을 시도한다. 반면 Angora는 새로운 branch를 탐색할 수 있을때만 input의 길이를 증가시킨다.</p><p>tacking을 수행하는 동안 Angora는 read-like function을 호출할대 destination memory를 input byte offset과 연결한다. 또한 read call에서 반환 값에 특별한 label을 표시한다.</p><p>반환 값이 조건문에서 사용되고 constraint를 만족하지 않는 경우 Angora는 read call이 요쳥하는 모든 byte를 얻을 수 있도록 input length를 증가시킨다. 이러한 기준이 모든 경우를 포함하는것은 아니지만 프로그램이 우리가 예상하지 못한 방식으로 input을 사용하고 그 길이를 확인할 수 있지만 그것을 발견하면 Angora에 기준을 추가하는것은 쉽다.</p><h1 id=4-implementation>4. Implementation<a hidden class=anchor aria-hidden=true href=#4-implementation>#</a></h1><h2 id=41-instrumentation>4.1. Instrumentation<a hidden class=anchor aria-hidden=true href=#41-instrumentation>#</a></h2><p>Angora는 LLVM pass를 사용하여 프로그램을 계측함으로써 실행 파일을 생성한다. 계측은 다음 과정을 수행한다.</p><ol><li>조건문의 기본 정보를 수집하고 taint analysis를 통하여 input byte offset과 연결한다. Angora는 각 입력에 대해 이 단계를 한번만 실행한다.</li><li>새로운 ipnt을 식별하기위하여 excution trace를 기록한다.</li><li>runtime에 context를 사용한다.</li><li>조건문에서 표현된 값을 수집한다.</li></ol><p>이러한 계측 과정은 프로그램의 실행동안 필요한 데이터를 수집하여 Angora가 더 효과적으로 fuzzing을 수행할 수 있도록 한다.</p><p>Angora는 byte-level taint tracking을 위하여 *DataFlowSanitizer (DFSan)*을 확장하여 구현하였다. FIND와 UNION 기능에도 caching 기능을 추가하여 속도를 향상시켰다.</p><p>Angora는 LLVM 4.0.0 (DFSan 포함)에 기반하였다. LLVM pass은 DFSan을 제외하고 C++ 820줄 코드로 이루어져 있으며 runtime에는 taint label을 저장하기위한 data structure, input을 오염시키고 조건문을 추적하기 위한 hook을 포함하여 C++ 1950로 구현하였다.</p><p>두개의 분기를 가진 if문 외에도 <em>LLVM IR</em>은 여러 branch를 도입할 수 있는 switch문도 지원한다. Angora는 switch 문을 if문을 변환한다.</p><p>Angora는 조건문에서 문자열과 배열을 비교하는 libc function을 인식한다 예를들어 <code>strcmp(x,y)</code>를 <code>x strcmp y</code>로 변환한다 여기서 strcmp는 Angora가 이해하는 특별한 비교연산이다.</p><h2 id=42-fuzzer>4.2. Fuzzer<a hidden class=anchor aria-hidden=true href=#42-fuzzer>#</a></h2><p>Angora를 4488줄의 Rust코드로 구현하였다. fork server, CPU binding과 같은 기술로 최적화 하였다.</p><h1 id=5-evaluation>5. Evaluation<a hidden class=anchor aria-hidden=true href=#5-evaluation>#</a></h1><p>Angora를 3단계로 평가하였다.</p><ul><li>다른 최신 fuzzer와의 성능 비교</li><li>test coverage와 새로운 bug를 찾는 능력</li><li>중요한 새로운 기능</li></ul><p>Angora는 멀티코어를 지원하지만 다른 fuzzer와의 비교를 위하여 단일 코어를 사용였다. 각 실험을 5회 실행하고 평균 성능을 평가하였다.</p><h2 id=51-compare-angora-with-other-fuzzers>5.1. Compare Angora with other fuzzers<a hidden class=anchor aria-hidden=true href=#51-compare-angora-with-other-fuzzers>#</a></h2><p>Fuzzer를 비교하는 절대적 지표는 버그를 찾는 능력이다. 좋은 test set는 실제 프로그램과 현실적인 버그를 포함해야 한다. LAVA는 프로그램 source code에 대량의 현실적인 버그를 주입하여 ground-truth corpus를 생성한다.</p><p>저자는 4개의 GNU coreutils 프로그램 (uniq, base64, md5sum, who)에 버그를 주입하여 LAVA-m corpus를 생성하였다. Angora를 다음 fuzzer들과 비교하였다.</p><ul><li>Fuzzer :coverage based fuzzer, SES :symbolic execution and SAT solving</li><li>VUzzer : &ldquo;magic byte"전략을 사용하는 fuzzer</li><li>Steelix : LAVA-M에서 VUzzer보다 뛰어난 fuzzer</li><li>AFL 2.51b : 논문 작성 시점의 최신 AFL 버전</li></ul><p>Angora가 가장 좋았음 uniq, base64, md5sum 에서 모든 bug와 who의 대부분의 bug, 103개의 unlisted bug도 찾았다.</p><p>다음같은 이유로 Angora가 좋았다.</p><ol><li>LAVA는 bug가 포함된 분위글 보호하기 위하여 &ldquo;magic byte"를 사용한다. 일부 magic byte입력은 직접 복사되는것이 아닌 입력에서 계산된다. VUzzer와 Steelix의 magic byte 전략은 magic byte를 입력에 직접 복사할 수 있으므로 해당 분기를 탐색하는 입력을 생성할 수 없다.</li><li>VUzzer는 &ldquo;magic byte"를 맹목적으로 시도하고 Steelix는 random mutation 중 &ldquo;magic byte"와 같은 byte가 존재할때 이 전략을 사용한다. 반면 Angora는 컴퓨팅 파워를 사용하여 탐색되지 않음 branch 의 path constraint를 해결하기 위하여 스케줄링 하기 때문에 더 많은 branch를 cover할 수 있어서 LAVA-M에 주입된 대부분의 버그를 빠르게 찾을 수 있다.</li></ol><h2 id=52-evaluate-angora-on-unmodified-real-world-programs>5.2. Evaluate Angora on unmodified real world programs<a hidden class=anchor aria-hidden=true href=#52-evaluate-angora-on-unmodified-real-world-programs>#</a></h2><p>LAVA에서 명시되지 않은 bug를 찾는 높은 성능을 보였다. 발견한 버그가 인위적으로 주입된 것인지 확인하기 위하여 최신의 8개의 open source 프로그램에 대해서 평가하였다. 이러한 프로그램들은 crash가 적을겉으로 예상되었지만 꽤 많은 버그를 찾을 수 있었다. AFL 또한 -cmin -C 명령을 주어 크래시 중복 제거를 주어 실행하여 비교해본 결과 branch coverage, line coverage, Unique crash 부분에서 더 좋은 성능을 확인할 수 있었다.</p><p>이와같은 이유는 복잡한 조건문의 양쪽 branch를 모두 탐색할 수 있기 때문이다. 예를들어 다음과 같은 코드에서 AFL은 true branch 를 탐색할 수 없다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=c1>// readelf.c:620
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>namesz</span><span class=o>==</span><span class=mi>10</span> <span class=o>&amp;&amp;</span> <span class=nf>strcmp</span><span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>nbuf</span><span class=p>[</span><span class=n>noff</span><span class=p>],</span> <span class=s>&#34;DragonFly&#34;</span><span class=p>)</span><span class=o>==</span><span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>type</span> <span class=o>==</span> <span class=n>NT_DRAGONFLY_VERSION</span> <span class=o>&amp;&amp;</span> <span class=n>descsz</span><span class=o>==</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=53-context-sensitive-branch-count>5.3. Context-sensitive branch count<a hidden class=anchor aria-hidden=true href=#53-context-sensitive-branch-count>#</a></h2><h3 id=531-performance>5.3.1. Performance<a hidden class=anchor aria-hidden=true href=#531-performance>#</a></h3><p>3.2절에서는 context-sensetive branch에 대해서 소개하였다. 우리는 동일한 branch를 다른 function call context와 구분하는 것이 더 많은 버그를 찾을것이라고 생각하였다. 이 가설을 평가하기 위하여 context-sensetive branch count와 context-insensetive branch counter를 각각 사용하여 Angora를 실행하였다.</p><p>결과는 context-insensetive 를 사용하여 하나의 bug도 찾지 못하였다. 하지만 sensetive 방식으로는 6개의 버그를 찾았다.</p><h3 id=532-hash-collision>5.3.2. Hash collision<a hidden class=anchor aria-hidden=true href=#532-hash-collision>#</a></h3><p>Angora는 barnch count를 hash table에 저장한다. Angora가 calling context를 포함하여 branch coverage를 계산하기 때문에 더 많은 branch를 hash table에 삽입하게 된다. 따라서 hash collision rate를 낮추기 위하여 hash table의 크기를 증가시켜야 한다.</p><p>AFL의 경우 2^16 bukit을 갖는 hash table이 충분하다고 생각하였지만 Angora의 경우 16배 늘린 2^20개의 bukit을 할당하였다.</p><p>AFL과는 다르게 Angora는 새로운 path를 찾기 위하여 hash table을 탐색하지 않고 input을 우선시 하기에 hash table이 크더라도 실행속도에 영향을 덜 미친다.</p><h2 id=54-search-based-on-gradient-descent>5.4. Search based on gradient descent<a hidden class=anchor aria-hidden=true href=#54-search-based-on-gradient-descent>#</a></h2><p>3.4절에서 조건문의 constarint를 해결하기 위하여 gradient descent를 사용하는 방법을 설명하였다. 우리는 이 방법을 randome mutation과 magic byte 전략과 비교하여 더 많은 constraint를 해결하였음을 확인하였다.</p><h2 id=55-input-length-exploration>5.5. Input length exploration<a hidden class=anchor aria-hidden=true href=#55-input-length-exploration>#</a></h2><p>Angora는 path constraint가 input length에 의존한다는 것을 관찰하면 input length를 증가시킨다. 반면 AFL과 같은 fuzzer는 input length를 무작위로 증가시킨다. 이 두 전략을 다음 두가지 기준으로 비교하였다.</p><ul><li>얼마나 자주 증가시키는지, 또한 생성된 input중 얼마나 많은 input이 유용한지.</li><li>유용한 input의 평균 길이는 어떻게 되는지</li></ul><p>우리는 Angora와 AFL을 5시간동안 실험하여 Angora의 전략이 훨씬 더 효율적이고(더 자주 유용한 입력을 만듬) 생성된 input의 길이가 더 짧다는 사실은 확인할 수 있었다. 짧은 input은 대체로 많은 프로그램에서 더 빠르게 실행되기 때문에 Angora의 전략이 더 높은 품질의 input을 생성한다는것을 확인하였다.</p><h2 id=56-execution-speed>5.6. Execution speed<a hidden class=anchor aria-hidden=true href=#56-execution-speed>#</a></h2><p>Angora의 taint analysis는 비용이 많이든다. 하지만 Angora는 input에 대해서 한번만 이 과정을 수행하기 때문에 일회성 비용이라고 생각할 수 있다. 이 때문에 AFL보다 살짝 낮은 속도로 실행한다. 하지만 Angora는 더 높은 품질의 input을 생성하여 더 높은 coverage와 더 많은 버그를 찾아낼 수 있다.</p><h1 id=6-related-work>6. Related work<a hidden class=anchor aria-hidden=true href=#6-related-work>#</a></h1><h2 id=61-prioritize-seed-inputs>6.1. Prioritize seed inputs<a hidden class=anchor aria-hidden=true href=#61-prioritize-seed-inputs>#</a></h2><p>mutation-based fuzzer에서 중요한 부분은 seed input을 현명하게 선택하는것이다. <em>Rebert</em>는 seed selection scheduling 문제를 고안하고 분석하였다. 그들은 <em>PeachFuzzer</em>를 기반으로 여섯가지 다른 seed selection algorithm을 설계하고 평가하였다.</p><p>결과는 seed selection algorithm에 의한 heuristic이 random sampling보다 더 좋은 결과를 나타내었다.</p><p><em>AFLFast</em>는 대부분의 fuzz tsting이 동일한 몇개의 high frequency path를 탐색한다고 관찰하였다. Markov chain을 사용하여 low frequency path를 탐지해 내었고 이러한 경로를 포함하는 입력을 우선적으로 처리하였다.
<em>VUzzer</em> 또한 path를 모델링 하기 위하여 control-flow의 특징을 사용하여 도달하기 힘든 paht에 대한 input을 먼저 처리하였다. 또한 error-handling basic block을 감지하고 이 block들을 포함하지 않는 input을 우선적으로 처리하였다. 반면 Angora는 미탐색 branch가 있는 조건문을 포함하는 path를 가진 input을 선택하였다. 이러한 전략은 더 일반적으로 high frequency path를 탐색한 이후에 자동으로 low frequency path에 집중하도록 한다.</p><h2 id=62-taint-based-fuzzing>6.2. Taint-based fuzzing<a hidden class=anchor aria-hidden=true href=#62-taint-based-fuzzing>#</a></h2><p>taint analysis는 다음과 같은 더많은 용도로 사용된다.</p><ul><li>malware analyzing</li><li>detexting and preventing information leaks</li><li>debugging software</li><li>fuzzing</li></ul><p>taint based fuzzing은 프로그램이 input을 처리하는 방식을 분석하여 input의 어떤 부분을 수정해야하는지 결정한다. 이러한 fuzzer중 일부는 보안에 민감한 코드에서 사용되는 값을 input에서 찾고 이러한 input의 해당 부분을 수정하여 crash를 일으키려고 노력한다.</p><p>예를들어 <em>BuzzFuzz</em>는 taint tracking을 사용하여 &ldquo;attack point"라고 정의한 것에 input byte를 찾았다. <em>Dowser</em>는 BOF로 이어질 가능성이 높은 코드를 security sensitive code로 보았다. 즉 접근 가능한 path에서 bug를 악용하려고 시도하였다. <em>Woo</em>는 exploration 과
exploitation trade off를 언급하였다.</p><p>Angora는 탐색한 path를 explotation 하기 위한 이러한 기술을 통합할 수 있다.</p><p>Taintscope*는 check sum 코드를 추론하고 입력을 변조하여 이러한 check를 우회하기위해 taint analysis를 사용하였다.</p><p><em>VUzzer</em>는 taint analysis를 사용하여 &ldquo;magic byte"를 찾은 다음 이를 input의 고정 위치에 할당하였다. 이는 magic byte를 찾을 수 있지만 이러한 바이트가 input에 연속적으로 나타날때만 가능하다. <em>Steelix</em>는 이를 개선하여 program state로부터 magic byte를 추론한다.</p><p>반면 Angora는 byte-level taint tracking을 이용하여 input flow의 byte offset을 얻은 다음 미탐색된 branch의 constraint를 충족시킨다. 이는 magic byte보다 더 많은 유형의 값을 효율적으로 찾을 수 있다.</p><p>Angora는 byte offset을 tree에 저장하고 이를 taint table로 사용하여 input byte offset에 관계없이 taint table의 크기가 일정하다. 여러개의 label이 동일한 taint offset을 가질때 <em>VUzzer</em>는 각 taint lable에 반복하여 저장하지만 Angora는 Tree에 한번만 저장하므로 메모리를 절약할 수 있다.</p><p>이러한 데이터 구조는 roBDD(reduced orderd binary decision digaram)과 비슷하다. Angora는 이를 처음으로 적용하였다.</p><h2 id=63-symbolic-assisted-fuzzing>6.3. Symbolic-assisted fuzzing<a hidden class=anchor aria-hidden=true href=#63-symbolic-assisted-fuzzing>#</a></h2><p>dynamic smybolic execution은 프로그램에 대한 높은 분석을 제공한다. 이러한 기술은 program state를 trigger하는 방법을 알기 때문에 취약점을 직접 찾는데 사용될 수 있다. 고전적인 접근 방식은 crash를 찾기위하여 code coverage를 최대화 하기 위해 symbolic execution을 수행하였다. 하지만 path explosion과 constraint solving은 Symbolic execution을 확장하기 힘들게 하였다. <em>DART</em>나 <em>SAGE</em>는 이를 해결하여 input을 수정할때 dynamic symbolic excution을 사용하였다. <em>SYMFUZZ</em>는 execution trace에서 사용하여 bit position사이의 의존성을 감지하고 fuzzing을 위한 최적의 mutation ratio를 제공하였다. 그러나 모두 symbolic execution에서 비롯된 확장성 문제를 이어받았다. Angora는 symbolic 실행을 사용하지 않아 큰 프로그램에서 효율적으로 많은 버그를 찾을 수 있다.</p><h1 id=7-conclusion>7. Conclusion<a hidden class=anchor aria-hidden=true href=#7-conclusion>#</a></h1><p>Angora라는 강력한 muatint-base fuzzer를 설계하고 구현하였다. 이 fuzzer는 다음과 같은 주요 기술을 사용하여 고품질 input을 생성한다.</p><ul><li>scalable byte-level taint tracking</li><li>context-sensitive branch count</li><li>serach algorithm based on gradient descent</li><li>shape and type inference</li><li>input length exploration</li></ul><p>Angora는 다른 최신 fuzzer보다 더 뛰어난 성능을 발휘하였다. LAVA-M 에서 다른 fuzzer보다 더 많은 버그를 찾았으며 LAVA 저자들이 trigger하지 못한 103개의 버그와 8개의 open source 프로그램에서 많은 175개의 새로운 버그를 찾았다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://246p.github.io/tags/2024/>2024</a></li><li><a href=https://246p.github.io/tags/%ED%95%99%EB%B6%80%EC%97%B0%EA%B5%AC%EC%83%9D/>학부연구생</a></li><li><a href=https://246p.github.io/tags/%EB%85%BC%EB%AC%B8/>논문</a></li><li><a href=https://246p.github.io/tags/lava-m/>LAVA-M</a></li><li><a href=https://246p.github.io/tags/fuzzer/>fuzzer</a></li></ul><nav class=paginav><a class=next href=https://246p.github.io/blog/paper_2/><span class=title>Next »</span><br><span>2. Automated Whitebox Fuzz Testing</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://246p.github.io/>Junlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>