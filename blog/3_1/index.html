<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>3. Syntax analysis (1) | Junlog</title>
<meta name=keywords content="컴파일러,Parser,CFG,Top-Down,Syntax analysis"><meta name=description content="Context-free grammar CFG : defined with a set of production rules ex) E -> E + E E -> E * E E -> id E -> num
Derivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps
Terminal Symbol vs Non-Terminal Symbol Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num) Non-Terminal Symbol : can be rewritten (E)"><meta name=author content="Kim-Minjoon"><link rel=canonical href=https://246p.github.io/blog/3_1/><meta name=google-site-verification content="GTM-524D7HPF"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="3. Syntax analysis (1)"><meta property="og:description" content="Context-free grammar CFG : defined with a set of production rules ex) E -> E + E E -> E * E E -> id E -> num
Derivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps
Terminal Symbol vs Non-Terminal Symbol Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num) Non-Terminal Symbol : can be rewritten (E)"><meta property="og:type" content="article"><meta property="og:url" content="https://246p.github.io/blog/3_1/"><meta property="og:image" content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-01-10T17:47:45+09:00"><meta property="article:modified_time" content="2024-01-10T17:47:45+09:00"><meta property="og:site_name" content="Junlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta name=twitter:title content="3. Syntax analysis (1)"><meta name=twitter:description content="Context-free grammar CFG : defined with a set of production rules ex) E -> E + E E -> E * E E -> id E -> num
Derivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps
Terminal Symbol vs Non-Terminal Symbol Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num) Non-Terminal Symbol : can be rewritten (E)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://246p.github.io/post/"},{"@type":"ListItem","position":2,"name":"3. Syntax analysis (1)","item":"https://246p.github.io/blog/3_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"3. Syntax analysis (1)","name":"3. Syntax analysis (1)","description":"Context-free grammar CFG : defined with a set of production rules ex) E -\u0026gt; E + E E -\u0026gt; E * E E -\u0026gt; id E -\u0026gt; num\nDerivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps\nTerminal Symbol vs Non-Terminal Symbol Terminal Symbol : can\u0026rsquo;t be rewritten anymore (+, *, id, num) Non-Terminal Symbol : can be rewritten (E)","keywords":["컴파일러","Parser","CFG","Top-Down","Syntax analysis"],"articleBody":"Context-free grammar CFG : defined with a set of production rules ex) E -\u003e E + E E -\u003e E * E E -\u003e id E -\u003e num\nDerivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps\nTerminal Symbol vs Non-Terminal Symbol Terminal Symbol : can’t be rewritten anymore (+, *, id, num) Non-Terminal Symbol : can be rewritten (E)\nCFG : Sentence and Language Sentence : Result of derivation that does not contain nay non-terminal\nLanguage : set of all derivable sentences\n𝑳(𝑮) = {𝒘 | 𝑺⇒ ∗𝒘, 𝒘 consists of terminals}\nLeftmost Derivation derivation을 할때 가장 왼쪽의 non-terminal을 먼저 변환하는 규칙\nParse tree Derivation process중 Parse tree를 만들 수 있음\nex) E ⇒ E + E ⇒ id + E ⇒ id + num\nRegEx vs CFG R = ((id | num) (’ + ’ | ’ * ‘))* (id | num) 와 같이 RegEx로 할 수 있다. 하지만 brackets : “{}”, “{{}}”, {{{}}}\",… 과 같이 RegEx로 표현 불가능한 것이 존재 한다. 또한 RegEx는 Parse Tree를 생성할 수 없다. Ambiguous Grammar derivations 방법에 따라서 서도 다른 parse tree가 만들어진다.\n이와 같은 경우를 막기 위하여 세가지 요소를 고려해야한다.\nEliminate ambiguity (Precedence) Bind * before + id + id * id must be interpreted as id + (id * id) (Associativity) * and + associate to the left id + id + id must be interpreted as (id + id) + id 다음과 같이 CFG를 정의하면 가능하다.\nStart variable is E\nE -\u003e E + T | T\nT -\u003e T * F | F\nF -\u003e id | num\nGeneral Rewriting Algorithm? ambiguous -\u003e unambiguous로 rewrite하는 algorithm은 없다.\n심지어 ambiguous 한지 판단하는 algorithm 또한 없다.\nUndecidable problem 하지만 우리는 unambiguous 하다는 가정하에 진행한다. Top-down parsing Parser는 derivation을 추론해야함 (if exist)\nParsing is the process of inferring derivation for the token stream construction of parse tree Top-down parsing leftmost derivations root node에서 아래 방향으로 늘려야함 At each step, we must rewrite the left most non-terminal\n이때 어떠한 production rule을 사용할지 골라야 한다. parsing table : case에 따라 어떤 rule을 사용할지 알려줌\ncurrent status + next token을 통해 고를 수 있음 table drivven LL(1) parsing or LL(1) parsing Left-to-right, Leftmost derivation, 1 token lookahead LL(1) Grammar LL(1) Grammar 란 LL(1) parsing이 적용 되는 CFG를 의미한다. 모든 CFG에 대해서 적용할 수 는 없다. 즉 어떤 grammar들은 parsing table을 만들 수 없음 다음 CFG는 LL(1)이 아님 E -\u003e E + T | T T -\u003e T * F | F F -\u003e id | num\nLeft-Recursion CFG has a variable A that appear as the fist symbol in right-hand side of a rule\n위 예시에서 E, T는 left-recursive 이다.\nCFG가 left-recursive이면 LL(1)이 될 수 없다.\nEliminating Left-Recursion 𝑨 → 𝑨𝜶 | 𝜷\n위와 같은 rule을 다음과 rewrite할 수 있다.\n𝑨 → 𝜷𝑨′\n𝑨′ → 𝜶𝑨′ | 𝝐 이를 우리의 production rule에 적용해 보자.\nLeft- Recursion 이 아니더라도 꼭 LL(1) Grammer는 아니다. 다행히 운이 좋게도 우리의 CFG는 LL(1) Grammar이다.\nLL(1) Parsing Example num + id 에 대해서 LL(1) parsing을 적용해보자\nStack Input Tokens Rule E $ num + id $ T E’ $ num + id $ E -\u003e T E’ F T’ E’ $ num + id $ T -\u003e F T' num T’ E’ $ num + id $ F -\u003e num T’ E’ $ + id $ Match and Pop E’ $ + id $ T’ -\u003e 𝜺 + T E’ $ + id $ E’ -\u003e + T E; T E’ $ id $ Match and Pop F T’ E’ $ id $ T -\u003e F T' id T’ E’ $ id $ F -\u003e id T’ E’ $ $ Match and Pop E’ $ $ T’ -\u003e 𝜺 $ $ E’ -\u003e 𝜺 Parsing Table Parsing 을 수행하다보면 Parsing table의 필요성을 느끼게 된다.\nRow : non-terminal on stack top\nColumn : first terminal (token) in buffer\nFirst and Follow Parsing table을 만들기 위해서는 First, Follow set을 먼저 만들어야 한다.\nFirst(a) : a를 파생하여 나올 수 있는 문장 중 첫 문자들의 집합\nFollow(X) : X를 파생하여 나온 문장 문장 이후 나올 수 있는 문자 들의 집합\n다음은 예시이다. Building Parsing Table X -\u003e a 에 대해서 parsing table에 넣는 방법이다.\nfor t in First (a), add X -\u003e a to the parsing table in Tap [X, t] if 𝜺 is in First (a), for t in Follow (x), add X -\u003e a to Tap [X, t] Construction Fail X -\u003e a1 | … | an 을 생각해 보자\nFirst (ai)들이 disjoint 하지 않을 경우 table의 하나의 slot에 여러 rule이 들어가게 된다. 즉 해당 parsing table을 만들 수 없고 CFG가 LL(1) Grammar가 아니라는 의미이다.\n","wordCount":"780","inLanguage":"en","datePublished":"2024-01-10T17:47:45+09:00","dateModified":"2024-01-10T17:47:45+09:00","author":{"@type":"Person","name":"Kim-Minjoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://246p.github.io/blog/3_1/"},"publisher":{"@type":"Organization","name":"Junlog","logo":{"@type":"ImageObject","url":"https://246p.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://246p.github.io/ accesskey=h title="HOME (Alt + H)"><img src=https://246p.github.io/apple-touch-icon.png alt aria-label=logo height=35>HOME</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://246p.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://246p.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://246p.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://246p.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1Di1J0LxHNuXNiDbwFhOh2XMLAgUJtYlh/view?usp=drive_link" title=CV><span>CV</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://246p.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://246p.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">3. Syntax analysis (1)</h1><div class=post-meta><span title='2024-01-10 17:47:45 +0900 KST'>January 10, 2024</span>&nbsp;·&nbsp;Kim-Minjoon</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#context-free-grammar>Context-free grammar</a><ul><li><a href=#derivation>Derivation</a></li><li><a href=#terminal-symbol-vs-non-terminal-symbol>Terminal Symbol vs Non-Terminal Symbol</a></li><li><a href=#cfg--sentence-and-language>CFG : Sentence and Language</a></li><li><a href=#leftmost-derivation>Leftmost Derivation</a></li><li><a href=#parse-tree>Parse tree</a></li><li><a href=#regex-vs-cfg>RegEx vs CFG</a></li><li><a href=#ambiguous-grammar>Ambiguous Grammar</a></li><li><a href=#general-rewriting-algorithm>General Rewriting Algorithm?</a></li></ul></li><li><a href=#top-down-parsing>Top-down parsing</a><ul><li><a href=#top-down-parsing-1>Top-down parsing</a></li></ul></li><li><a href=#ll1-grammar>LL(1) Grammar</a><ul><li><a href=#left-recursion>Left-Recursion</a></li><li><a href=#eliminating-left-recursion>Eliminating Left-Recursion</a></li><li><a href=#ll1-parsing-example>LL(1) Parsing Example</a></li><li><a href=#parsing-table>Parsing Table</a></li><li><a href=#first-and-follow>First and Follow</a></li><li><a href=#building-parsing-table>Building Parsing Table</a></li><li><a href=#construction-fail>Construction Fail</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=context-free-grammar>Context-free grammar<a hidden class=anchor aria-hidden=true href=#context-free-grammar>#</a></h2><p>CFG : defined with a set of production rules
ex)
E -> E + E
E -> E * E
E -> id
E -> num</p><h3 id=derivation>Derivation<a hidden class=anchor aria-hidden=true href=#derivation>#</a></h3><p>ex) E ⇒ E + E ⇒ id + E ⇒ id + num
we will use ⇒* to denote arbitrary number of rewriting steps</p><h3 id=terminal-symbol-vs-non-terminal-symbol>Terminal Symbol vs Non-Terminal Symbol<a hidden class=anchor aria-hidden=true href=#terminal-symbol-vs-non-terminal-symbol>#</a></h3><p>Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num)
Non-Terminal Symbol : can be rewritten (E)</p><h3 id=cfg--sentence-and-language>CFG : Sentence and Language<a hidden class=anchor aria-hidden=true href=#cfg--sentence-and-language>#</a></h3><p>Sentence : Result of derivation that does not contain nay non-terminal</p><p>Language : set of all derivable sentences</p><blockquote><p>𝑳(𝑮) = {𝒘 | 𝑺⇒ ∗𝒘, 𝒘 consists of terminals}</p></blockquote><h3 id=leftmost-derivation>Leftmost Derivation<a hidden class=anchor aria-hidden=true href=#leftmost-derivation>#</a></h3><p>derivation을 할때 가장 왼쪽의 non-terminal을 먼저 변환하는 규칙</p><h3 id=parse-tree>Parse tree<a hidden class=anchor aria-hidden=true href=#parse-tree>#</a></h3><p>Derivation process중 Parse tree를 만들 수 있음</p><blockquote><p>ex) E ⇒ E + E ⇒ id + E ⇒ id + num</p></blockquote><p><img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_1.Parse.png?raw=true" alt=Parse></p><h3 id=regex-vs-cfg>RegEx vs CFG<a hidden class=anchor aria-hidden=true href=#regex-vs-cfg>#</a></h3><ul><li>R = ((id | num) (&rsquo; + &rsquo; | &rsquo; * &lsquo;))* (id | num) 와 같이 RegEx로 할 수 있다.</li><li>하지만 brackets : &ldquo;{}&rdquo;, &ldquo;{{}}&rdquo;, {{{}}}",&mldr; 과 같이 RegEx로 표현 불가능한 것이 존재 한다.</li><li>또한 RegEx는 Parse Tree를 생성할 수 없다.</li></ul><h3 id=ambiguous-grammar>Ambiguous Grammar<a hidden class=anchor aria-hidden=true href=#ambiguous-grammar>#</a></h3><p>derivations 방법에 따라서 서도 다른 parse tree가 만들어진다.</p><p><img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_1.Amb_1.png?raw=true" alt=Amb_1></p><p><img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_1.Amb_2.png?raw=true" alt=Amb_2></p><p>이와 같은 경우를 막기 위하여 세가지 요소를 고려해야한다.</p><ol><li>Eliminate ambiguity</li><li>(Precedence) Bind * before +</li></ol><ul><li>id + id * id must be interpreted as id + (id * id)</li></ul><ol start=3><li>(Associativity) * and + associate to the left</li></ol><ul><li>id + id + id must be interpreted as (id + id) + id</li></ul><p>다음과 같이 CFG를 정의하면 가능하다.</p><blockquote><p>Start variable is E</p><p>E -> E + T | T</p><p>T -> T * F | F</p><p>F -> id | num</p></blockquote><h3 id=general-rewriting-algorithm>General Rewriting Algorithm?<a hidden class=anchor aria-hidden=true href=#general-rewriting-algorithm>#</a></h3><p>ambiguous -> unambiguous로 rewrite하는 algorithm은 없다.</p><p>심지어 ambiguous 한지 판단하는 algorithm 또한 없다.</p><ul><li>Undecidable problem
하지만 우리는 unambiguous 하다는 가정하에 진행한다.</li></ul><h2 id=top-down-parsing>Top-down parsing<a hidden class=anchor aria-hidden=true href=#top-down-parsing>#</a></h2><p>Parser는 derivation을 추론해야함 (if exist)</p><ul><li>Parsing is the process of inferring derivation for the token stream</li><li>construction of parse tree</li></ul><h3 id=top-down-parsing-1>Top-down parsing<a hidden class=anchor aria-hidden=true href=#top-down-parsing-1>#</a></h3><ul><li>leftmost derivations</li><li>root node에서 아래 방향으로 늘려야함</li></ul><p>At each step, we must rewrite the left most non-terminal</p><ul><li>이때 어떠한 production rule을 사용할지 골라야 한다.</li></ul><p>parsing table : case에 따라 어떤 rule을 사용할지 알려줌</p><ul><li>current status + next token을 통해 고를 수 있음</li><li>table drivven LL(1) parsing or LL(1) parsing<ul><li><strong>L</strong>eft-to-right, <strong>L</strong>eftmost derivation, <strong>1</strong> token lookahead</li></ul></li></ul><h2 id=ll1-grammar>LL(1) Grammar<a hidden class=anchor aria-hidden=true href=#ll1-grammar>#</a></h2><ul><li>LL(1) Grammar 란 LL(1) parsing이 적용 되는 CFG를 의미한다.</li><li>모든 CFG에 대해서 적용할 수 는 없다.</li><li>즉 어떤 grammar들은 parsing table을 만들 수 없음</li></ul><p>다음 CFG는 LL(1)이 아님
E -> E + T | T
T -> T * F | F
F -> id | num</p><h3 id=left-recursion>Left-Recursion<a hidden class=anchor aria-hidden=true href=#left-recursion>#</a></h3><ul><li><p>CFG has a variable A that appear as the fist symbol in right-hand side of a rule</p></li><li><p>위 예시에서 E, T는 left-recursive 이다.</p></li><li><p>CFG가 left-recursive이면 LL(1)이 될 수 없다.</p></li></ul><h3 id=eliminating-left-recursion>Eliminating Left-Recursion<a hidden class=anchor aria-hidden=true href=#eliminating-left-recursion>#</a></h3><blockquote><p>𝑨 → 𝑨𝜶 | 𝜷</p></blockquote><p>위와 같은 rule을 다음과 rewrite할 수 있다.</p><blockquote><p>𝑨 → 𝜷𝑨′</p><p>𝑨′ → 𝜶𝑨′ | 𝝐
이를 우리의 production rule에 적용해 보자.</p></blockquote><p><img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_1.Left.png?raw=true" alt=Left></p><p>Left- Recursion 이 아니더라도 꼭 LL(1) Grammer는 아니다. 다행히 운이 좋게도 우리의 CFG는 LL(1) Grammar이다.</p><h3 id=ll1-parsing-example>LL(1) Parsing Example<a hidden class=anchor aria-hidden=true href=#ll1-parsing-example>#</a></h3><p>num + id 에 대해서 LL(1) parsing을 적용해보자</p><table><thead><tr><th style=text-align:right>Stack</th><th style=text-align:right>Input Tokens</th><th style=text-align:right>Rule</th></tr></thead><tbody><tr><td style=text-align:right>E $</td><td style=text-align:right>num + id $</td><td style=text-align:right></td></tr><tr><td style=text-align:right>T E&rsquo; $</td><td style=text-align:right>num + id $</td><td style=text-align:right>E -> T E&rsquo;</td></tr><tr><td style=text-align:right>F T&rsquo; E&rsquo; $</td><td style=text-align:right>num + id $</td><td style=text-align:right>T -> F T'</td></tr><tr><td style=text-align:right>num T&rsquo; E&rsquo; $</td><td style=text-align:right>num + id $</td><td style=text-align:right>F -> num</td></tr><tr><td style=text-align:right>T&rsquo; E&rsquo; $</td><td style=text-align:right>+ id $</td><td style=text-align:right>Match and Pop</td></tr><tr><td style=text-align:right>E&rsquo; $</td><td style=text-align:right>+ id $</td><td style=text-align:right>T&rsquo; -> 𝜺</td></tr><tr><td style=text-align:right>+ T E&rsquo; $</td><td style=text-align:right>+ id $</td><td style=text-align:right>E&rsquo; -> + T E;</td></tr><tr><td style=text-align:right>T E&rsquo; $</td><td style=text-align:right>id $</td><td style=text-align:right>Match and Pop</td></tr><tr><td style=text-align:right>F T&rsquo; E&rsquo; $</td><td style=text-align:right>id $</td><td style=text-align:right>T -> F T'</td></tr><tr><td style=text-align:right>id T&rsquo; E&rsquo; $</td><td style=text-align:right>id $</td><td style=text-align:right>F -> id</td></tr><tr><td style=text-align:right>T&rsquo; E&rsquo; $</td><td style=text-align:right>$</td><td style=text-align:right>Match and Pop</td></tr><tr><td style=text-align:right>E&rsquo; $</td><td style=text-align:right>$</td><td style=text-align:right>T&rsquo; -> 𝜺</td></tr><tr><td style=text-align:right>$</td><td style=text-align:right>$</td><td style=text-align:right>E&rsquo; -> 𝜺</td></tr></tbody></table><h3 id=parsing-table>Parsing Table<a hidden class=anchor aria-hidden=true href=#parsing-table>#</a></h3><p>Parsing 을 수행하다보면 Parsing table의 필요성을 느끼게 된다.</p><p>Row : non-terminal on stack top</p><p>Column : first terminal (token) in buffer</p><p><img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_1.Parsing_table_1.png?raw=true" alt=Parsing_table_1></p><h3 id=first-and-follow>First and Follow<a hidden class=anchor aria-hidden=true href=#first-and-follow>#</a></h3><p>Parsing table을 만들기 위해서는 First, Follow set을 먼저 만들어야 한다.</p><p>First(a) : a를 파생하여 나올 수 있는 문장 중 첫 문자들의 집합</p><p>Follow(X) : X를 파생하여 나온 문장 문장 이후 나올 수 있는 문자 들의 집합</p><p>다음은 예시이다.
<img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_1.FirstFollow.png?raw=true" alt=FirstFollow></p><h3 id=building-parsing-table>Building Parsing Table<a hidden class=anchor aria-hidden=true href=#building-parsing-table>#</a></h3><p>X -> a 에 대해서 parsing table에 넣는 방법이다.</p><ul><li>for t in First (a), add X -> a to the parsing table in Tap [X, t]</li><li>if 𝜺 is in First (a), for t in Follow (x), add X -> a to Tap [X, t]</li></ul><p><img loading=lazy src="https://github.com/246p/blog/blob/main/Hugo/blog/content/post/compiler/3_1.Parsing_table_2.png?raw=true" alt=Parsing_table_2></p><h3 id=construction-fail>Construction Fail<a hidden class=anchor aria-hidden=true href=#construction-fail>#</a></h3><p>X -> a1 | &mldr; | an 을 생각해 보자</p><p>First (ai)들이 disjoint 하지 않을 경우 table의 하나의 slot에 여러 rule이 들어가게 된다. 즉 해당 parsing table을 만들 수 없고 CFG가 LL(1) Grammar가 아니라는 의미이다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://246p.github.io/tags/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC/>컴파일러</a></li><li><a href=https://246p.github.io/tags/parser/>Parser</a></li><li><a href=https://246p.github.io/tags/cfg/>CFG</a></li><li><a href=https://246p.github.io/tags/top-down/>Top-Down</a></li><li><a href=https://246p.github.io/tags/syntax-analysis/>Syntax analysis</a></li></ul><nav class=paginav><a class=next href=https://246p.github.io/blog/2/><span class=title>Next »</span><br><span>2. Lexical Analysis</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://246p.github.io/>Junlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>