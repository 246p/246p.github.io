<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>4. 함수 정의와 호출 | Junlog</title>
<meta name=keywords content="PL,자유변수,유효범위"><meta name=description content="4. 함수 정의와 호출 앞에서 선언한 언어를 확장하여 함수를 정의한다.
4.1 문법구조 프로그램에서 함수를 사용하려면 함수 생성(선언)과 호출을 지원해야한다.
E -> n | E1 + E2 | E1 - E2 | E1 * E2 | E1 / E2 | x | let x = E1 in E2 | if E1 then E2 else E3 | iszero E | fun x E 함수 생성식 | E1 E2 함수 호출식 fun x E x를 인자로 받아서 E의 계산 결과를 반환하는 함수를 정의하는 구문이다."><meta name=author content="Kim-Minjoon"><link rel=canonical href=https://246p.github.io/blog/pl_4/><meta name=google-site-verification content="GTM-524D7HPF"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="4. 함수 정의와 호출"><meta property="og:description" content="4. 함수 정의와 호출 앞에서 선언한 언어를 확장하여 함수를 정의한다.
4.1 문법구조 프로그램에서 함수를 사용하려면 함수 생성(선언)과 호출을 지원해야한다.
E -> n | E1 + E2 | E1 - E2 | E1 * E2 | E1 / E2 | x | let x = E1 in E2 | if E1 then E2 else E3 | iszero E | fun x E 함수 생성식 | E1 E2 함수 호출식 fun x E x를 인자로 받아서 E의 계산 결과를 반환하는 함수를 정의하는 구문이다."><meta property="og:type" content="article"><meta property="og:url" content="https://246p.github.io/blog/pl_4/"><meta property="og:image" content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-01-24T13:38:09+09:00"><meta property="article:modified_time" content="2024-01-24T13:38:09+09:00"><meta property="og:site_name" content="Junlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta name=twitter:title content="4. 함수 정의와 호출"><meta name=twitter:description content="4. 함수 정의와 호출 앞에서 선언한 언어를 확장하여 함수를 정의한다.
4.1 문법구조 프로그램에서 함수를 사용하려면 함수 생성(선언)과 호출을 지원해야한다.
E -> n | E1 + E2 | E1 - E2 | E1 * E2 | E1 / E2 | x | let x = E1 in E2 | if E1 then E2 else E3 | iszero E | fun x E 함수 생성식 | E1 E2 함수 호출식 fun x E x를 인자로 받아서 E의 계산 결과를 반환하는 함수를 정의하는 구문이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://246p.github.io/post/"},{"@type":"ListItem","position":2,"name":"4. 함수 정의와 호출","item":"https://246p.github.io/blog/pl_4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"4. 함수 정의와 호출","name":"4. 함수 정의와 호출","description":"4. 함수 정의와 호출 앞에서 선언한 언어를 확장하여 함수를 정의한다.\n4.1 문법구조 프로그램에서 함수를 사용하려면 함수 생성(선언)과 호출을 지원해야한다.\nE -\u0026gt; n | E1 + E2 | E1 - E2 | E1 * E2 | E1 / E2 | x | let x = E1 in E2 | if E1 then E2 else E3 | iszero E | fun x E 함수 생성식 | E1 E2 함수 호출식 fun x E x를 인자로 받아서 E의 계산 결과를 반환하는 함수를 정의하는 구문이다.","keywords":["PL","자유변수","유효범위"],"articleBody":"4. 함수 정의와 호출 앞에서 선언한 언어를 확장하여 함수를 정의한다.\n4.1 문법구조 프로그램에서 함수를 사용하려면 함수 생성(선언)과 호출을 지원해야한다.\nE -\u003e n | E1 + E2 | E1 - E2 | E1 * E2 | E1 / E2 | x | let x = E1 in E2 | if E1 then E2 else E3 | iszero E | fun x E 함수 생성식 | E1 E2 함수 호출식 fun x E x를 인자로 받아서 E의 계산 결과를 반환하는 함수를 정의하는 구문이다.\nx를 형식인자, E를 몸통식 이라고 한다.\nex) fun x (x+1) : 인자 x를 받아서 x+1을 반환하는 함수\nE1 E2 E1은 호출할 함수를 계산하는 식이고 E2는 함수의 인자를 계산하는 식이다. E2의 값을 실제인자라고 부른다.\nex) let f = fun x (x+1) in (f 2)\n함수 fun x (x+1)을 f라고 정의하고 실제인자 2를 이용하여 호출하는 식이다.\n동치관계 우리는 다음과 같은 동치관계를 발견할 수 있다.\nlet x = E1 in E2 ≡ (fun x E2) E1\n4.2 의미구조 함수의 생성과 호출에서 실행 의미를 정의해보자 이에 앞서 자유변수에 대하여 정의할 필요가 있따.\n4.2.0 자유변수 함수의 의미를 정의하기우ㅏㅎ여 변수들을 자유변수와 묶인변수로 구분해야한다.\n자유변수란 주어진 식에서 그 정의를 찾을 수 없는 변수를 말한다.\n묶인변수란 주어진 식에서 정의를 찾을 수 있는 변수를 의미한다.\n또한 식E에 등장하는 자유변수의 집합 FV(E)는 다음과 같이 귀납적으로 정의된다.\n묶인변수는 VAR(E)\\FV(E)가 된다.\nFV(n) = ∅ FV(x) = {x} FV(E1 + E2) = FV (E1) ∪ FV(E2) FV(let x = E1 in E2) = FV(E1) ∪ (FV(E2) \\ {x}) FV(if E1 then E2 else E3) = FV(E1) ∪ FV(E2) ∪ FV(E3) FV(fun x E) = FV(E) \\ {x} FV(E1 E2) = FV(E1) ∪ FV(E2) 4.2.1 유효범위 먼저 다음 함수에 대해서 생각해보자\nlet x = 1 in let f = fun y (x+y) in let x = 2 in let g = fun y (x+y) in (f 1) + (g 1) 함수에서 등장하는 자유변수의 값을 결정할때 다음 두가지 방법을 생각해볼 수 있다\n함수가 정의되는 시점 (정적 유효범위) f가 정의되는 시점에서 x=1, g가 정의되는 시점에서 x=2이므로 다음과 같이 계산된다.\nf 1 = 2, g 1 = 3\n함수가 호출되는 시점 (동적 유효범위) f, g가 호출되는 시점에서 x=2이므로 다음과 같이 계산된다.\nf 1 = 3, g 1 = 3\n대부분의 프로그래밍 언어는 정적 유효범위를 지원한다. 변수의 유효범위가 프로그래밍 실행전에 정적으로 결정되어 프로그램을 이해하기 쉬워지기 때문이다.\n4.2.2 정적 유효범위 정적 유효범위를 지원하도록 함수의 의미를 정의해보자. 먼저 함수를 값으로 사용할 수 있도록 하기위하여 다음과 같이 의미공간을 확장한다.\nVal = Z + Bool + Procedure Procedure = Var × Exp × Env Env = Var → Val 함수 생성식의 실행 의미는 다음과 같이 정의할 수 있다.\n------------------------ ρ ⊢ fun x E ⇒ (x, E, ρ) 즉 환경 ρ에서 식 fun x E를 계산하면 함수값 (x,E,ρ)가 생성된다.\n함수 호출식은 다음과 같다.\nρ ⊢ E1 ⇒ (x, E, ρ′) ρ ⊢ E2 ⇒ v {x |→ v}ρ′ ⊢ E ⇒ v′ --------------------------------------------------------- ρ ⊢ E1 E2 ⇒ v′ 4.2.3 동적 유효범위 동적 유효범위를 지원하기위해 다음과같이 함수호출식의 의미를 변경하면 된다.\nρ ⊢ E1 ⇒ (x, E, ρ′) ρ ⊢ E2 ⇒ v {x |→ v}ρ ⊢ E ⇒ v′ --------------------------------------------------------- ρ ⊢ E1 E2 ⇒ v′ 함수 몸통부를 계산할때 ρ′ 대신 ρ를 사용한다 즉 위에서 정의한 의미공간의 Env를 제외하여 Procedure = Var × Exp과 같이 다시 정의할 수 있다.\n이를 다시 정의하여 나타내면 다음과 같다.\n--------------------- ρ ⊢ fun x E ⇒ (x, E) ρ ⊢ E1 ⇒ (x, E) ρ ⊢ E2 ⇒ v {x |→ v}ρ ⊢ E ⇒ v′ ------------------------------------------------------ ρ ⊢ E1 E2 ⇒ v′ 4.2.4 재귀함수 정적 유효범위 재귀함수 정적 유효범위를 지원하는 의미구조 하에서 다음과 같은 프로그램을 생각해보자.\nlet f = fun x (f x) in (f 1) 위 식을 실행하면 다음과 같은 환경이 만들어진다.\n{f |→ (x, (f x), ∅)} 이 환경에서 f 1을 실행한다면 몸통 식 f x를 계산할때 f에 대한 정보가 없으로 실행이 불가능하다. 즉 문법구조를 확장하여 재귀함수를 지원하도록 해야한다.\nE -\u003e ... | let rec f(x) = E1 in E2 또한 의미구조 정의를 위하여 다음과 같이 의미공간을 확장한다.\nVal = Z + Bool + Procedure + RecProcedure Procedure = Var × Exp × Env RecProcedure = Var × Var × Exp × Env Env = Var → Val 즉 재귀함수는 일반함수와 다르게 함수 이름을 기억한다. 재귀함수 생성식의 의미는 다음과 같다.\n{f |→ (f, x, E1, ρ)}ρ ⊢ E2 ⇒ v ------------------------------- ρ ⊢ letrec f(x) = E1 in E2 ⇒ v ρ ⊢ E1 ⇒ (f, x, E, ρ′) ρ ⊢ E2 ⇒ v {x |→ v, f |→ (f, x, E,ρ′)}ρ′ ⊢ E ⇒ v′ ------------------------------------------------------------------------------- ρ ⊢ E1 E2 ⇒ v 비재귀 함수의 호출과 다르게 함수를 호출할때 함수가 정의된 시점의 환경과 호출되는 함수를 함께 확장한다.\n동적 유효범위 재귀함수 동적 유효범위에서는 다른 확장 없이 재귀함수가 잘 정의된다.\n왜냐하면 함수의 몸통을 함수의 호출이 일어날때 환경에서 계산한느데 그때 환경에 이미 함수 f에 대한 정보가 존재하기 때문이다.\n","wordCount":"783","inLanguage":"en","datePublished":"2024-01-24T13:38:09+09:00","dateModified":"2024-01-24T13:38:09+09:00","author":{"@type":"Person","name":"Kim-Minjoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://246p.github.io/blog/pl_4/"},"publisher":{"@type":"Organization","name":"Junlog","logo":{"@type":"ImageObject","url":"https://246p.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://246p.github.io/ accesskey=h title="HOME (Alt + H)"><img src=https://246p.github.io/apple-touch-icon.png alt aria-label=logo height=35>HOME</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://246p.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://246p.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://246p.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://246p.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1Di1J0LxHNuXNiDbwFhOh2XMLAgUJtYlh/view?usp=drive_link" title=CV><span>CV</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://246p.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://246p.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">4. 함수 정의와 호출</h1><div class=post-meta><span title='2024-01-24 13:38:09 +0900 KST'>January 24, 2024</span>&nbsp;·&nbsp;Kim-Minjoon</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#41-문법구조>4.1 문법구조</a><ul><li><a href=#fun-x-e>fun x E</a></li><li><a href=#e1-e2>E1 E2</a></li><li><a href=#동치관계>동치관계</a></li></ul></li><li><a href=#42-의미구조>4.2 의미구조</a><ul><li><a href=#420-자유변수>4.2.0 자유변수</a></li><li><a href=#421-유효범위>4.2.1 유효범위</a></li><li><a href=#422-정적-유효범위>4.2.2 정적 유효범위</a></li><li><a href=#423-동적-유효범위>4.2.3 동적 유효범위</a></li><li><a href=#424-재귀함수>4.2.4 재귀함수</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=4-함수-정의와-호출>4. 함수 정의와 호출<a hidden class=anchor aria-hidden=true href=#4-함수-정의와-호출>#</a></h1><p>앞에서 선언한 언어를 확장하여 함수를 정의한다.</p><h2 id=41-문법구조>4.1 문법구조<a hidden class=anchor aria-hidden=true href=#41-문법구조>#</a></h2><p>프로그램에서 함수를 사용하려면 함수 생성(선언)과 호출을 지원해야한다.</p><pre><code> E -&gt; n
    | E1 + E2
    | E1 - E2 
    | E1 * E2
    | E1 / E2
    | x                       
    | let x = E1 in E2        
    | if E1 then E2 else E3   
    | iszero E         
    | fun x E               함수 생성식
    | E1 E2                 함수 호출식
</code></pre><h3 id=fun-x-e>fun x E<a hidden class=anchor aria-hidden=true href=#fun-x-e>#</a></h3><p>x를 인자로 받아서 E의 계산 결과를 반환하는 함수를 정의하는 구문이다.</p><p>x를 형식인자, E를 몸통식 이라고 한다.</p><p>ex) fun x (x+1) : 인자 x를 받아서 x+1을 반환하는 함수</p><h3 id=e1-e2>E1 E2<a hidden class=anchor aria-hidden=true href=#e1-e2>#</a></h3><p>E1은 호출할 함수를 계산하는 식이고 E2는 함수의 인자를 계산하는 식이다. E2의 값을 실제인자라고 부른다.</p><p>ex) let f = fun x (x+1) in (f 2)</p><p>함수 fun x (x+1)을 f라고 정의하고 실제인자 2를 이용하여 호출하는 식이다.</p><h3 id=동치관계>동치관계<a hidden class=anchor aria-hidden=true href=#동치관계>#</a></h3><p>우리는 다음과 같은 동치관계를 발견할 수 있다.</p><blockquote><p>let x = E1 in E2 ≡ (fun x E2) E1</p></blockquote><h2 id=42-의미구조>4.2 의미구조<a hidden class=anchor aria-hidden=true href=#42-의미구조>#</a></h2><p>함수의 생성과 호출에서 실행 의미를 정의해보자
이에 앞서 자유변수에 대하여 정의할 필요가 있따.</p><h3 id=420-자유변수>4.2.0 자유변수<a hidden class=anchor aria-hidden=true href=#420-자유변수>#</a></h3><p>함수의 의미를 정의하기우ㅏㅎ여 변수들을 자유변수와 묶인변수로 구분해야한다.</p><p>자유변수란 주어진 식에서 그 정의를 찾을 수 없는 변수를 말한다.</p><p>묶인변수란 주어진 식에서 정의를 찾을 수 있는 변수를 의미한다.</p><p>또한 식E에 등장하는 자유변수의 집합 FV(E)는 다음과 같이 귀납적으로 정의된다.</p><p>묶인변수는 VAR(E)\FV(E)가 된다.</p><pre><code>FV(n) = ∅
FV(x) = {x}
FV(E1 + E2) = FV (E1) ∪ FV(E2)
FV(let x = E1 in E2) = FV(E1) ∪ (FV(E2) \ {x})
FV(if E1 then E2 else E3) = FV(E1) ∪ FV(E2) ∪ FV(E3)
FV(fun x E) = FV(E) \ {x}
FV(E1 E2) = FV(E1) ∪ FV(E2)
</code></pre><h3 id=421-유효범위>4.2.1 유효범위<a hidden class=anchor aria-hidden=true href=#421-유효범위>#</a></h3><p>먼저 다음 함수에 대해서 생각해보자</p><pre><code>let x = 1
in let f = fun y (x+y)
    in let x = 2
        in let g = fun y (x+y)
            in (f 1) + (g 1)
</code></pre><p>함수에서 등장하는 자유변수의 값을 결정할때 다음 두가지 방법을 생각해볼 수 있다</p><ol><li>함수가 정의되는 시점 (정적 유효범위)</li></ol><p>f가 정의되는 시점에서 x=1, g가 정의되는 시점에서 x=2이므로 다음과 같이 계산된다.</p><blockquote><p>f 1 = 2, g 1 = 3</p></blockquote><ol start=2><li>함수가 호출되는 시점 (동적 유효범위)</li></ol><p>f, g가 호출되는 시점에서 x=2이므로 다음과 같이 계산된다.</p><blockquote><p>f 1 = 3, g 1 = 3</p></blockquote><p>대부분의 프로그래밍 언어는 정적 유효범위를 지원한다. 변수의 유효범위가 프로그래밍 실행전에 정적으로 결정되어 프로그램을 이해하기 쉬워지기 때문이다.</p><h3 id=422-정적-유효범위>4.2.2 정적 유효범위<a hidden class=anchor aria-hidden=true href=#422-정적-유효범위>#</a></h3><p>정적 유효범위를 지원하도록 함수의 의미를 정의해보자. 먼저 함수를 값으로 사용할 수 있도록 하기위하여 다음과 같이 의미공간을 확장한다.</p><pre><code>Val = Z + Bool + Procedure
Procedure = Var × Exp × Env
Env = Var → Val
</code></pre><p>함수 생성식의 실행 의미는 다음과 같이 정의할 수 있다.</p><pre><code>------------------------
ρ ⊢ fun x E ⇒ (x, E, ρ)
</code></pre><p>즉 환경 ρ에서 식 fun x E를 계산하면 함수값 (x,E,ρ)가 생성된다.</p><p>함수 호출식은 다음과 같다.</p><pre><code>ρ ⊢ E1 ⇒ (x, E, ρ′)   ρ ⊢ E2 ⇒ v   {x |→ v}ρ′ ⊢ E ⇒ v′
---------------------------------------------------------
                      ρ ⊢ E1 E2 ⇒ v′
</code></pre><h3 id=423-동적-유효범위>4.2.3 동적 유효범위<a hidden class=anchor aria-hidden=true href=#423-동적-유효범위>#</a></h3><p>동적 유효범위를 지원하기위해 다음과같이 함수호출식의 의미를 변경하면 된다.</p><pre><code>ρ ⊢ E1 ⇒ (x, E, ρ′)   ρ ⊢ E2 ⇒ v   {x |→ v}ρ ⊢ E ⇒ v′
---------------------------------------------------------
                      ρ ⊢ E1 E2 ⇒ v′
</code></pre><p>함수 몸통부를 계산할때 ρ′ 대신 ρ를 사용한다 즉 위에서 정의한 의미공간의 Env를 제외하여 Procedure = Var × Exp과 같이 다시 정의할 수 있다.</p><p>이를 다시 정의하여 나타내면 다음과 같다.</p><pre><code>---------------------
ρ ⊢ fun x E ⇒ (x, E)

ρ ⊢ E1 ⇒ (x, E)    ρ ⊢ E2 ⇒ v    {x |→ v}ρ ⊢ E ⇒ v′
------------------------------------------------------
                   ρ ⊢ E1 E2 ⇒ v′
</code></pre><h3 id=424-재귀함수>4.2.4 재귀함수<a hidden class=anchor aria-hidden=true href=#424-재귀함수>#</a></h3><h4 id=정적-유효범위-재귀함수>정적 유효범위 재귀함수<a hidden class=anchor aria-hidden=true href=#정적-유효범위-재귀함수>#</a></h4><p>정적 유효범위를 지원하는 의미구조 하에서 다음과 같은 프로그램을 생각해보자.</p><pre><code>let f = fun x (f x) in (f 1)
</code></pre><p>위 식을 실행하면 다음과 같은 환경이 만들어진다.</p><pre><code>{f |→ (x, (f x), ∅)}
</code></pre><p>이 환경에서 f 1을 실행한다면 몸통 식 f x를 계산할때 f에 대한 정보가 없으로 실행이 불가능하다. 즉 문법구조를 확장하여 재귀함수를 지원하도록 해야한다.</p><pre><code>E -&gt; ...
    | let rec f(x) = E1 in E2
</code></pre><p>또한 의미구조 정의를 위하여 다음과 같이 의미공간을 확장한다.</p><pre><code>Val = Z + Bool + Procedure + RecProcedure
Procedure = Var × Exp × Env
RecProcedure = Var × Var × Exp × Env
Env = Var → Val
</code></pre><p>즉 재귀함수는 일반함수와 다르게 함수 이름을 기억한다. 재귀함수 생성식의 의미는 다음과 같다.</p><pre><code>{f |→ (f, x, E1, ρ)}ρ ⊢ E2 ⇒ v
-------------------------------
ρ ⊢ letrec f(x) = E1 in E2 ⇒ v

ρ ⊢ E1 ⇒ (f, x, E, ρ′)   ρ ⊢ E2 ⇒ v   {x |→ v, f |→ (f, x, E,ρ′)}ρ′ ⊢ E ⇒ v′
-------------------------------------------------------------------------------
                                ρ ⊢ E1 E2 ⇒ v
</code></pre><p>비재귀 함수의 호출과 다르게 함수를 호출할때 함수가 정의된 시점의 환경과 호출되는 함수를 함께 확장한다.</p><h4 id=동적-유효범위-재귀함수>동적 유효범위 재귀함수<a hidden class=anchor aria-hidden=true href=#동적-유효범위-재귀함수>#</a></h4><p>동적 유효범위에서는 다른 확장 없이 재귀함수가 잘 정의된다.</p><p>왜냐하면 함수의 몸통을 함수의 호출이 일어날때 환경에서 계산한느데 그때 환경에 이미 함수 f에 대한 정보가 존재하기 때문이다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://246p.github.io/tags/pl/>PL</a></li><li><a href=https://246p.github.io/tags/%EC%9E%90%EC%9C%A0%EB%B3%80%EC%88%98/>자유변수</a></li><li><a href=https://246p.github.io/tags/%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84/>유효범위</a></li></ul><nav class=paginav><a class=next href=https://246p.github.io/blog/pl_3/><span class=title>Next »</span><br><span>3. 변수와 환경</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://246p.github.io/>Junlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>