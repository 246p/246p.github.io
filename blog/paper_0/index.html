<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>0. 읽을 논문 | Junlog</title>
<meta name=keywords content="2024,학부연구생,논문"><meta name=description content="Abstract 요약 Penetrating conditionals REDQUEEN: Fuzzing with Input-to-State Correspondence Link
최근 몇년간 fuzz 기반 automated software testing이 대두되고 있다. 특히 feedback-driven fuzz testing은 magic byte와 checksum은의 문제가 있다.
비용이많이드는 taint tracking 과 symbolic execution이 있다. 하지만 이러한 방법은 source code에 대한 접근, environment (OS나 library function call)에 대한 엄밀한 정보가 필요하다.
이 논문에서 taint tracking과 symbolic execution에 비해 가벼우면서 효과적인 대안을 소개한다. 이 방법은 large binary application과 알려지지 않은 environment에 쉽게 확장 가능하다."><meta name=author content="Kim-Minjoon"><link rel=canonical href=https://246p.github.io/blog/paper_0/><meta name=google-site-verification content="GTM-524D7HPF"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="0. 읽을 논문"><meta property="og:description" content="Abstract 요약 Penetrating conditionals REDQUEEN: Fuzzing with Input-to-State Correspondence Link
최근 몇년간 fuzz 기반 automated software testing이 대두되고 있다. 특히 feedback-driven fuzz testing은 magic byte와 checksum은의 문제가 있다.
비용이많이드는 taint tracking 과 symbolic execution이 있다. 하지만 이러한 방법은 source code에 대한 접근, environment (OS나 library function call)에 대한 엄밀한 정보가 필요하다.
이 논문에서 taint tracking과 symbolic execution에 비해 가벼우면서 효과적인 대안을 소개한다. 이 방법은 large binary application과 알려지지 않은 environment에 쉽게 확장 가능하다."><meta property="og:type" content="article"><meta property="og:url" content="https://246p.github.io/blog/paper_0/"><meta property="og:image" content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-02-01T10:13:41+09:00"><meta property="article:modified_time" content="2024-02-01T10:13:41+09:00"><meta property="og:site_name" content="Junlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta name=twitter:title content="0. 읽을 논문"><meta name=twitter:description content="Abstract 요약 Penetrating conditionals REDQUEEN: Fuzzing with Input-to-State Correspondence Link
최근 몇년간 fuzz 기반 automated software testing이 대두되고 있다. 특히 feedback-driven fuzz testing은 magic byte와 checksum은의 문제가 있다.
비용이많이드는 taint tracking 과 symbolic execution이 있다. 하지만 이러한 방법은 source code에 대한 접근, environment (OS나 library function call)에 대한 엄밀한 정보가 필요하다.
이 논문에서 taint tracking과 symbolic execution에 비해 가벼우면서 효과적인 대안을 소개한다. 이 방법은 large binary application과 알려지지 않은 environment에 쉽게 확장 가능하다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://246p.github.io/post/"},{"@type":"ListItem","position":2,"name":"0. 읽을 논문","item":"https://246p.github.io/blog/paper_0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"0. 읽을 논문","name":"0. 읽을 논문","description":"Abstract 요약 Penetrating conditionals REDQUEEN: Fuzzing with Input-to-State Correspondence Link\n최근 몇년간 fuzz 기반 automated software testing이 대두되고 있다. 특히 feedback-driven fuzz testing은 magic byte와 checksum은의 문제가 있다.\n비용이많이드는 taint tracking 과 symbolic execution이 있다. 하지만 이러한 방법은 source code에 대한 접근, environment (OS나 library function call)에 대한 엄밀한 정보가 필요하다.\n이 논문에서 taint tracking과 symbolic execution에 비해 가벼우면서 효과적인 대안을 소개한다. 이 방법은 large binary application과 알려지지 않은 environment에 쉽게 확장 가능하다.","keywords":["2024","학부연구생","논문"],"articleBody":"Abstract 요약 Penetrating conditionals REDQUEEN: Fuzzing with Input-to-State Correspondence Link\n최근 몇년간 fuzz 기반 automated software testing이 대두되고 있다. 특히 feedback-driven fuzz testing은 magic byte와 checksum은의 문제가 있다.\n비용이많이드는 taint tracking 과 symbolic execution이 있다. 하지만 이러한 방법은 source code에 대한 접근, environment (OS나 library function call)에 대한 엄밀한 정보가 필요하다.\n이 논문에서 taint tracking과 symbolic execution에 비해 가벼우면서 효과적인 대안을 소개한다. 이 방법은 large binary application과 알려지지 않은 environment에 쉽게 확장 가능하다.\n우리는 input의 일부분이 직접적(거의 수정되지 않은)으로 프로그램 state에 포함되는것을 관찰한다. 이러한 input-to-state 연관성은 매우 효율적인 방법으로 두가지 문제점을 극복하는데 사용된다.\n우리는 이러한 방법으로 REDQUEEN을 만들었다. 주어진 바이너리 실행파일에 대해서 magic byte와 중첩된 checksum test를 자동으로 해결할 수 있다.\nREDQUEEN은 처음으로 LAVA-M에 심어진 버그의 100% 이상을 모든 타깃에서 찾아내었다. 또한 65개의 새로운 버그와 여러 프로그램 및 OS kernel에서 16개의 CVE를 얻었다.\nGrey-box concolic testing on Binary Code Link white-box와 grey-box fuzzing의 장점을 결합하여 새로운 path based testcase generation 방법인 grey-box concolic testing을 제시한다. 우리는 대상 프로그램의 executin path를 white-box fuzzing, 즉 concolic tesing처럼 체계적으로 탐색하는 동시해 grey-box fuzzing의 단순함을 모두 구현하였다.\n이는 경량화된 계측만을 사용하여 SMT solver를 사용하지 않는다.\nEclipser라는 fuzzer를 구현하여 최신 grey-box fuzzer(AFLFast, LAF-intel, Stellix, VUzzer), smybolic executor(KLEE)와 비교하여 다른 도구들보다 더 높은 code coverage를 달성하고 더 많은 버그를 발견하였따.\n2. Improving the efficiency (execution speed) of fuzzing Designing New Operating Primitives to Improve Fuzzing Link\nFuzzing의 반복 실행 시간을 단축하여 fuzzing의 성능을 향상시키는 방법을 다루었다.\nAFL이 120코어로 실행될때 fork() system call의 scalability로 인해 24배 느려진다는 것을 관찰하였다. 다른 fuzzer들도 비슷한 설계 패턴을 따르기 때문에 같은 scalability bottleneck이 있을것이라고 예상된다.\nfuzzing 성능 향상을 위하여 이 문제를 문제를 해결하였다.\n새로운 operating primitives specialized를 통하여 120코어를 사용하였고 Google fuzzer test suite를 대상으로 AFL : 6.1~28.9배, LibFuzzer : 1.1~735.7배 향상함을 확인하였다.\n더 일반적인 설정인 30코어를 할당한 경우에도 AFL의 처리량을 7.7배까지 향상시킨다. 이러한 fuzzer-agnostic primitives는 어떤 fuzzer에도 쉽게 적용할 수 있으며 대규모 fuzzer 및 cloud 기반 fuzzing 서비스에 직접적인 이익이 된다.\nFull-speed Fuzzing: Reducing Fuzzing Overhead through Link\ncoverage-guided fuzzing은 다음 3가지 요소를 갖는다.\ntest case generation code coverage tracking crash triage 이중 code coeverage tracking은 overhead의 주요한 원인이다. coverage-guided fuzzer는 static or dynamic binary instrumentation 또는 하드웨어 지원을 통하여 testcase의 code coverage를 추적한다.\n모든 testcase를 추적하는것은 상당한 성능 저하를 초래한다. 심지어 압도적 다수의 testcase coverage 정보가 쓸모가 없다.\ncoverage-guided fuzzer에 불필요한 추적을 제거하기 위하여 coverage-guided tracking을 소개한다. 이는 두가지 관찰에 기반한다.\n생성된 testcase중 일부만 coverage를 증가시킨다. 이러한 testcase는 시간이 지나면 덜 발생한다. coverage-guided tracking은 coverage를 증가시키는 testcase를 처리한 시간을 높이고 그렇지 않은 것을 처리하는 시간을 줄인다.\n우리는 static bainary instrumentator Dyninst에 기반한 Untracer를 만들었다.\n실험결과 Untracer의 평균 오버헤드는 1시간동안 1%미만이고 24시간 후에는 0%에 접근한다. 반면 AFL-Clang, AFL-QEMU, AFL-Dyninst로 는 36,612,518%의 오버헤드가 발생한다.\n또한 우리는 Untracer를 fuzzerQSYM과 통합하여 24시간의 fuzzing에서 QSYM-Untracer가 QSYM-Clang, QSYM-QEMU보다 79,616% 더 많은 test case를 실행하였다.\n","wordCount":"449","inLanguage":"en","datePublished":"2024-02-01T10:13:41+09:00","dateModified":"2024-02-01T10:13:41+09:00","author":{"@type":"Person","name":"Kim-Minjoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://246p.github.io/blog/paper_0/"},"publisher":{"@type":"Organization","name":"Junlog","logo":{"@type":"ImageObject","url":"https://246p.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://246p.github.io/ accesskey=h title="HOME (Alt + H)"><img src=https://246p.github.io/apple-touch-icon.png alt aria-label=logo height=35>HOME</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://246p.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://246p.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://246p.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://246p.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1Di1J0LxHNuXNiDbwFhOh2XMLAgUJtYlh/view?usp=drive_link" title=CV><span>CV</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://246p.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://246p.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">0. 읽을 논문</h1><div class=post-meta><span title='2024-02-01 10:13:41 +0900 KST'>February 1, 2024</span>&nbsp;·&nbsp;Kim-Minjoon</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#penetrating-conditionals>Penetrating conditionals</a><ul><li><a href=#redqueen-fuzzing-with-input-to-state-correspondence>REDQUEEN: Fuzzing with Input-to-State Correspondence</a></li><li><a href=#grey-box-concolic-testing-on-binary-code>Grey-box concolic testing on Binary Code</a></li></ul></li><li><a href=#2--improving-the-efficiency-execution-speed-of-fuzzing>2. Improving the efficiency (execution speed) of fuzzing</a><ul><li><a href=#designing-new-operating-primitives-to-improve-fuzzing>Designing New Operating Primitives to Improve Fuzzing</a></li><li><a href=#full-speed-fuzzing-reducing-fuzzing-overhead-through>Full-speed Fuzzing: Reducing Fuzzing Overhead through</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=abstract-요약>Abstract 요약<a hidden class=anchor aria-hidden=true href=#abstract-요약>#</a></h1><h2 id=penetrating-conditionals>Penetrating conditionals<a hidden class=anchor aria-hidden=true href=#penetrating-conditionals>#</a></h2><h3 id=redqueen-fuzzing-with-input-to-state-correspondence>REDQUEEN: Fuzzing with Input-to-State Correspondence<a hidden class=anchor aria-hidden=true href=#redqueen-fuzzing-with-input-to-state-correspondence>#</a></h3><p><a href=https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_04A-2_Aschermann_paper.pdf>Link</a></p><p>최근 몇년간 fuzz 기반 automated software testing이 대두되고 있다. 특히 feedback-driven fuzz testing은 magic byte와 checksum은의 문제가 있다.</p><p>비용이많이드는 taint tracking 과 symbolic execution이 있다. 하지만 이러한 방법은 source code에 대한 접근, environment (OS나 library function call)에 대한 엄밀한 정보가 필요하다.</p><p>이 논문에서 taint tracking과 symbolic execution에 비해 가벼우면서 효과적인 대안을 소개한다. 이 방법은 large binary application과 알려지지 않은 environment에 쉽게 확장 가능하다.</p><p>우리는 input의 일부분이 직접적(거의 수정되지 않은)으로 프로그램 state에 포함되는것을 관찰한다. 이러한 input-to-state 연관성은 매우 효율적인 방법으로 두가지 문제점을 극복하는데 사용된다.</p><p>우리는 이러한 방법으로 REDQUEEN을 만들었다. 주어진 바이너리 실행파일에 대해서 magic byte와 중첩된 checksum test를 자동으로 해결할 수 있다.</p><p>REDQUEEN은 처음으로 LAVA-M에 심어진 버그의 100% 이상을 모든 타깃에서 찾아내었다. 또한 65개의 새로운 버그와 여러 프로그램 및 OS kernel에서 16개의 CVE를 얻었다.</p><h3 id=grey-box-concolic-testing-on-binary-code>Grey-box concolic testing on Binary Code<a hidden class=anchor aria-hidden=true href=#grey-box-concolic-testing-on-binary-code>#</a></h3><p><a href=https://softsec.kaist.ac.kr/~sangkilc/papers/choi-icse2019.pdf>Link</a>
white-box와 grey-box fuzzing의 장점을 결합하여 새로운 path based testcase generation 방법인 grey-box concolic testing을 제시한다. 우리는 대상 프로그램의 executin path를 white-box fuzzing, 즉 concolic tesing처럼 체계적으로 탐색하는 동시해 grey-box fuzzing의 단순함을 모두 구현하였다.</p><p>이는 경량화된 계측만을 사용하여 SMT solver를 사용하지 않는다.</p><p>Eclipser라는 fuzzer를 구현하여 최신 grey-box fuzzer(AFLFast, LAF-intel, Stellix, VUzzer), smybolic executor(KLEE)와 비교하여 다른 도구들보다 더 높은 code coverage를 달성하고 더 많은 버그를 발견하였따.</p><h2 id=2--improving-the-efficiency-execution-speed-of-fuzzing>2. Improving the efficiency (execution speed) of fuzzing<a hidden class=anchor aria-hidden=true href=#2--improving-the-efficiency-execution-speed-of-fuzzing>#</a></h2><h3 id=designing-new-operating-primitives-to-improve-fuzzing>Designing New Operating Primitives to Improve Fuzzing<a hidden class=anchor aria-hidden=true href=#designing-new-operating-primitives-to-improve-fuzzing>#</a></h3><p><a href=https://cosmoss-jigu.github.io/pages/pubs/fuzzing-xu-ccs17.pdf>Link</a></p><p>Fuzzing의 반복 실행 시간을 단축하여 fuzzing의 성능을 향상시키는 방법을 다루었다.</p><p>AFL이 120코어로 실행될때 fork() system call의 scalability로 인해 24배 느려진다는 것을 관찰하였다. 다른 fuzzer들도 비슷한 설계 패턴을 따르기 때문에 같은 scalability bottleneck이 있을것이라고 예상된다.</p><p>fuzzing 성능 향상을 위하여 이 문제를 문제를 해결하였다.</p><p>새로운 operating primitives specialized를 통하여 120코어를 사용하였고 Google fuzzer test suite를 대상으로 AFL : 6.1~28.9배, LibFuzzer : 1.1~735.7배 향상함을 확인하였다.</p><p>더 일반적인 설정인 30코어를 할당한 경우에도 AFL의 처리량을 7.7배까지 향상시킨다. 이러한 fuzzer-agnostic primitives는 어떤 fuzzer에도 쉽게 적용할 수 있으며 대규모 fuzzer 및 cloud 기반 fuzzing 서비스에 직접적인 이익이 된다.</p><h3 id=full-speed-fuzzing-reducing-fuzzing-overhead-through>Full-speed Fuzzing: Reducing Fuzzing Overhead through<a hidden class=anchor aria-hidden=true href=#full-speed-fuzzing-reducing-fuzzing-overhead-through>#</a></h3><p><a href=https://users.cs.utah.edu/~snagy/papers/19SP.pdf>Link</a></p><p>coverage-guided fuzzing은 다음 3가지 요소를 갖는다.</p><ol><li>test case generation</li><li>code coverage tracking</li><li>crash triage</li></ol><p>이중 code coeverage tracking은 overhead의 주요한 원인이다. coverage-guided fuzzer는 static or dynamic binary instrumentation 또는 하드웨어 지원을 통하여 testcase의 code coverage를 추적한다.</p><p>모든 testcase를 추적하는것은 상당한 성능 저하를 초래한다. 심지어 압도적 다수의 testcase coverage 정보가 쓸모가 없다.</p><p>coverage-guided fuzzer에 불필요한 추적을 제거하기 위하여 coverage-guided tracking을 소개한다. 이는 두가지 관찰에 기반한다.</p><ol><li>생성된 testcase중 일부만 coverage를 증가시킨다.</li><li>이러한 testcase는 시간이 지나면 덜 발생한다.</li></ol><p>coverage-guided tracking은 coverage를 증가시키는 testcase를 처리한 시간을 높이고 그렇지 않은 것을 처리하는 시간을 줄인다.</p><p>우리는 static bainary instrumentator Dyninst에 기반한 Untracer를 만들었다.</p><p>실험결과 Untracer의 평균 오버헤드는 1시간동안 1%미만이고 24시간 후에는 0%에 접근한다. 반면 AFL-Clang, AFL-QEMU, AFL-Dyninst로 는 36,612,518%의 오버헤드가 발생한다.</p><p>또한 우리는 Untracer를 fuzzerQSYM과 통합하여 24시간의 fuzzing에서 QSYM-Untracer가 QSYM-Clang, QSYM-QEMU보다 79,616% 더 많은 test case를 실행하였다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://246p.github.io/tags/2024/>2024</a></li><li><a href=https://246p.github.io/tags/%ED%95%99%EB%B6%80%EC%97%B0%EA%B5%AC%EC%83%9D/>학부연구생</a></li><li><a href=https://246p.github.io/tags/%EB%85%BC%EB%AC%B8/>논문</a></li></ul><nav class=paginav><a class=prev href=https://246p.github.io/blog/paper_1/><span class=title>« Prev</span><br><span>1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution</span>
</a><a class=next href=https://246p.github.io/blog/pl_4/><span class=title>Next »</span><br><span>4. 함수 정의와 호출</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://246p.github.io/>Junlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>