<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2. Automated Whitebox Fuzz Testing | Junlog</title>
<meta name=keywords content="2024,논문,학부연구생,whitebox fuzzing,symbolic execution"><meta name=description content="Automated Whitebox Fuzz Testing
0. Abstract fuzz testing은 소프트웨어 보안 취약점을 찾는 효과적인 기술이다. 전통적인 fuzzer들은 well-formed input에 random mutations을 적용하고 결과값을 테스트한다. 이 논문에서는 Symbolic execution과 Dynamic test generation을 적용하여 alternative whitebox fuzz testing을 구현하였다.
이 논문에서는 well-formed input에 따라 실제로 실행되는 것을 기록하고, symbolicaly evalution하고, 프로그램이 입력을 어떻게 사용하는지 확인하여 입력에 대한 제약조건을 수집한다. 수집한 제약조건들을 하나씩 부정하고 constraint solver를 이용하여 solve한다. 이를 통해 프로그램에서 다른 경로를 실행하는 새로운 input을 생성한다."><meta name=author content="Kim-Minjoon"><link rel=canonical href=https://246p.github.io/blog/paper_2/><meta name=google-site-verification content="GTM-524D7HPF"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="2. Automated Whitebox Fuzz Testing"><meta property="og:description" content="Automated Whitebox Fuzz Testing
0. Abstract fuzz testing은 소프트웨어 보안 취약점을 찾는 효과적인 기술이다. 전통적인 fuzzer들은 well-formed input에 random mutations을 적용하고 결과값을 테스트한다. 이 논문에서는 Symbolic execution과 Dynamic test generation을 적용하여 alternative whitebox fuzz testing을 구현하였다.
이 논문에서는 well-formed input에 따라 실제로 실행되는 것을 기록하고, symbolicaly evalution하고, 프로그램이 입력을 어떻게 사용하는지 확인하여 입력에 대한 제약조건을 수집한다. 수집한 제약조건들을 하나씩 부정하고 constraint solver를 이용하여 solve한다. 이를 통해 프로그램에서 다른 경로를 실행하는 새로운 input을 생성한다."><meta property="og:type" content="article"><meta property="og:url" content="https://246p.github.io/blog/paper_2/"><meta property="og:image" content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-02-02T01:26:16+09:00"><meta property="article:modified_time" content="2024-02-02T01:26:16+09:00"><meta property="og:site_name" content="Junlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta name=twitter:title content="2. Automated Whitebox Fuzz Testing"><meta name=twitter:description content="Automated Whitebox Fuzz Testing
0. Abstract fuzz testing은 소프트웨어 보안 취약점을 찾는 효과적인 기술이다. 전통적인 fuzzer들은 well-formed input에 random mutations을 적용하고 결과값을 테스트한다. 이 논문에서는 Symbolic execution과 Dynamic test generation을 적용하여 alternative whitebox fuzz testing을 구현하였다.
이 논문에서는 well-formed input에 따라 실제로 실행되는 것을 기록하고, symbolicaly evalution하고, 프로그램이 입력을 어떻게 사용하는지 확인하여 입력에 대한 제약조건을 수집한다. 수집한 제약조건들을 하나씩 부정하고 constraint solver를 이용하여 solve한다. 이를 통해 프로그램에서 다른 경로를 실행하는 새로운 input을 생성한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://246p.github.io/post/"},{"@type":"ListItem","position":2,"name":"2. Automated Whitebox Fuzz Testing","item":"https://246p.github.io/blog/paper_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2. Automated Whitebox Fuzz Testing","name":"2. Automated Whitebox Fuzz Testing","description":"Automated Whitebox Fuzz Testing\n0. Abstract fuzz testing은 소프트웨어 보안 취약점을 찾는 효과적인 기술이다. 전통적인 fuzzer들은 well-formed input에 random mutations을 적용하고 결과값을 테스트한다. 이 논문에서는 Symbolic execution과 Dynamic test generation을 적용하여 alternative whitebox fuzz testing을 구현하였다.\n이 논문에서는 well-formed input에 따라 실제로 실행되는 것을 기록하고, symbolicaly evalution하고, 프로그램이 입력을 어떻게 사용하는지 확인하여 입력에 대한 제약조건을 수집한다. 수집한 제약조건들을 하나씩 부정하고 constraint solver를 이용하여 solve한다. 이를 통해 프로그램에서 다른 경로를 실행하는 새로운 input을 생성한다.","keywords":["2024","논문","학부연구생","whitebox fuzzing","symbolic execution"],"articleBody":"Automated Whitebox Fuzz Testing\n0. Abstract fuzz testing은 소프트웨어 보안 취약점을 찾는 효과적인 기술이다. 전통적인 fuzzer들은 well-formed input에 random mutations을 적용하고 결과값을 테스트한다. 이 논문에서는 Symbolic execution과 Dynamic test generation을 적용하여 alternative whitebox fuzz testing을 구현하였다.\n이 논문에서는 well-formed input에 따라 실제로 실행되는 것을 기록하고, symbolicaly evalution하고, 프로그램이 입력을 어떻게 사용하는지 확인하여 입력에 대한 제약조건을 수집한다. 수집한 제약조건들을 하나씩 부정하고 constraint solver를 이용하여 solve한다. 이를 통해 프로그램에서 다른 경로를 실행하는 새로운 input을 생성한다. 이러한 과정은 code-coverage maximizing heuristic의 도움으로 반복된다.\n이 알고리즘을 SAGE(Scalable, Automated, Guided, Execution)이라는 새로운 도구에서 구현하였고 SAGE는 임의의 파일을 읽는 windows application을 x86 instruct level tracing, emulation할 수 있는 white box fuzzing tool이다. 대규모 입력 파일과 수백만개의 명령으로 구성된 긴 실행 추적을 통하여 dynamic test generation을 하는 과정속 적용된 주요 최적화 기법을 소개한다.\n이후 여러 windows application을 대상으로한 실험을 소개한다. 특정 지식없이 SAGE는 black box fuzzing, static analysis tool이 놓친 MS07-017 ANI vulnerability를 찾았고 image processsors, media players, file decoders등에서 30개 이상의 새로운 버그를 발견하였다. 이중 몇가지는 memory access violation이다.\n1. Introduction “Month of Browser Bugs\"이 새로운 bug를 공개한 이후 fuzz testing은 large application에서 빠르고 효율적으로 보안 버그를 찾는 방법으로 떠오르고 있다. fuzz testing은 blackbox random testing의 한 사례이다. 어떤 경우에는 well-formed input을 생성하기위하여 grammar가 사용되며 application의 특정 지식과 test geuristics을 사용한다.\nfuzz testing은 효과적이지만 blackbox testing의 한계는 잘 알려져 있다.\n1 if (x==10) (statement) 의 경우 x가 무작위로 선택된 2^32분의 1 확률로 실행된다. 이것은 random testing이 낮은 code coverage를 제공하는 이유를 설명한다.\n이러한 한계는 버그가 포함된 코드가 실행되지 않았기 때문에 BOF와 같은 심각한 security bug를 놓칠 수 있음을 의미한다.\n이 논문에서 dynamic test generation으로부터 영감을 받아 whitebox testing 접근 방법을 제안한다.\n알고리즘은 fixed input으로 시작하여 프로그램을 symbolic하게 실행하며 조건문에서 constraint을 수집한다. 수집한 constraint을 부정하고 Constraint Solver를 이용하여 프로그램 내에서 다양한 path를 테스트 하는데 사용된다.\n이 과정은 새로운 search algorithm과 coverage-maximizing heuristic을 이용하여 반복된다.\n예를들어 x=0을 위의 코드로 실행되면 constraint x≠10이 생성된다. 이를 부정하여 x=10을 생성하고 주어진 조건문을 만족하는 새로운 입력을 제공한다.\n이를 통하여 입력 형식에 대한 구체적인 지식 없이도 보안 버그를 찾기 위해 프로그램의 추가 코드를 실행하고 테스트할 수 있다. 또한 프로그래머가 메모리를 올바르게 할당하고 버퍼를 조작하지 못하게 할 수 있는 “corner cases\"를 자동으로 발견하고 테스트하여 security vulnerabilities를 탐지한다.\n이론적으로 systematic dynamic test generation은 full program path coverage, program verification에 도달할 수 있다. 그러나 실제로 테스트 대상 프로그램의 path의 수가 크고 symbolic exectuion, constraint generation, constraint solving이 부정확하기 때문에 일반적으로 search가 불가능하다.\n따라서 우리는 실용적인 절충안을 찾을 수 밖에 없으며 이 논문에서는 유용하다고 생각하는 점을 제시한다. 실제로 특정 접근 방식은 이전에 well-test되었던 large application에서 새로운 결함을 찾는데 효과적이다.\n우리의 알고리즘은 많은 결함을 찾아내었고 defact triage problem을 다룬다. 이는 static program analysis와 blackbox fuzzing에서 흔한 일이지만 dynamic test generation 에서는 이제까지 다루지 않았던 문제이다. 우리의 접근 방법은 기존 dynamic test generation에서 수행되었던것보다 더 큰 application을 테스트할 수 있다.\n이 접근방식을 SAGE에 구현하였다 SAGE는 Scalable, Automated, Guided Execution의 약자로 x84 Windows application을 위한 whole-program whitebox file fuzzing tool이다. 현재 도구는 file-reading application에 중점을 두고 있지만 natwork-facing application에 대해서도 적용 가능하다.\nSAGE는 blackbox fuzzer가 찾을 수 없었던 버그를 찾을 수 있다. 또한 formet-specific knowledge가 없이 blackbox fuzzing과 static anlysis에서 놓친 MS07-017 ANI bulnerability를 찾았다. 우리의 작엄은 다음 3가지에 대해 기여하였다.\n2장에서 search가 불완전 할 수 있는 large input file, long execution traces를 갖는 large applicationd에 대한 새로운 search algorithm을 제시하였다. 3장에서는 SAGE의 구현에 관하여 논의하였다. symbolic execution algorithm 뒤에있는 엔지니어링 선택과 수백만 명령어의 program traces로 확장할 수 있는 key optimization techniques을 설명한다. 4장은 SAGE를 사용한 경험에 대하여 설명하고 있다. 발견한 결함의 예를 들고 다양한 실험의 결과에 대해서 논의하였다. 2. A White Box Fuzzing Algorithm 2.1 Background: Dynamic Test Generation 다음 프로그램에서 논의해 보자\n1 2 3 4 5 6 7 8 void top (char input[4]){ int cnt=0; if (input[0]=='b') cnt++; if (input[1]=='a') cnt++; if (input[2]=='d') cnt++; if (input[3]=='!') cnt++;; if (cnt\u003e=3) abort(); //error } abort가 발생할 조건을 random testing(blackbox fuzzing)으로 찾을 확률은 5/2^(8*4)정도이다. 이는 random testing의 전형적인 문제로 프로그램의 가능한 모든 execution path로 이끌어낼 input을 생성하기 어렵다.\n반면 whitebox dynamic test generation은 이 프로그램의 오류를 쉽게 찾을 수 있다. 일부 initial input을 통하여 프로그램을 실행하여 실행 도중 분기문에서의 족너으로부터 입력에 대한 제약을 수집하기 위해 dynamic symbolic execution을 수행하여 constraint solver를 통하여 이전의 입력에 변형을 주어 다음 실행의 새로운 branch를 찾도록 한다.\n이 과정은 주어진 프로그램 statement나 path가 실행되거나 프로그램의 모든(많은) 실행 가능한 path가 실행될때까지 반복된다.\n위의 예시를 가정하면 우리는 초기 4개의 문자열 good을 가지고 함수 top을 실행한다 (경로 ρ). Figure 2는 top에 대한 모든 실행 가능한 program path의 집합을 보여준다. 가장 왼쪽 경로는 ‘good’에 대한 프로그램의 첫번째 실행을 나타내며 프로그램 내의 모든 if문의 else에 해당하는 경로에 해당한다. leaf의 숫자들은 0은 cnt의 값을 나타내고 있다.\nnormal execution과 함께 symbolic execution은 조건문이 어떻게 평가되는지에 따라 다음과 같은 condition을 수집한다.\ni_0≠b, i_1≠a, i_2≠d, i_3≠! (i_0는 input[0]의 memory location의 값을 나타내는 symbolic variable) 다음 pathconstraint에 대해서 생각해보자\nφ_ρ = 이는 input vector의 equivalant class이다. 즉, 방금 실행된 path로 실행되는 모든 input vector이다. 프로그램을 다른 equivalant class로 실행하려면 현제 path constraint 하나를 부정하여 다른 path로 실행할 수 있다.\nex) φ = 이 path constraint의 해는 goo! 이다. 이를 실행하게 된다면 Figure2에서 왼쪽에서 두번째에 있는 path가 실행 된다. 이과정을 반복함으로 이 프로그램에서 가능한 모든 16가지 path를 실행할 수 있다.\n이 탐색이 depth-first order로 실행된다면 Figure의 왼쪽에서 오른쪽으로 탐색된다. 그러면 cnt==3인 첫 오류는 8번째 실행에서 발생하고 9번째 실행 후에 full branch/block coverage에 도달한다.\n2.2 Limitations 위에서 간략하게 소개된 Systematic dynamic test generation에는 두가지 한계가 존재한다.\n2.2.1 Path explosion 모든 실행 가능한 path를 실행하는것은 실제 대규모 프로그램에 대해서 확장성이 없다. path explosion은 dynamic test generation 을 compositionally하게 수행하면서 완하할 수 있다.\n이는 함수를 독립적으로 테스팅하고 테스트 결과를 함수 입력전제조건과 출력 후 조건을 사용하여 function summaries하고 high-level function을 테스팅할때 이러한 summaries를 제사용 함으로서 이루어진다.\nsoftware testing에서 summaries가 유용해 보이지만 수백만 가지 명령어를 가진 large application에 대해서 full path coverage를 도달하기엔 한계가 존재한다.\n2.2.2 Imperfect symbolic execution large program에 대한 symbolic execution은 복잡한 program statements(포인터 조작, 산술연산 등)과 운영체제, 라이브러리 함수 호출로 인하여 정확하게 추론하기 어렵거나 불가능하여 정밀도가 떨어질 수 있다. 즉 합리적인 비용으로 정밀도를 가지고 symbolically precision하는것은 어렵다.\nsymbolic execution이 불가능할때 concrete한 값을 사용하여 constraint를 단순화 하고 단순화된 부분적 symbolic execution을 수행할 수 있다.\n주어진 input vector에 대한 symbolic execution으로 예측된 프로그램 path와 실제 실행된 path가 일치하지 않을때 divergence가 발생하였다고 한다.\ndivergence은 예측된 path를 bit vector(각 조건분기 결과에 대한 한 비트)로 기록하고 이후 실제로 해당 path가 수행되어있는지 확인함으로 감지할 수 있다.\n2.3 Generational Search 이러한 실용적 한계를 해결하기위하여 새로운 search algorithm을 소개한다. 이 알고리즘은 다음과 같은 주요 특징을 가지고 있다.\n대규모 입력(수천개의 symbolic variable)을 사용하고 매우 깊은 path(수백만개의 명렁어)를 가진 large application의 state space를 체계적이고 부분적으로 탐색하도록 설계되었다. search 과정에서 중복을 피하며 각 symbolic execution(long, expensive)에서 생성된 새로운 테스트의 수를 극대한다. 버그를 빠르게 찾는것을 목표로 가능한 빨리 code coverage를 극대화하기 위한 heuristic을 사용한다. divergence가 발생할때 recover할 수 있고 계속 진행된다. 이 새로운 search algorithm은 아래 두 코드로 제시된다. 먼저 Search함수는 standard한 과정이다.\n1. 초기 inputSeed를 workList에 넣는다. 2. 프로그램을 실행하여 bug가 감지되었는지 확인한다. 3. workList에서 Input 하나 선택하고 ExpandExecution을 통하여 새로운 childInputs을 생성한다. 4. childInput의 각각에 대해 프로그램을 실행하고 오류를 확인하고 점수를 계산한다. 5. workList에 이를 추가한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Search(inputSeed){ inputSeed.bound = 0; workList = {inputSeed}; Run\u0026Check(inputSeed); while (workList not empty) {//new children input = PickFirstItem(workList); childInputs = ExpandExecution(input); while (childInputs not empty) { newInput = PickOneItem(childInputs); Run\u0026Check(newInput); Score(newInput); workList = workList + newInput; } } } 이 알고리즘에서 주요한 부분은 아래코드와 같이 childInput을 확장하는 방식에 있다. ExpandExecution은 아래와 같이 동작한다.\n1. 해당 입력으로 symbolic excution를 통하여 path constraint (PC)를 생성한다. 2. not(PC[j])와 PC[0..(j-1)]이 해 I가 존재하는지 확인한다. 3. 해가 존재한다면 해를 이용하여 input을 업데이트한다. 4. 새로운 input은 evalutaion을 위하여 저장한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 ExpandExecution(input) { childInputs = {}; // symbolically execute (program,input) PC = ComputePathConstraint(input); for (j=input.bound; j \u003c |PC|; j++){ if((PC[0..(j-1)] and not(PC[j]))has a solution I){ newInput = input + I; newInput.bound = j; childInputs = childInputs + newInput; } } return childInputs; } 즉 inputSeed와 PC로 시작하여 새로운 search alogrithm은 PC의 모든 constraint를 확장하려고 시도할것이다. DFS의 경우 마지막 constraint를, BFS의 경우 첫번째 constraint를 확장하는것과 대비된다.\n또한 child sub-search가 중복 탐색하는것을 방지하기위하여 bound 매개변수를 사용하여 sub-search가 parent로부터 시작된 분기로 돌아가는것을 제한한다.\n각 실행이 많은 child로 확장되기 때문에 이러한 검색 순서를 generational search 라고 한다.\n다시 top에 대해 고려해 본다면 초기 입력이 good이라고 가정하였을때 Figure 2의 tree에서 가장 왼쪽 path는 그 입력에 대한 첫번째 실행을 의미한다.\n이 parent execution에서 generational search는 4개의 first-generation child를 생성하는데 이는 leaf에 1로 기록된 4개의 path에 해당한다. 실제로 이 path들은 parent의 path constraint중 하나의 constraint를 부정하는것에 해당한다.\n위 코드의 과정을 통하여 6개의 second-generation child를 생성할 수 있다. 이 과정을 반복하여 top 함수의 모든 실행 가능한 execution path를 한번씩 생성할 수 있다. 또한 cnt의 값은 generation number을 나타낸다.\nExpandExecution은 현재 path constraint에서 하나만 확장하는 대신 bound 안의 모든 constraint를 확장하기 때문에 각 symbolic execution에서 생성된 새로운 테스트 input의 수를 극대화 한다.\n이 최적화는 top과 같은 작은 프로그램의 모든 execution path를 탐색하는데는 중요하지 않을 수 있지만 symbolic execution이 오랜 시간 걸리는 경우(모든 path를 실행하는것이 불가능한 large application)에는 중요하다. 3장에서 이에대해 더 자세히 논의되고 4장에서 관련된 실험을 통해 설명한다.\n이 시나리오에서 initial input으로 수행된 첫번째 symbolic execution을 최대한 이용하고 first-generation child를 체계적으로 탐색하고자 한다. 이검색 전략은 initial input이 잘 형성되어 있을때 가장 잘 작동한다.\n실제로 프로그램 코드의 더 많은 부분을 실행할 가능성이 더 높아지고 따라서 더 많은 constraint를 부어할 수 있으며 그 결과 더 많은 child가 생성된다. 이는 4장에서 실험을 통해 보여진다.\ninitial input에 대한 중요성은 전통적인 blackbox fuzz testing에서 수행하는것과 유사하며 이때문에 이러한 검색 기법을 whitebox fuzzing라고 한다.\n첫번째 parent execution의 child를 확장하는것은 빠르게 block covarage를 극대화 하는 heuristic를 사용하여 우선순위를 정하여 더 빠르게 더 많은 bug를 찾을 수 있다.\nSearch의 Score함수는 newInput을 실행하여 이전 모든 실행과 비교했을때 얻은 incremental block coverage를 계산한다.\n예를들어 100개의 새로운 block을 만드는 newInput에는 100점을 할당한다.\n이후 newInput은 점수에 따라 workList에 삽입되며 높은 점수를 가진 항목이 List의 가장 앞에 배치된다. 즉 모든 자식들은 generation number와 관련없이 서로 경쟁한다.\n우리의 block coverage heuristic은 EXE의 Best-First Search와 관련있다. 하지만 전체 검색 전략은 다르다. EXE는 block coverage heuristic을 사용하지만 다음 child 를 탐색할때 DFS를 사용하는 반면 우리는 generational serach를 사용하여 모든 child를 테스트한다. workList에서 가장 좋은 것을 선택하기 전에 점수를 부여한다.\nScore 함수로 계산된 block coverage heuristic은 divergent를 처리하는데도 도움이 된다. 하나의 divergent는 검색의 완전성을 손상하지만 매우 큰 검색 공간에서는 검색이 불완전할 수 밖에 없으므로 주요 문제가 되진 않는다. 하지만 divergent가 발생한다면 검색이 진행되지 않는다.\n예를 들어서 path P에서 이전 탐색된 경로 P’로 divergence하는 경우 DFS는 P’과 P사이에 영원히 순환한다. 반면 우리의 generational search는 dievergence를 허용하고 이러한 pathological 상황에서 회복할 수 있다.\n실제로 각 실행은 DFS처럼 많은 child를 생성하며, 만약 child P가 이전 실행 P’으로 divergent한다면 p는 점수가 0이되어 workList의 끝에 배치되므로 정상적인(non-divergent) child의 확장에 방해를 주지 않는다. 또한 divergence은 4장에서 다룰 우리의 알고리즘의 중요한 기능이다.\n마지막으로 generational search는 병렬화 하기 쉽다. child를 독립적으로 확인하고 점수를 부여할 수 있다.\n3. The SAGE System SAGE(Scalable, Automated, Guided Execution)은 파일에서 읽은 바이트를 symbolic input으로 취급하여 windows에서 실행되는 모든 파일 읽기 프로그램을 테스트할 수 있다.\nSAGE의 또 다른 혁신은 symbolic execution을 수행할때 x86 Binary level에서 trace할 수 있다는 것이다.\n이 섹션은 SGAE의 설계 선택을 정당화 할 수 있는 논리를 제시한다.\n3.1 System Architecture SAGE는 4가지 유형의 작업을 반복하며 generational serach를 수행한다.\n3.1.1 Tester Tester는 testinput으로 프로그램을 실행하여 access violation exceptions과 extreme memory consumption등 비정상적인 이벤트를 찾는 Run\u0026Check를 구현한다. Tester가 오류를 감지하면 testcase를 저장하고 4장에 나오는 방법대로 분류를 수행한다.\n3.1.2 Tracer Tracer는 동힐한 input으로 다시 실행하여 프로그램이 실행되지 않을때 확인하기 위한 로그를 생성하고 저장한다. 이 작업은 iDNA framework를 사용하여 machine-instruction level에서의 execution traces를 수집한다.\n3.1.3 CoverageCollector 기록된 로그 재생하여 어떤 basic block이 실행되었는지 계산한다. SAGE는 이 정보를 사용하여 Score 함수를 구현한다.\n3.1.4 SymbolicExecutor 기록된 로그를 다시 재생하여 입력관련 constraint를 수집하고 constraint solver Disolver를 사용하여 새로운 입력을 생성하고 2.3절의 ExpandExecution을 구현한다.\n3.1.5 TrueScan CoverageCollector와 SymbolicExecutor는 iDNA에 의해 생성된 trace file을 사용하고 기록된 실행을 가상으로 재실행하는 trace replay framework TruScan위에 구축하였다.\nTruScan은 symbolic execution을 단순화 하는 다음과 같은 기능을 제공한다.\n명령어 디코딩 symbolic information에 대한 인터페이스 제공 다양한 입출력 시스템 호출 모니터링 heap, stack frame 할당 추적 프로그램 구조를 통한 data flow tracking 3.2 Trace-based x86 Constraint Generation SAGE의 constraint generation은 dynamical test generation과 두가지 방면에서 차이가 있다.\n3.2.1 Machine-Code-Based Approach Multitude of languages and build processes source-based 계측은 테스트 대상 프로그램에 사용된 특정 언어, 컴파일러, 빌드 프로세스를 지원해야한다. 따라서 새로운 언어, 컴파일러, 빌드 도구에 계측을 적용하는데는 많은 초기비용이 든다. 다양한 빌드 프로세스와 호환되지 않는 컴파일러 버전으로 개발된 많은 application을 cover하는 것은 쉽지 않다.\n반면 machine-code-based symbolic execution engine은 복잡하지만 아키텍처마다 한번만 구현하면 된다.\nCompiler and post-build transformations 실제로 출시된 binary code에서 symbolic execution을 수행함으로서 SAGE는 대상 프로그램 뿐만 아니라 컴파일, 후처리 과정에서 발생할 수 있는 버그를 포착할 수 있게 한다.\n예를들어 코드 난독화 도구나 base block transformer와 같은 도구는 source code와 bianary code사이으 미묘한 차이를 발생시킬 수 있다.\nUnavailability of source source code를 얻기 어려울 수 있다. source-based 계측은 self-modifying, JITed(Just-In-Time compiled) 코드에 대해서 어려울 수 있으나 SAGE는 machine code level에서 작업함으로 이러한 문제를 해결할 수 있다.\n물론 source code에는 machine code에서 즉시 보이지 않는 타입과 구조에 대한 정보가 있지만 SAGE의 path search에는 이 정보가 필요하지 않다.\n3.2.2 Offline Trace-Based Constraint Generation SAGE는 online 계측 대신 offline trace기반의 constraint generation을 사용한다. online generation은 프로그램이 실행될때 정적으로 주입된 계측 코드나 Nirvana, Valgrind와 같은 static binary 계측도구를 이용하여 constraint가 생성된다.\nSAGE가 offline trace-based constraint generation을 사용하는것은 두가지 이유 때문이다.\n프로그램은 OS에 의하여 보호되거나 난독화될 수 있는 binary 요소들을 포함할 수 있어 계측된 버전으로 교체하기 어려울 수 있다. 프로그램의 비결정성은 online constraint generation의 디버깅을 어렵게 만든다. constraint generation engine에 문제가 발생한다면 이를 재현하기 어려울 것이기 때문이다. SAGE에서 constraint generation은 실행시간 동안 모든 비결정적 이벤트의 결과를 기록하는 execution trace에서 작동하기에 완전히 결정론적이다. 3.3 Constraint Generation Symbolic Tag SAGE는 프로그램의 concrete and symbolic state를 각 메모리 위치와 레지스터를 byte-sized value와 symbolic tag를 각각 연결하여 한쌍으로 저장한다. symbolic tag는 input vlaue나 어떤 값의 함수를 나타내는 표현식이다.\nSAGE는 여러 종류의 tag를 지원한다.\ninput(m) input의 m번째 바이트 c : 상수 t1 op t2 : t1과 t2의 연산(op)값 sequence tag : t0…tn에서 내는 byte-size값을 그룹화 하여 얻은 word, double-word 크기의 값 subtag (t,i) : word, double-word 크기의 t중 i번째 byte의 값 SAGE는 symbolic pointer dereference를 추론하지 않는다. SAGE는 비 상수 symbolic tag마다 새로운 symbolic variable을 정의한다. SAGE가 프로그램 trace를 재생할때 방문한 각 명령어의 의미에 따라 concrete and symbolic 저장소를 업데이트한다.\nSAGE는 symbolic tag propagation을 수행하는것 이외에도 input vlaue에 대한 constraint를 생성한다. constraint는 symbolic variable간의 관계를 나타낸다.\n예를 들어 input(4)에 해당하는 변수 x가 주어졌을때 x\u003c10은 입력의 다섯번째 바이트가 10보다 크다는 뜻이다.\ninput에 의존하는 conditional jump를 만나면 분기의 결과를 모델링하는 constraint를 생성하고 지금까지 만난 contraint로 구성된 path constraint에 추가한다.\nTracking Symbolic Tag and Collecting Constraints 다음은 symbolic tag를 추적하고 constraint를 수집하는 과정을 보여준다.\n1 2 3 4 5 6 7 # read 10 byte file into a # buffer beginning at address 1000 mov ebx, 1005 mov al, byte [ebx] dec al # Decrement al jz LabelForIfZero # Jump if al == 0 10byte의 파일을 읽어서 1000번지 주소에 저장한다. 이 명령어를 실행함에 따라 SAGE는 주소 1000~1009를 symbolic tag input(0)~input(9)와 연결하여 symbolic 저장소를 업데이트한다. mov 명령어는 6번째 입력 바이트를 al레즈스터로 로드한다. 명령어를 재생한 후 SAGE는 al을 input(5)dp mapping하는것으로 symbolic 저장소를 업데이트한다. 마지막 두 명령언s al을 감소하고 감소된 값이 0이면 LabelForIfZero로 conditional jump를 수행한다. 분기의 결과에 따라 두가지 constraint중 하나를 추가한다. (t=input(5)-1 -\u003e t=0 or t=1 추가) Conditional Jump 이는 x86 machine instruction 으로부터 constraint를 형성하는데 있어서 주요 문제중 하나로 이어진다. conditional expression에서 비교과 이루어질때 그것이 어떻게 conditional jump에 사용되는지 알 수 없다.\nEFLAG 프로세서에는 CF,SF,AF,PF,OF,ZF와 같은 EFLAG가 존재한다. EFLAG는 다양한 명령어의 결과에 따라 결정된다 예를들어 CF는 산술연산간 carry가 발생하였다면 1로 설정된다.\nEFLAG의 처리를 위해 SAGE는 n비트의 값으로 f0…fn-1에 따라 설정된 비트를 나타네는 bit vector tag \u003cf0…fn-1\u003e을 정의한다.\n위의 예시에서 SGAE가 dec명령어를 실행할떄 al과 EFLAG에 대한 symbolic 저장소의 mapping을 업데이트 한다(t=input(5)-1, CF,ZF).\nCasting x86에서 자자주 사용되는 관행은 byte, word, double word간의 casting이다. 테스트 대상 프로그램의 코드에 명시적인 casting이 포함되지 않더라도 atol, malloc, memcpy등 run-time library에서 casting을 수행하는 함수를 호출하게 된다.\nSAGE는 subtag와 sequence tag를 이용하여 casting의 정확한 처리를 구현한다.\n1 2 3 mov ch, byte [...] mov cl, byte [...] inc cx # Increment cx 두개의 명령어가 symbolic tag t1,t2와 관련된 주소를 읽을때 SAGE가 명령어를 재생할때 symbolic 저장소는 cl-\u003et1, ch-\u003et2으로 mapping을 업데이트한다. 다음 명령어는 cx를 증가한다 cx는 16bit 레지스터로 cl과 ch를 포함한다.\n증가하기 전에 cx의 내용은 로 표현할 수 있다. 증가한 후 cx는 t=로 표현할 수 있는데 inc를 마무리하기 위하여 SAGE는 symbolic 저장소의 byte크기의 maaping을 cl-\u003esubtag(t,0), ch-\u003esubtag(t,1)로 업데이트 한다.\nSAGE는 symbolic 저장소를 byte크기로 다음과 같이 인코딩하여 mapping한다.\nx=x'+256*x', where x=t, x'=subtag (t,0), x''=subtag(t,1) 3.4 Constraint Optimization Standard Optimization SAGE의 constraint generation의 속도와 메모리 사용을 향상시키기 위하여 몇가지 최적화 기법을 사용한다.\n1. Tag Caching : 구조적으로 동등한 tag들이 동일한 physical object에 mapping되도록 한다. 2. unrelated constraint elimination : 부정된 constraint와 symbolic variable을 공유하지 않는 constraint를 제거함으로서 constraint solver의 크기를 줄인다. 3. local constraint caching : 이미 path constraint에 추가된 constraint는 건너 뛴다. 4. flip count limit : 특정 명령어에서 생성된 constraint가 몇번 flip가능한 최대 횟수를 설정한다. 5. concretization : 여러 명령을 포함하는 symbolic tag를 concerete value로 줄인다. 이러한 최적화는 dynamical test generation에서 표준적인 방법이다. 이 섹션의 나머지 부분은 structured-file parsing application에 대한 최적화에사용되는 constraint subsumption(가정)에 대해서 설명한다.\nConstraint subsumption constraint subsumption은 주어진 분기 명령에서 셍성된 constraint를 추적하여 새로운 constaint f가 생성될때 SAGE는 빠른 syntactic check를 통하여 f 다른 constaint를 함축하거나 같은 명령에서 생성된 다른 constraint에 의해 함축되는지 판단하고 함축된다면 path constraint에서 제거된다.\nsubsumption 최적화는 다양한 image parser및 미디어 플레이어와 같은 structured file을 처리하는 많은 프로그램에 중요한 영향을 미친다.\nConstant Folding 다음과 같은 예제를 확인해보자\n1 2 3 mov cl, byte [...] dec cl # Decrement cl ja 2 # Jump if cl \u003e 0 이 코드는 cl에 바이트를 로드하고 0이 될때까지 loop에서 감소시킨다. mov 명령에 의해 읽힌 바이트가 symbolic tag t0에 매핑된다고 하자. 3.3절에서 설명한 알고리즘은 다음과 t1\u003e0,…,tk-1\u003e0과 tk\u003c=0을 생성한다. 여기서 k는 로드된 바이트의 구체적인 값이고 ti+1=ti-1이다.\n반복마다 새로운 constraint와 symbolic tag를 생성하기 때문에 메모리는 루프 반복횟수에 선형적이다.\n여기서 subsumption을 사용한다면 첫 k-2개의 constraint는 다음 constraint에 의해 축약되기 때문에 제거할 수 있다. 우리는 symbolic tag는 선형적인 수로 유지해야 한다. 왜냐하면 각 tag는 이전 tag에 대한 조건으로 정의되기 때문이다.\n이를 상수 크기의 공간으로 동작을 하기 위해서는 tag 생성중 constand folding을 수행해야한다. : (t-c)-1=t-(c+1)\nconstraint subsumption과 constant folding을 적용한다면 다음 두가지 constraint를 갖는 path constraint가 된다.\nt0-(k-1)\u003e0 and t0 -k \u003c=0 sequence tag simplification 만약 multi-byte에 대해서는 또 다른 문제가 있다 다음 예제를 보자 위 예시와 비슷하지만 cl이 아닌 cx로 대체되었다.\n1 2 3 mov cx, word [...] dec cx # Decrement cx ja 2 # Jump if cx \u003e 0 mov 명령에 의해 읽힌 두 바이트가 t'0 ,t’‘0에 메핑된다고 가정한다면 다음과같은 constraint를 생성한다\ns1\u003e0,...,sk-1\u003e0 and sk\u003c=0 where si+1 = ","wordCount":"4542","inLanguage":"en","datePublished":"2024-02-02T01:26:16+09:00","dateModified":"2024-02-02T01:26:16+09:00","author":{"@type":"Person","name":"Kim-Minjoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://246p.github.io/blog/paper_2/"},"publisher":{"@type":"Organization","name":"Junlog","logo":{"@type":"ImageObject","url":"https://246p.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://246p.github.io/ accesskey=h title="HOME (Alt + H)"><img src=https://246p.github.io/apple-touch-icon.png alt aria-label=logo height=35>HOME</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://246p.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://246p.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://246p.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://246p.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1Di1J0LxHNuXNiDbwFhOh2XMLAgUJtYlh/view?usp=drive_link" title=CV><span>CV</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://246p.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://246p.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">2. Automated Whitebox Fuzz Testing</h1><div class=post-meta><span title='2024-02-02 01:26:16 +0900 KST'>February 2, 2024</span>&nbsp;·&nbsp;Kim-Minjoon</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#21-background-dynamic-test-generation>2.1 Background: Dynamic Test Generation</a></li><li><a href=#22-limitations>2.2 Limitations</a><ul><li><a href=#221-path-explosion>2.2.1 Path explosion</a></li><li><a href=#222-imperfect-symbolic-execution>2.2.2 Imperfect symbolic execution</a></li></ul></li><li><a href=#23-generational-search>2.3 Generational Search</a></li></ul><ul><li><a href=#31-system-architecture>3.1 System Architecture</a><ul><li><a href=#311-tester>3.1.1 Tester</a></li><li><a href=#312-tracer>3.1.2 Tracer</a></li><li><a href=#313-coveragecollector>3.1.3 CoverageCollector</a></li><li><a href=#314-symbolicexecutor>3.1.4 SymbolicExecutor</a></li><li><a href=#315-truescan>3.1.5 TrueScan</a></li></ul></li><li><a href=#32-trace-based-x86-constraint-generation>3.2 Trace-based x86 Constraint Generation</a><ul><li><a href=#321-machine-code-based-approach>3.2.1 Machine-Code-Based Approach</a></li><li><a href=#322-offline-trace-based-constraint-generation>3.2.2 Offline Trace-Based Constraint Generation</a></li></ul></li><li><a href=#33-constraint-generation>3.3 Constraint Generation</a><ul><li><a href=#symbolic-tag>Symbolic Tag</a></li><li><a href=#tracking-symbolic-tag-and-collecting-constraints>Tracking Symbolic Tag and Collecting Constraints</a></li><li><a href=#conditional-jump>Conditional Jump</a></li><li><a href=#eflag>EFLAG</a></li><li><a href=#casting>Casting</a></li></ul></li><li><a href=#34-constraint-optimization>3.4 Constraint Optimization</a><ul><li><a href=#standard-optimization>Standard Optimization</a></li><li><a href=#constraint-subsumption>Constraint subsumption</a></li><li><a href=#constant-folding>Constant Folding</a></li><li><a href=#sequence-tag-simplification>sequence tag simplification</a></li></ul></li></ul><ul><li><a href=#41-initial-experiences>4.1 Initial Experiences</a><ul><li><a href=#ms07-017>MS07-017</a></li><li><a href=#compressed-file-format>Compressed File Format</a></li><li><a href=#media-file-parsing>Media File Parsing</a></li><li><a href=#office-2007-application>Office 2007 Application</a></li><li><a href=#image-parsing>Image Parsing</a></li></ul></li><li><a href=#42-experiment-setup>4.2 Experiment Setup</a><ul><li><a href=#test-plan>Test Plan</a></li><li><a href=#triage>Triage</a></li><li><a href=#nondeterminism-in-coverage-results>Nondeterminism in Coverage Results</a></li></ul></li><li><a href=#43-results-and-observations>4.3 Results and Observations</a><ul><li><a href=#symbolic-execution-is-slow>Symbolic execution is slow</a></li><li><a href=#generational-search-is-better-than-depth-first-search>Generational search is better than depth-first search</a></li><li><a href=#divergences-are-common>Divergences are common</a></li><li><a href=#bogus-files-find-few-bugs>Bogus files find few bugs</a></li><li><a href=#different-files-find-different-bugs>Different files find different bugs</a></li><li><a href=#bugs-found-are-shallow>Bugs found are shallow</a></li><li><a href=#no-clear-correlation-between-coverage-and-crashes>No clear correlation between coverage and crashes</a></li><li><a href=#effect-of-block-coverage-heuristic>Effect of block coverage heuristic</a></li></ul></li></ul><ul><li><a href=#input-grammar>Input Grammar</a></li><li><a href=#generational-search-algorithm>Generational Search Algorithm</a></li></ul></nav></div></details></div><div class=post-content><p><a href=https://patricegodefroid.github.io/public_psfiles/ndss2008.pdf>Automated Whitebox Fuzz Testing</a></p><h1 id=0-abstract>0. Abstract<a hidden class=anchor aria-hidden=true href=#0-abstract>#</a></h1><p>fuzz testing은 소프트웨어 보안 취약점을 찾는 효과적인 기술이다.
전통적인 fuzzer들은 well-formed input에 random mutations을 적용하고 결과값을 테스트한다.
이 논문에서는 Symbolic execution과 Dynamic test generation을 적용하여 alternative whitebox fuzz testing을 구현하였다.</p><p>이 논문에서는 well-formed input에 따라 실제로 실행되는 것을 기록하고, symbolicaly evalution하고, 프로그램이 입력을 어떻게 사용하는지 확인하여 입력에 대한 제약조건을 수집한다. 수집한 제약조건들을 하나씩 부정하고 constraint solver를 이용하여 solve한다. 이를 통해 프로그램에서 다른 경로를 실행하는 새로운 input을 생성한다. 이러한 과정은 code-coverage maximizing heuristic의 도움으로 반복된다.</p><p>이 알고리즘을 SAGE(Scalable, Automated, Guided, Execution)이라는 새로운 도구에서 구현하였고 SAGE는 임의의 파일을 읽는 windows application을 x86 instruct level tracing, emulation할 수 있는 white box fuzzing tool이다.
대규모 입력 파일과 수백만개의 명령으로 구성된 긴 실행 추적을 통하여 dynamic test generation을 하는 과정속 적용된 주요 최적화 기법을 소개한다.</p><p>이후 여러 windows application을 대상으로한 실험을 소개한다.
특정 지식없이 SAGE는 black box fuzzing, static analysis tool이 놓친 MS07-017 ANI vulnerability를 찾았고 image processsors, media players, file decoders등에서 30개 이상의 새로운 버그를 발견하였다.
이중 몇가지는 memory access violation이다.</p><h1 id=1-introduction>1. Introduction<a hidden class=anchor aria-hidden=true href=#1-introduction>#</a></h1><p>&ldquo;Month of Browser Bugs"이 새로운 bug를 공개한 이후 fuzz testing은 large application에서 빠르고 효율적으로 보안 버그를 찾는 방법으로 떠오르고 있다. fuzz testing은 blackbox random testing의 한 사례이다. 어떤 경우에는 well-formed input을 생성하기위하여 grammar가 사용되며 application의 특정 지식과 test geuristics을 사용한다.</p><p>fuzz testing은 효과적이지만 blackbox testing의 한계는 잘 알려져 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=o>==</span><span class=mi>10</span><span class=p>)</span> <span class=p>(</span><span class=n>statement</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>의 경우 x가 무작위로 선택된 2^32분의 1 확률로 실행된다.
이것은 random testing이 낮은 code coverage를 제공하는 이유를 설명한다.</p><p>이러한 한계는 버그가 포함된 코드가 실행되지 않았기 때문에 BOF와 같은 심각한 security bug를 놓칠 수 있음을 의미한다.</p><p>이 논문에서 dynamic test generation으로부터 영감을 받아 whitebox testing 접근 방법을 제안한다.</p><p>알고리즘은 fixed input으로 시작하여 프로그램을 symbolic하게 실행하며 조건문에서 constraint을 수집한다. 수집한 constraint을 부정하고 Constraint Solver를 이용하여 프로그램 내에서 다양한 path를 테스트 하는데 사용된다.</p><p>이 과정은 새로운 search algorithm과 coverage-maximizing heuristic을 이용하여 반복된다.</p><p>예를들어 x=0을 위의 코드로 실행되면 constraint x≠10이 생성된다. 이를 부정하여 x=10을 생성하고 주어진 조건문을 만족하는 새로운 입력을 제공한다.</p><p>이를 통하여 입력 형식에 대한 구체적인 지식 없이도 보안 버그를 찾기 위해 프로그램의 추가 코드를 실행하고 테스트할 수 있다. 또한 프로그래머가 메모리를 올바르게 할당하고 버퍼를 조작하지 못하게 할 수 있는 &ldquo;corner cases"를 자동으로 발견하고 테스트하여 security vulnerabilities를 탐지한다.</p><p>이론적으로 systematic dynamic test generation은 full program path coverage, program verification에 도달할 수 있다. 그러나 실제로 테스트 대상 프로그램의 path의 수가 크고 symbolic exectuion, constraint generation, constraint solving이 부정확하기 때문에 일반적으로 search가 불가능하다.</p><p>따라서 우리는 실용적인 절충안을 찾을 수 밖에 없으며 이 논문에서는 유용하다고 생각하는 점을 제시한다. 실제로 특정 접근 방식은 이전에 well-test되었던 large application에서 새로운 결함을 찾는데 효과적이다.</p><p>우리의 알고리즘은 많은 결함을 찾아내었고 defact triage problem을 다룬다. 이는 static program analysis와 blackbox fuzzing에서 흔한 일이지만 dynamic test generation 에서는 이제까지 다루지 않았던 문제이다. 우리의 접근 방법은 기존 dynamic test generation에서 수행되었던것보다 더 큰 application을 테스트할 수 있다.</p><p>이 접근방식을 SAGE에 구현하였다 SAGE는 Scalable, Automated, Guided Execution의 약자로 x84 Windows application을 위한 whole-program whitebox file fuzzing tool이다. 현재 도구는 file-reading application에 중점을 두고 있지만 natwork-facing application에 대해서도 적용 가능하다.</p><p>SAGE는 blackbox fuzzer가 찾을 수 없었던 버그를 찾을 수 있다. 또한 formet-specific knowledge가 없이 blackbox fuzzing과 static anlysis에서 놓친 MS07-017 ANI bulnerability를 찾았다. 우리의 작엄은 다음 3가지에 대해 기여하였다.</p><ul><li>2장에서 search가 불완전 할 수 있는 large input file, long execution traces를 갖는 large applicationd에 대한 새로운 search algorithm을 제시하였다.</li><li>3장에서는 SAGE의 구현에 관하여 논의하였다. symbolic execution algorithm 뒤에있는 엔지니어링 선택과 수백만 명령어의 program traces로 확장할 수 있는 key optimization techniques을 설명한다.</li><li>4장은 SAGE를 사용한 경험에 대하여 설명하고 있다. 발견한 결함의 예를 들고 다양한 실험의 결과에 대해서 논의하였다.</li></ul><h1 id=2-a-white-box-fuzzing-algorithm>2. A White Box Fuzzing Algorithm<a hidden class=anchor aria-hidden=true href=#2-a-white-box-fuzzing-algorithm>#</a></h1><h2 id=21-background-dynamic-test-generation>2.1 Background: Dynamic Test Generation<a hidden class=anchor aria-hidden=true href=#21-background-dynamic-test-generation>#</a></h2><p>다음 프로그램에서 논의해 보자</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>top</span> <span class=p>(</span><span class=kt>char</span> <span class=n>input</span><span class=p>[</span><span class=mi>4</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cnt</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>==</span><span class=sc>&#39;b&#39;</span><span class=p>)</span> <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>==</span><span class=sc>&#39;a&#39;</span><span class=p>)</span> <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>==</span><span class=sc>&#39;d&#39;</span><span class=p>)</span> <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>input</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=o>==</span><span class=sc>&#39;!&#39;</span><span class=p>)</span> <span class=n>cnt</span><span class=o>++</span><span class=p>;;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cnt</span><span class=o>&gt;=</span><span class=mi>3</span><span class=p>)</span> <span class=nf>abort</span><span class=p>();</span> <span class=c1>//error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>abort가 발생할 조건을 random testing(blackbox fuzzing)으로 찾을 확률은 5/2^(8*4)정도이다. 이는 random testing의 전형적인 문제로 프로그램의 가능한 모든 execution path로 이끌어낼 input을 생성하기 어렵다.</p><p>반면 whitebox dynamic test generation은 이 프로그램의 오류를 쉽게 찾을 수 있다. 일부 initial input을 통하여 프로그램을 실행하여 실행 도중 분기문에서의 족너으로부터 입력에 대한 제약을 수집하기 위해 dynamic symbolic execution을 수행하여 constraint solver를 통하여 이전의 입력에 변형을 주어 다음 실행의 새로운 branch를 찾도록 한다.</p><p>이 과정은 주어진 프로그램 statement나 path가 실행되거나 프로그램의 모든(많은) 실행 가능한 path가 실행될때까지 반복된다.</p><p>위의 예시를 가정하면 우리는 초기 4개의 문자열 good을 가지고 함수 top을 실행한다 (경로 ρ). Figure 2는 top에 대한 모든 실행 가능한 program path의 집합을 보여준다. 가장 왼쪽 경로는 &lsquo;good&rsquo;에 대한 프로그램의 첫번째 실행을 나타내며 프로그램 내의 모든 if문의 else에 해당하는 경로에 해당한다. leaf의 숫자들은 0은 cnt의 값을 나타내고 있다.</p><p><img loading=lazy src=./../../image/paper_2_Figure2.png alt=figure2></p><p>normal execution과 함께 symbolic execution은 조건문이 어떻게 평가되는지에 따라 다음과 같은 condition을 수집한다.</p><pre><code>i_0≠b, i_1≠a, i_2≠d, i_3≠!
(i_0는 input[0]의 memory location의 값을 나타내는 symbolic variable)
</code></pre><p>다음 pathconstraint에 대해서 생각해보자</p><pre><code>φ_ρ = &lt;i_0≠b, i_1≠a, i_2≠d, i_3≠!&gt;
</code></pre><p>이는 input vector의 equivalant class이다. 즉, 방금 실행된 path로 실행되는 모든 input vector이다. 프로그램을 다른 equivalant class로 실행하려면 현제 path constraint 하나를 부정하여 다른 path로 실행할 수 있다.</p><pre><code>ex) φ = &lt;i_0≠b, i_1≠a, i_2≠d, i_3=!&gt;
</code></pre><p>이 path constraint의 해는 goo! 이다. 이를 실행하게 된다면 Figure2에서 왼쪽에서 두번째에 있는 path가 실행 된다. 이과정을 반복함으로 이 프로그램에서 가능한 모든 16가지 path를 실행할 수 있다.</p><p>이 탐색이 depth-first order로 실행된다면 Figure의 왼쪽에서 오른쪽으로 탐색된다. 그러면 cnt==3인 첫 오류는 8번째 실행에서 발생하고 9번째 실행 후에 full branch/block coverage에 도달한다.</p><h2 id=22-limitations>2.2 Limitations<a hidden class=anchor aria-hidden=true href=#22-limitations>#</a></h2><p>위에서 간략하게 소개된 Systematic dynamic test generation에는 두가지 한계가 존재한다.</p><h3 id=221-path-explosion>2.2.1 Path explosion<a hidden class=anchor aria-hidden=true href=#221-path-explosion>#</a></h3><p>모든 실행 가능한 path를 실행하는것은 실제 대규모 프로그램에 대해서 확장성이 없다. path explosion은 dynamic test generation 을 compositionally하게 수행하면서 완하할 수 있다.</p><p>이는 함수를 독립적으로 테스팅하고 테스트 결과를 함수 입력전제조건과 출력 후 조건을 사용하여 function summaries하고 high-level function을 테스팅할때 이러한 summaries를 제사용 함으로서 이루어진다.</p><p>software testing에서 summaries가 유용해 보이지만 수백만 가지 명령어를 가진 large application에 대해서 full path coverage를 도달하기엔 한계가 존재한다.</p><h3 id=222-imperfect-symbolic-execution>2.2.2 Imperfect symbolic execution<a hidden class=anchor aria-hidden=true href=#222-imperfect-symbolic-execution>#</a></h3><p>large program에 대한 symbolic execution은 복잡한 program statements(포인터 조작, 산술연산 등)과 운영체제, 라이브러리 함수 호출로 인하여 정확하게 추론하기 어렵거나 불가능하여 정밀도가 떨어질 수 있다. 즉 합리적인 비용으로 정밀도를 가지고 symbolically precision하는것은 어렵다.</p><p>symbolic execution이 불가능할때 concrete한 값을 사용하여 constraint를 단순화 하고 단순화된 부분적 symbolic execution을 수행할 수 있다.</p><p>주어진 input vector에 대한 symbolic execution으로 예측된 프로그램 path와 실제 실행된 path가 일치하지 않을때 divergence가 발생하였다고 한다.</p><p>divergence은 예측된 path를 bit vector(각 조건분기 결과에 대한 한 비트)로 기록하고 이후 실제로 해당 path가 수행되어있는지 확인함으로 감지할 수 있다.</p><h2 id=23-generational-search>2.3 Generational Search<a hidden class=anchor aria-hidden=true href=#23-generational-search>#</a></h2><p>이러한 실용적 한계를 해결하기위하여 새로운 search algorithm을 소개한다. 이 알고리즘은 다음과 같은 주요 특징을 가지고 있다.</p><ul><li>대규모 입력(수천개의 symbolic variable)을 사용하고 매우 깊은 path(수백만개의 명렁어)를 가진 large application의 state space를 체계적이고 부분적으로 탐색하도록 설계되었다.</li><li>search 과정에서 중복을 피하며 각 symbolic execution(long, expensive)에서 생성된 새로운 테스트의 수를 극대한다.</li><li>버그를 빠르게 찾는것을 목표로 가능한 빨리 code coverage를 극대화하기 위한 heuristic을 사용한다.</li><li>divergence가 발생할때 recover할 수 있고 계속 진행된다.</li></ul><p>이 새로운 search algorithm은 아래 두 코드로 제시된다. 먼저 Search함수는 standard한 과정이다.</p><pre><code>1. 초기 inputSeed를 workList에 넣는다. 
2. 프로그램을 실행하여 bug가 감지되었는지 확인한다.
3. workList에서 Input 하나 선택하고 ExpandExecution을 통하여 새로운 childInputs을 생성한다.
4. childInput의 각각에 대해 프로그램을 실행하고 오류를 확인하고 점수를 계산한다.
5. workList에 이를 추가한다.
</code></pre><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>Search</span><span class=p>(</span><span class=n>inputSeed</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>inputSeed</span><span class=p>.</span><span class=n>bound</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>workList</span> <span class=o>=</span> <span class=p>{</span><span class=n>inputSeed</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>Run</span><span class=o>&amp;</span><span class=nf>Check</span><span class=p>(</span><span class=n>inputSeed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>workList</span> <span class=n>not</span> <span class=n>empty</span><span class=p>)</span> <span class=p>{</span><span class=c1>//new children
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>input</span> <span class=o>=</span> <span class=nf>PickFirstItem</span><span class=p>(</span><span class=n>workList</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>childInputs</span> <span class=o>=</span> <span class=nf>ExpandExecution</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>childInputs</span> <span class=n>not</span> <span class=n>empty</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>newInput</span> <span class=o>=</span> <span class=nf>PickOneItem</span><span class=p>(</span><span class=n>childInputs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>Run</span><span class=o>&amp;</span><span class=nf>Check</span><span class=p>(</span><span class=n>newInput</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>Score</span><span class=p>(</span><span class=n>newInput</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>workList</span> <span class=o>=</span> <span class=n>workList</span> <span class=o>+</span> <span class=n>newInput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘에서 주요한 부분은 아래코드와 같이 childInput을 확장하는 방식에 있다. ExpandExecution은 아래와 같이 동작한다.</p><pre><code>1. 해당 입력으로 symbolic excution를 통하여 path constraint (PC)를 생성한다.
2. not(PC[j])와 PC[0..(j-1)]이 해 I가 존재하는지 확인한다. 
3. 해가 존재한다면 해를 이용하여 input을 업데이트한다.
4. 새로운 input은 evalutaion을 위하여 저장한다.
</code></pre><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=nf>ExpandExecution</span><span class=p>(</span><span class=n>input</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>childInputs</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=c1>// symbolically execute (program,input)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PC</span> <span class=o>=</span> <span class=nf>ComputePathConstraint</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=n>input</span><span class=p>.</span><span class=n>bound</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=o>|</span><span class=n>PC</span><span class=o>|</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span> 
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>((</span><span class=n>PC</span><span class=p>[</span><span class=mf>0.</span><span class=p>.(</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>)]</span> <span class=n>and</span> <span class=nf>not</span><span class=p>(</span><span class=n>PC</span><span class=p>[</span><span class=n>j</span><span class=p>]))</span><span class=n>has</span> <span class=n>a</span> <span class=n>solution</span> <span class=n>I</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>newInput</span> <span class=o>=</span> <span class=n>input</span> <span class=o>+</span> <span class=n>I</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>newInput</span><span class=p>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>childInputs</span> <span class=o>=</span> <span class=n>childInputs</span> <span class=o>+</span> <span class=n>newInput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>childInputs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>즉 inputSeed와 PC로 시작하여 새로운 search alogrithm은 PC의 모든 constraint를 확장하려고 시도할것이다. DFS의 경우 마지막 constraint를, BFS의 경우 첫번째 constraint를 확장하는것과 대비된다.</p><p>또한 child sub-search가 중복 탐색하는것을 방지하기위하여 bound 매개변수를 사용하여 sub-search가 parent로부터 시작된 분기로 돌아가는것을 제한한다.</p><p>각 실행이 많은 child로 확장되기 때문에 이러한 검색 순서를 generational search 라고 한다.</p><p>다시 top에 대해 고려해 본다면 초기 입력이 good이라고 가정하였을때 Figure 2의 tree에서 가장 왼쪽 path는 그 입력에 대한 첫번째 실행을 의미한다.</p><p>이 parent execution에서 generational search는 4개의 first-generation child를 생성하는데 이는 leaf에 1로 기록된 4개의 path에 해당한다. 실제로 이 path들은 parent의 path constraint중 하나의 constraint를 부정하는것에 해당한다.</p><p>위 코드의 과정을 통하여 6개의 second-generation child를 생성할 수 있다. 이 과정을 반복하여 top 함수의 모든 실행 가능한 execution path를 한번씩 생성할 수 있다. 또한 cnt의 값은 generation number을 나타낸다.</p><p>ExpandExecution은 현재 path constraint에서 하나만 확장하는 대신 bound 안의 모든 constraint를 확장하기 때문에 각 symbolic execution에서 생성된 새로운 테스트 input의 수를 극대화 한다.</p><p>이 최적화는 top과 같은 작은 프로그램의 모든 execution path를 탐색하는데는 중요하지 않을 수 있지만 symbolic execution이 오랜 시간 걸리는 경우(모든 path를 실행하는것이 불가능한 large application)에는 중요하다. 3장에서 이에대해 더 자세히 논의되고 4장에서 관련된 실험을 통해 설명한다.</p><p>이 시나리오에서 initial input으로 수행된 첫번째 symbolic execution을 최대한 이용하고 first-generation child를 체계적으로 탐색하고자 한다. 이검색 전략은 initial input이 잘 형성되어 있을때 가장 잘 작동한다.</p><p>실제로 프로그램 코드의 더 많은 부분을 실행할 가능성이 더 높아지고 따라서 더 많은 constraint를 부어할 수 있으며 그 결과 더 많은 child가 생성된다. 이는 4장에서 실험을 통해 보여진다.</p><p>initial input에 대한 중요성은 전통적인 blackbox fuzz testing에서 수행하는것과 유사하며 이때문에 이러한 검색 기법을 whitebox fuzzing라고 한다.</p><p>첫번째 parent execution의 child를 확장하는것은 빠르게 block covarage를 극대화 하는 heuristic를 사용하여 우선순위를 정하여 더 빠르게 더 많은 bug를 찾을 수 있다.</p><p>Search의 Score함수는 newInput을 실행하여 이전 모든 실행과 비교했을때 얻은 incremental block coverage를 계산한다.</p><p>예를들어 100개의 새로운 block을 만드는 newInput에는 100점을 할당한다.</p><p>이후 newInput은 점수에 따라 workList에 삽입되며 높은 점수를 가진 항목이 List의 가장 앞에 배치된다. 즉 모든 자식들은 generation number와 관련없이 서로 경쟁한다.</p><p>우리의 block coverage heuristic은 EXE의 Best-First Search와 관련있다. 하지만 전체 검색 전략은 다르다.
EXE는 block coverage heuristic을 사용하지만 다음 child 를 탐색할때 DFS를 사용하는 반면 우리는 generational serach를 사용하여 모든 child를 테스트한다. workList에서 가장 좋은 것을 선택하기 전에 점수를 부여한다.</p><p>Score 함수로 계산된 block coverage heuristic은 divergent를 처리하는데도 도움이 된다. 하나의 divergent는 검색의 완전성을 손상하지만 매우 큰 검색 공간에서는 검색이 불완전할 수 밖에 없으므로 주요 문제가 되진 않는다. 하지만 divergent가 발생한다면 검색이 진행되지 않는다.</p><p>예를 들어서 path P에서 이전 탐색된 경로 P&rsquo;로 divergence하는 경우 DFS는 P&rsquo;과 P사이에 영원히 순환한다. 반면 우리의 generational search는 dievergence를 허용하고 이러한 pathological 상황에서 회복할 수 있다.</p><p>실제로 각 실행은 DFS처럼 많은 child를 생성하며, 만약 child P가 이전 실행 P&rsquo;으로 divergent한다면 p는 점수가 0이되어 workList의 끝에 배치되므로 정상적인(non-divergent) child의 확장에 방해를 주지 않는다. 또한 divergence은 4장에서 다룰 우리의 알고리즘의 중요한 기능이다.</p><p>마지막으로 generational search는 병렬화 하기 쉽다. child를 독립적으로 확인하고 점수를 부여할 수 있다.</p><h1 id=3-the-sage-system>3. The SAGE System<a hidden class=anchor aria-hidden=true href=#3-the-sage-system>#</a></h1><p>SAGE(Scalable, Automated, Guided Execution)은 파일에서 읽은 바이트를 symbolic input으로 취급하여 windows에서 실행되는 모든 파일 읽기 프로그램을 테스트할 수 있다.</p><p>SAGE의 또 다른 혁신은 symbolic execution을 수행할때 x86 Binary level에서 trace할 수 있다는 것이다.</p><p>이 섹션은 SGAE의 설계 선택을 정당화 할 수 있는 논리를 제시한다.</p><h2 id=31-system-architecture>3.1 System Architecture<a hidden class=anchor aria-hidden=true href=#31-system-architecture>#</a></h2><p>SAGE는 4가지 유형의 작업을 반복하며 generational serach를 수행한다.</p><h3 id=311-tester>3.1.1 Tester<a hidden class=anchor aria-hidden=true href=#311-tester>#</a></h3><p>Tester는 testinput으로 프로그램을 실행하여 access violation exceptions과 extreme memory consumption등 비정상적인 이벤트를 찾는 Run&amp;Check를 구현한다. Tester가 오류를 감지하면 testcase를 저장하고 4장에 나오는 방법대로 분류를 수행한다.</p><h3 id=312-tracer>3.1.2 Tracer<a hidden class=anchor aria-hidden=true href=#312-tracer>#</a></h3><p>Tracer는 동힐한 input으로 다시 실행하여 프로그램이 실행되지 않을때 확인하기 위한 로그를 생성하고 저장한다. 이 작업은 <em>iDNA framework</em>를 사용하여 machine-instruction level에서의 execution traces를 수집한다.</p><h3 id=313-coveragecollector>3.1.3 CoverageCollector<a hidden class=anchor aria-hidden=true href=#313-coveragecollector>#</a></h3><p>기록된 로그 재생하여 어떤 basic block이 실행되었는지 계산한다. SAGE는 이 정보를 사용하여 Score 함수를 구현한다.</p><h3 id=314-symbolicexecutor>3.1.4 SymbolicExecutor<a hidden class=anchor aria-hidden=true href=#314-symbolicexecutor>#</a></h3><p>기록된 로그를 다시 재생하여 입력관련 constraint를 수집하고 constraint solver <em>Disolver</em>를 사용하여 새로운 입력을 생성하고 2.3절의 ExpandExecution을 구현한다.</p><h3 id=315-truescan>3.1.5 TrueScan<a hidden class=anchor aria-hidden=true href=#315-truescan>#</a></h3><p>CoverageCollector와 SymbolicExecutor는 <em>iDNA</em>에 의해 생성된 trace file을 사용하고 기록된 실행을 가상으로 재실행하는 trace replay framework <em>TruScan</em>위에 구축하였다.</p><p><em>TruScan</em>은 symbolic execution을 단순화 하는 다음과 같은 기능을 제공한다.</p><ul><li>명령어 디코딩</li><li>symbolic information에 대한 인터페이스 제공</li><li>다양한 입출력 시스템 호출 모니터링</li><li>heap, stack frame 할당 추적</li><li>프로그램 구조를 통한 data flow tracking</li></ul><h2 id=32-trace-based-x86-constraint-generation>3.2 Trace-based x86 Constraint Generation<a hidden class=anchor aria-hidden=true href=#32-trace-based-x86-constraint-generation>#</a></h2><p>SAGE의 constraint generation은 dynamical test generation과 두가지 방면에서 차이가 있다.</p><h3 id=321-machine-code-based-approach>3.2.1 Machine-Code-Based Approach<a hidden class=anchor aria-hidden=true href=#321-machine-code-based-approach>#</a></h3><h4 id=multitude-of-languages-and-build-processes>Multitude of languages and build processes<a hidden class=anchor aria-hidden=true href=#multitude-of-languages-and-build-processes>#</a></h4><p>source-based 계측은 테스트 대상 프로그램에 사용된 특정 언어, 컴파일러, 빌드 프로세스를 지원해야한다. 따라서 새로운 언어, 컴파일러, 빌드 도구에 계측을 적용하는데는 많은 초기비용이 든다. 다양한 빌드 프로세스와 호환되지 않는 컴파일러 버전으로 개발된 많은 application을 cover하는 것은 쉽지 않다.</p><p>반면 machine-code-based symbolic execution engine은 복잡하지만 아키텍처마다 한번만 구현하면 된다.</p><h4 id=compiler-and-post-build-transformations>Compiler and post-build transformations<a hidden class=anchor aria-hidden=true href=#compiler-and-post-build-transformations>#</a></h4><p>실제로 출시된 binary code에서 symbolic execution을 수행함으로서 SAGE는 대상 프로그램 뿐만 아니라 컴파일, 후처리 과정에서 발생할 수 있는 버그를 포착할 수 있게 한다.</p><p>예를들어 코드 난독화 도구나 base block transformer와 같은 도구는 source code와 bianary code사이으 미묘한 차이를 발생시킬 수 있다.</p><h4 id=unavailability-of-source>Unavailability of source<a hidden class=anchor aria-hidden=true href=#unavailability-of-source>#</a></h4><p>source code를 얻기 어려울 수 있다. source-based 계측은 self-modifying, JITed(Just-In-Time compiled) 코드에 대해서 어려울 수 있으나 SAGE는 machine code level에서 작업함으로 이러한 문제를 해결할 수 있다.</p><p>물론 source code에는 machine code에서 즉시 보이지 않는 타입과 구조에 대한 정보가 있지만 SAGE의 path search에는 이 정보가 필요하지 않다.</p><h3 id=322-offline-trace-based-constraint-generation>3.2.2 Offline Trace-Based Constraint Generation<a hidden class=anchor aria-hidden=true href=#322-offline-trace-based-constraint-generation>#</a></h3><p>SAGE는 online 계측 대신 offline trace기반의 constraint generation을 사용한다. online generation은 프로그램이 실행될때 정적으로 주입된 계측 코드나 <em>Nirvana</em>, <em>Valgrind</em>와 같은 static binary 계측도구를 이용하여 constraint가 생성된다.</p><p>SAGE가 offline trace-based constraint generation을 사용하는것은 두가지 이유 때문이다.</p><ol><li>프로그램은 OS에 의하여 보호되거나 난독화될 수 있는 binary 요소들을 포함할 수 있어 계측된 버전으로 교체하기 어려울 수 있다.</li><li>프로그램의 비결정성은 online constraint generation의 디버깅을 어렵게 만든다. constraint generation engine에 문제가 발생한다면 이를 재현하기 어려울 것이기 때문이다. SAGE에서 constraint generation은 실행시간 동안 모든 비결정적 이벤트의 결과를 기록하는 execution trace에서 작동하기에 완전히 결정론적이다.</li></ol><h2 id=33-constraint-generation>3.3 Constraint Generation<a hidden class=anchor aria-hidden=true href=#33-constraint-generation>#</a></h2><h3 id=symbolic-tag>Symbolic Tag<a hidden class=anchor aria-hidden=true href=#symbolic-tag>#</a></h3><p>SAGE는 프로그램의 concrete and symbolic state를 각 메모리 위치와 레지스터를 byte-sized value와 symbolic tag를 각각 연결하여 한쌍으로 저장한다.
symbolic tag는 input vlaue나 어떤 값의 함수를 나타내는 표현식이다.</p><p>SAGE는 여러 종류의 tag를 지원한다.</p><ul><li>input(m) input의 m번째 바이트</li><li>c : 상수</li><li>t1 op t2 : t1과 t2의 연산(op)값</li><li>sequence tag &lt;t0&mldr;tn> : t0&mldr;tn에서 내는 byte-size값을 그룹화 하여 얻은 word, double-word 크기의 값</li><li>subtag (t,i) : word, double-word 크기의 t중 i번째 byte의 값</li></ul><p>SAGE는 symbolic pointer dereference를 추론하지 않는다.
SAGE는 비 상수 symbolic tag마다 새로운 symbolic variable을 정의한다. SAGE가 프로그램 trace를 재생할때 방문한 각 명령어의 의미에 따라 concrete and symbolic 저장소를 업데이트한다.</p><p>SAGE는 symbolic tag propagation을 수행하는것 이외에도 input vlaue에 대한 constraint를 생성한다. constraint는 symbolic variable간의 관계를 나타낸다.</p><p>예를 들어 input(4)에 해당하는 변수 x가 주어졌을때 x&lt;10은 입력의 다섯번째 바이트가 10보다 크다는 뜻이다.</p><p>input에 의존하는 conditional jump를 만나면 분기의 결과를 모델링하는 constraint를 생성하고 지금까지 만난 contraint로 구성된 path constraint에 추가한다.</p><h3 id=tracking-symbolic-tag-and-collecting-constraints>Tracking Symbolic Tag and Collecting Constraints<a hidden class=anchor aria-hidden=true href=#tracking-symbolic-tag-and-collecting-constraints>#</a></h3><p>다음은 symbolic tag를 추적하고 constraint를 수집하는 과정을 보여준다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># read 10 byte file into a
</span></span><span class=line><span class=cl># buffer beginning at address 1000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mov ebx, 1005
</span></span><span class=line><span class=cl>mov al, byte [ebx]
</span></span><span class=line><span class=cl>dec al                  # Decrement al
</span></span><span class=line><span class=cl>jz LabelForIfZero       # Jump if al == 0
</span></span></code></pre></td></tr></table></div></div><ol><li>10byte의 파일을 읽어서 1000번지 주소에 저장한다.
이 명령어를 실행함에 따라 SAGE는 주소 1000~1009를 symbolic tag input(0)~input(9)와 연결하여 symbolic 저장소를 업데이트한다.</li><li>mov 명령어는 6번째 입력 바이트를 al레즈스터로 로드한다. 명령어를 재생한 후 SAGE는 al을 input(5)dp mapping하는것으로 symbolic 저장소를 업데이트한다.</li><li>마지막 두 명령언s al을 감소하고 감소된 값이 0이면 LabelForIfZero로 conditional jump를 수행한다. 분기의 결과에 따라 두가지 constraint중 하나를 추가한다. (t=input(5)-1 -> t=0 or t=1 추가)</li></ol><h3 id=conditional-jump>Conditional Jump<a hidden class=anchor aria-hidden=true href=#conditional-jump>#</a></h3><p>이는 x86 machine instruction 으로부터 constraint를 형성하는데 있어서 주요 문제중 하나로 이어진다. conditional expression에서 비교과 이루어질때 그것이 어떻게 conditional jump에 사용되는지 알 수 없다.</p><h3 id=eflag>EFLAG<a hidden class=anchor aria-hidden=true href=#eflag>#</a></h3><p>프로세서에는 CF,SF,AF,PF,OF,ZF와 같은 EFLAG가 존재한다.
EFLAG는 다양한 명령어의 결과에 따라 결정된다 예를들어 CF는 산술연산간 carry가 발생하였다면 1로 설정된다.</p><p>EFLAG의 처리를 위해 SAGE는 n비트의 값으로 <em>f</em>0&mldr;<em>f</em>n-1에 따라 설정된 비트를 나타네는 bit vector tag &lt;<em>f</em>0&mldr;<em>f</em>n-1>을 정의한다.</p><p>위의 예시에서 SGAE가 dec명령어를 실행할떄 al과 EFLAG에 대한 symbolic 저장소의 mapping을 업데이트 한다(t=input(5)-1, CF,ZF).</p><h3 id=casting>Casting<a hidden class=anchor aria-hidden=true href=#casting>#</a></h3><p>x86에서 자자주 사용되는 관행은 byte, word, double word간의 casting이다. 테스트 대상 프로그램의 코드에 명시적인 casting이 포함되지 않더라도 atol, malloc, memcpy등 run-time library에서 casting을 수행하는 함수를 호출하게 된다.</p><p>SAGE는 subtag와 sequence tag를 이용하여 casting의 정확한 처리를 구현한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov ch, byte [...]
</span></span><span class=line><span class=cl>mov cl, byte [...]
</span></span><span class=line><span class=cl>inc cx              # Increment cx
</span></span></code></pre></td></tr></table></div></div><p>두개의 명령어가 symbolic tag t1,t2와 관련된 주소를 읽을때 SAGE가 명령어를 재생할때 symbolic 저장소는 cl->t1, ch->t2으로 mapping을 업데이트한다. 다음 명령어는 cx를 증가한다 cx는 16bit 레지스터로 cl과 ch를 포함한다.</p><p>증가하기 전에 cx의 내용은 &lt;t1,t2>로 표현할 수 있다. 증가한 후 cx는 t=&lt;t1,t2+1>로 표현할 수 있는데 inc를 마무리하기 위하여 SAGE는 symbolic 저장소의 byte크기의 maaping을 cl->subtag(t,0), ch->subtag(t,1)로 업데이트 한다.</p><p>SAGE는 symbolic 저장소를 byte크기로 다음과 같이 인코딩하여 mapping한다.</p><pre><code>x=x'+256*x', where x=t, x'=subtag (t,0), x''=subtag(t,1)
</code></pre><h2 id=34-constraint-optimization>3.4 Constraint Optimization<a hidden class=anchor aria-hidden=true href=#34-constraint-optimization>#</a></h2><h3 id=standard-optimization>Standard Optimization<a hidden class=anchor aria-hidden=true href=#standard-optimization>#</a></h3><p>SAGE의 constraint generation의 속도와 메모리 사용을 향상시키기 위하여 몇가지 최적화 기법을 사용한다.</p><pre><code>1. Tag Caching : 구조적으로 동등한 tag들이 동일한 physical object에 mapping되도록 한다.
2. unrelated constraint elimination : 부정된 constraint와 symbolic variable을 공유하지 않는 constraint를 제거함으로서 constraint solver의 크기를 줄인다.
3. local constraint caching : 이미 path constraint에 추가된 constraint는 건너 뛴다.
4. flip count limit : 특정 명령어에서 생성된 constraint가 몇번 flip가능한 최대 횟수를 설정한다.
5. concretization : 여러 명령을 포함하는 symbolic tag를 concerete value로 줄인다.
</code></pre><p>이러한 최적화는 dynamical test generation에서 표준적인 방법이다. 이 섹션의 나머지 부분은 structured-file parsing application에 대한 최적화에사용되는 constraint subsumption(가정)에 대해서 설명한다.</p><h3 id=constraint-subsumption>Constraint subsumption<a hidden class=anchor aria-hidden=true href=#constraint-subsumption>#</a></h3><p>constraint subsumption은 주어진 분기 명령에서 셍성된 constraint를 추적하여 새로운 constaint <em>f</em>가 생성될때 SAGE는 빠른 syntactic check를 통하여 <em>f</em> 다른 constaint를 함축하거나 같은 명령에서 생성된 다른 constraint에 의해 함축되는지 판단하고 함축된다면 path constraint에서 제거된다.</p><p>subsumption 최적화는 다양한 image parser및 미디어 플레이어와 같은 structured file을 처리하는 많은 프로그램에 중요한 영향을 미친다.</p><h3 id=constant-folding>Constant Folding<a hidden class=anchor aria-hidden=true href=#constant-folding>#</a></h3><p>다음과 같은 예제를 확인해보자</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov cl, byte [...]
</span></span><span class=line><span class=cl>dec cl              # Decrement cl
</span></span><span class=line><span class=cl>ja 2                # Jump if cl &gt; 0
</span></span></code></pre></td></tr></table></div></div><p>이 코드는 cl에 바이트를 로드하고 0이 될때까지 loop에서 감소시킨다. mov 명령에 의해 읽힌 바이트가 symbolic tag t0에 매핑된다고 하자. 3.3절에서 설명한 알고리즘은 다음과 t1>0,&mldr;,tk-1>0과 tk&lt;=0을 생성한다. 여기서 k는 로드된 바이트의 구체적인 값이고 ti+1=ti-1이다.</p><p>반복마다 새로운 constraint와 symbolic tag를 생성하기 때문에 메모리는 루프 반복횟수에 선형적이다.</p><p>여기서 subsumption을 사용한다면 첫 k-2개의 constraint는 다음 constraint에 의해 축약되기 때문에 제거할 수 있다. 우리는 symbolic tag는 선형적인 수로 유지해야 한다. 왜냐하면 각 tag는 이전 tag에 대한 조건으로 정의되기 때문이다.</p><p>이를 상수 크기의 공간으로 동작을 하기 위해서는 tag 생성중 constand folding을 수행해야한다. : (t-c)-1=t-(c+1)</p><p>constraint subsumption과 constant folding을 적용한다면 다음 두가지 constraint를 갖는 path constraint가 된다.</p><pre><code>t0-(k-1)&gt;0 and t0 -k &lt;=0
</code></pre><h3 id=sequence-tag-simplification>sequence tag simplification<a hidden class=anchor aria-hidden=true href=#sequence-tag-simplification>#</a></h3><p>만약 multi-byte에 대해서는 또 다른 문제가 있다 다음 예제를 보자 위 예시와 비슷하지만 cl이 아닌 cx로 대체되었다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mov cx, word [...]
</span></span><span class=line><span class=cl>dec cx              # Decrement cx
</span></span><span class=line><span class=cl>ja 2                # Jump if cx &gt; 0
</span></span></code></pre></td></tr></table></div></div><p>mov 명령에 의해 읽힌 두 바이트가 t'0 ,t&rsquo;&lsquo;0에 메핑된다고 가정한다면 다음과같은 constraint를 생성한다</p><pre><code>s1&gt;0,...,sk-1&gt;0 and sk&lt;=0 where si+1 = &lt;t'0,t''0&gt;-1
</code></pre><p>이때 constant folding은 어려워진다. 왜냐하면 각 루프 반복은 syntatically unique하지만 의미적으로는 중복되는 word-size sequence tag이기 때문이다.</p><p>SAGE는 sequence tag simplification을 지원한다. &lt;subtag(t,0), subtag(t,1)>를 t로 재작성하여 동등한 tag를 피하고 constant folding을 지원한다.</p><p>constraint subsumption, constant folding, sequence tag simplification은 위에서 생성된 constraint를 상수공간에서 재생하는것을 보장해 준다.</p><p>이 세가지 방법은 SAGE가 structured-file-parsing application을 효과적으로 fuzzing하도록 한다.</p><h1 id=4-experiments>4. Experiments<a hidden class=anchor aria-hidden=true href=#4-experiments>#</a></h1><p>Sblackbox fuzz에서 놓친 버그를 SAGE가 찾아낸것을 걸명한다. 두 memdia parsing application에서 SAGE의 행동에 대한 더 체계적인 연구룰 추구한다.</p><ul><li>initial inpuy file의 중요성</li><li>generational search vs DFS</li><li>block coverage heuristic의 효과</li></ul><h2 id=41-initial-experiences>4.1 Initial Experiences<a hidden class=anchor aria-hidden=true href=#41-initial-experiences>#</a></h2><h3 id=ms07-017>MS07-017<a hidden class=anchor aria-hidden=true href=#ms07-017>#</a></h3><p>MS는 ANI(애니메이션 커서 파일)을 parsing하는 코드에서 중요한 보안 패치를 발표했다. 이 코드에 대한 광범위한 blackbox fuzz testing을 하였지만 버그를 발견하지 못하였고 기존 static analysis 도구들은 과도한 거짓 false positive 없이 버그를 찾을 수 없었다. 하지만 SAGE는 well-formed ANI file에서 시작하여 몇시간 내에 버그를 드러내는 새로운 input file을 만들어 내었다.</p><p>이 취약점은 ANI parsing code와 관련된 MS05-006에 대한 불완전한 패치로 인하여 생성되었다. 이 버그의 근본 원인은 ANI파일의 <em>anih</em> rdcord 에서 읽은 size parameter에 대한 검증을 못한 것이다. 이 패치는 첫번째 <em>anih</em> record만 확인하였고 파일에 36byte이하의 초기 <em>anih</em> record가 있으면 이후 모든 <em>anih</em> record에 대한 아이콘 로딩 함수가 호출된다. 두번째 이후 recode의 길이가 확인되지 않으므로 memory corruption이 발생할 수 있다.</p><p>testcase는 최소한 두개의 <em>anih</em> record가 필요하다. blackbox fuzz testing이 MS07-017을 발견하지 못한 이유는 testing에 사용된 모든 seed file이 하나의 <em>anih</em> record만을 가지고 있기 때문이다. 물론 blackvox fuzz testing을 위해 여러 testcase를 생성하는 grammar를 사용할 수 있지만 노력이 필요하고 ANI format을 넘어 일반화할 수 없다.</p><p>반면 SAGE는 ANI format에 대한 지식 없이 하나의 <em>anih</em> record를 가진 well-formed ANI 파일에서 시작하여 MS07-017을 생성하는 입력을 생성할 수 있다. seed file은 잘성성된 ANI 파일 라이브러리에서 임의로 생성되었으며 <em>user32.dll</em>을 호출하여 ANI 파일을 parsing하는 작은 test driver을 사용하였다. 아래는 crash test case이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SEED
</span></span><span class=line><span class=cl>RIFF...ACONLIST
</span></span><span class=line><span class=cl>B...INFOINAM....
</span></span><span class=line><span class=cl>3D Blue Alternat
</span></span><span class=line><span class=cl>e v1.1..IART....
</span></span><span class=line><span class=cl>................
</span></span><span class=line><span class=cl>1996..anih$...$.
</span></span><span class=line><span class=cl>................
</span></span><span class=line><span class=cl>................
</span></span><span class=line><span class=cl>..rate..........
</span></span><span class=line><span class=cl>..........seq ..
</span></span><span class=line><span class=cl>................
</span></span><span class=line><span class=cl>..LIST....framic
</span></span><span class=line><span class=cl>on......... ..
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>CRASH
</span></span><span class=line><span class=cl>RIFF...ACONB
</span></span><span class=line><span class=cl>B...INFOINAM....
</span></span><span class=line><span class=cl>3D Blue Alternat
</span></span><span class=line><span class=cl>e v1.1..IART....
</span></span><span class=line><span class=cl>................
</span></span><span class=line><span class=cl>1996..anih$...$.
</span></span><span class=line><span class=cl>................
</span></span><span class=line><span class=cl>................
</span></span><span class=line><span class=cl>..rate..........
</span></span><span class=line><span class=cl>..........seq ..
</span></span><span class=line><span class=cl>................
</span></span><span class=line><span class=cl>..anih....framic
</span></span><span class=line><span class=cl>on......... ..
</span></span></code></pre></td></tr></table></div></div><h3 id=compressed-file-format>Compressed File Format<a hidden class=anchor aria-hidden=true href=#compressed-file-format>#</a></h3><p>SAGE의 alpha 버전을 이용하여 압축 파일 형식을 처리하는 코드에서 버그를 찾도록 하였다. 이 parsing code는 blackbox fuzzing tool을 이용하여 테스트 되었지만 SAGE는 다음 두가지 새로운 버그를 찾았다.</p><ul><li>Stack Overflow</li><li>CPU를 100% 사용하게 하는 무한루프</li></ul><h3 id=media-file-parsing>Media File Parsing<a hidden class=anchor aria-hidden=true href=#media-file-parsing>#</a></h3><p>SAGE를 널리 사용되는 4가지 media file format parser에 적용하였다. 이를 Media 1,2,3,4라 하자.
SAGE는 100개의 0x00으로 시작한 seed를 이용하여 각 Media File에서 충돌을 발견하여 9개의 bug reports를 생성하였다.</p><h3 id=office-2007-application>Office 2007 Application<a hidden class=anchor aria-hidden=true href=#office-2007-application>#</a></h3><p>SAGE는 Office 2007의 large application에 대한 crash test case를 생성했다. 이는 NULL포인터 역참조 오류들이다. 이는 SAGE가 large scale의 프로그램에 대해서 성공적임을 보여준다.</p><h3 id=image-parsing>Image Parsing<a hidden class=anchor aria-hidden=true href=#image-parsing>#</a></h3><p>SAGE를 이용하여 media player의 image parsing code를 테스팅하였다. 초기에 충돌을 찾지 못하였지만 내부 도구를 사용하여 SAGE-generated test case를 추적하여 여러 uninitialized value use error를 발견하였다. 이 결과를 재현 가능한 충돌로 확장 가능하였다. 즉 SAGE는 즉시 충돌로 이어지지 않는 심각한 버그를 발견할 수 있었다.</p><h2 id=42-experiment-setup>4.2 Experiment Setup<a hidden class=anchor aria-hidden=true href=#42-experiment-setup>#</a></h2><h3 id=test-plan>Test Plan<a hidden class=anchor aria-hidden=true href=#test-plan>#</a></h3><p>널리 사용되는 Media 1,2 parser에 초점을 맞추었다. Media 1 parser에 대해 test media file liabrary에서 선택된 5개의 well-formed media file로 SAGE를 실행하였다. Media file은 다음과 같은 5개의 &ldquo;bogus&rdquo; 파일로실행하였다.</p><table><thead><tr><th style=text-align:center>bogus</th><th style=text-align:center>contents</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>\x00 * 100</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>\x00 * 800</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>\x00 * 25600</td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>rand * 100</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>rand * 100</td></tr></tbody></table><p>이 10개의 파일에 대하여 10시간씩 SAGE를 실행하였다. 충돌을 찾은 경우 bloc coverage heuristic을 비활성화하고 다시 10시간 실행하였다.</p><p>각 SAGE serach는 heap memory error을 확인하기위하여 <em>AppVerfier</em>를 사용하였다. error가 발생할때마다 <em>AppVerfier</em>는 테스트중인 application에서 crash를 발생시킨다. 이후 crashing test case, seed input에 의해 cover된 block의 수, 검색 과정에 추가된 code block의 수를 수집하였다.</p><h3 id=triage>Triage<a hidden class=anchor aria-hidden=true href=#triage>#</a></h3><p>SAGE는 동일한 버그를 나타내는 많은 test case를 생성할 수 있으므로 crashing file 을 <em>stack hash</em>를 이용하여 &ldquo;bucket"하였다. 이는 오류 발생 명령의 주소를 포함며 동일한 원인으로 인해 다양한 경로로 발생한 버그에 대해서 같은 버그인지 분류하는 역할을 수행한다.</p><h3 id=nondeterminism-in-coverage-results>Nondeterminism in Coverage Results<a hidden class=anchor aria-hidden=true href=#nondeterminism-in-coverage-results>#</a></h3><p>실험의 일부로 test 실행중 cover된 block의 수를 측정하였다. 동일한 초기 프로그램에서 동일한 실행을 하더라도 약간의 다른 initial coverage가 나올 수 있다는것을 관찰하였다. 이는 test application을 사용하는 DLL을 로드하고 초기화하는 과정에서 발생하는 nondeterminisim 때문이라고 생각한다.</p><h2 id=43-results-and-observations>4.3 Results and Observations<a hidden class=anchor aria-hidden=true href=#43-results-and-observations>#</a></h2><p>부록에는 실험 결과의 표가 있다. 여기서 우리는 몇가지 일반적인 관찰사항에 대해서 설명한다. 이러한 관찰사항은 두개의 application에 대한 제한된 샘플 크기에서 얻어진것이므로 주의해서 받아들여야 한다.</p><h3 id=symbolic-execution-is-slow>Symbolic execution is slow<a hidden class=anchor aria-hidden=true href=#symbolic-execution-is-slow>#</a></h3><p>각 검색에서 symbolic execution에 소요된 시간을 측정하였다. symbolic excution에 소요되는 시간이 프로그램 testing이나 tracing 하는것보다 훨씬 더 많이 걸린린다. 예를들어 Media2 검색에서 wtf-3로 실행된 symbolic execution의 평균 실행 시간은 25분 30초이고 testing에 소요된 시간은 몇초이다. 왜냐하면 각 작업은 많은 test case를 생성하였기 때문이다. 하지만 전체 실행 시간은 25%에 불과하다 generational search가 symbolic execution을 효율적으로 활용함을 보여준다.</p><h3 id=generational-search-is-better-than-depth-first-search>Generational search is better than depth-first search<a hidden class=anchor aria-hidden=true href=#generational-search-is-better-than-depth-first-search>#</a></h3><ul><li><p>DFS를 사용하여 execution 하였을때 pathological divergence이 발생하였다. 이것은 path constraint의 AND 연산자를 구체화 하는것에 의해 발생하였다.</p></li><li><p>coverage와 관련하여도 geneartional search에 비해서 더 적은 것을 확인할 수 있었다. DFS가 localized하기 때문이다.반면 generational search의 경우 모든 depth에서 실행 분기를 탐색하여 프로그램의 레이어를 동시에 탐색한다.</p></li><li><p>DFS가 symbolic execution에 더 많은 시간을 소비한다.</p></li></ul><h3 id=divergences-are-common>Divergences are common<a hidden class=anchor aria-hidden=true href=#divergences-are-common>#</a></h3><p>기본적인 test 설정에서 divergence를 측정하지 않았고 몇가지 측정용 test case를 실행하여 diveergence rate를 측정하여따 종종 60%넘기도 하였다. 이는 실험 설정에서 효율성을 위하여 non-linear operation (곱셈 나눗셈, 비트연산)을 구체화 하기 때문일 수 있다. 또한 아직 emulate하지 않은 x86 명령들이 존재하며 pointer의 dereference 에 대한 모델을 만들지 않았기 때문이다.</p><p>symbolic variable을 tracking하는것은 불완전할 수 있읏고 위에 언급한 snondeterministic한 요소를 제어하기 때문이다.</p><p>그럼에도 SAGE의 검색 기술이 divergence를 허용함을 확인할 수 있었다.</p><h3 id=bogus-files-find-few-bugs>Bogus files find few bugs<a hidden class=anchor aria-hidden=true href=#bogus-files-find-few-bugs>#</a></h3><p>우리는 well-formed, bogus seed에서 발생한 crash data를 수집하였다. 각 시드 파일로 발견된 버그는 stack hash에 따라 나타내었다. 이 결과를 살펴보면 well-formed 파일을 initial로 하여야 fuzz testing이 잘 된다는 전통적인 지혜가 whitebox fuzzing에도 적용됨을 확인할 수 있었다.</p><h3 id=different-files-find-different-bugs>Different files find different bugs<a hidden class=anchor aria-hidden=true href=#different-files-find-different-bugs>#</a></h3><p>Media 1,2의 경우 bug를 찾은 well-formed file이 하나가 아니라는 것을 확인할 수 있었다. 각 search가 불완전 하기에 많은 well-formed file을 사용하는것이 중요하다.</p><h3 id=bugs-found-are-shallow>Bugs found are shallow<a hidden class=anchor aria-hidden=true href=#bugs-found-are-shallow>#</a></h3><p>각 seed file에 대하여 최대한 많은 generation을 수집하였다. 그런 다음 충돌이 발생한 버킷중 가장 마지막으로 찾은 generation을 확인하였다. media 1의 경우 4 generation 이내에 모든 버그를 찾았고 최대 generation은 5~7까지 다양하다.</p><p>즉 이러한 검색에서 찾은 대부분의 버그는 shallow하다. 적은 수의 generation에 도달할 수 있다. 이는 작은 generation에서도 확장할 후보 입력이 많고 나중 세대의 많은 테스트의 coverage score가 낮기 때문이다.</p><h3 id=no-clear-correlation-between-coverage-and-crashes>No clear correlation between coverage and crashes<a hidden class=anchor aria-hidden=true href=#no-clear-correlation-between-coverage-and-crashes>#</a></h3><p>coverage 증가가 새로운 버그관련과 관련이 있지만 모든 경우에 일관되게 관찰되지는 않았다.</p><h3 id=effect-of-block-coverage-heuristic>Effect of block coverage heuristic<a hidden class=anchor aria-hidden=true href=#effect-of-block-coverage-heuristic>#</a></h3><p>다음 child를 선택하기위하여 block coverage heuristic을 사용을 한 테스트와 사용하지 않은 실행을 비교해본 결과 사용한 경우가 훨씬 많은 block을 추가함을 확인할 수 있었다.</p><h1 id=5-other-relate-work>5. Other Relate Work<a hidden class=anchor aria-hidden=true href=#5-other-relate-work>#</a></h1><h2 id=input-grammar>Input Grammar<a hidden class=anchor aria-hidden=true href=#input-grammar>#</a></h2><p>최근 fuzz testing에 있어서 많은 개발이 있었다. 하지만 이들은 대부분 가능한 input을 표현하기위한 <em>grammar</em>를 사용하였다. 또한 input을 생성할때 확률적 가중치를 할당하여 random test input generation을 위한 heuristic으로 사용할 수 있다. 이러한 가중치는 가벼운 동적 프로그래밍 계측을 사용하여 수집된 coverage data를 사용하여 자동의로 정의되거나 수정될 수 있다. 이러한 <em>grammar</em>또한 입력 검증 코드에서 흔히 발생하는 함정을 테스트 하기위한 규칙 (긴 문자열 ,NULL값 포함)을 포함 할 수 있다.</p><p>input grammar의 사용은 application-specific knowledge를 사용하고 다른 영역에 비해 특정 input space의 영역을 선호하는 test guideline을 만드는 것을 가능하게 한다. 순수 무작위 테스팅을 통하여 버그를 찾는 확률은 매우 작기 때문에 blackbox fuzzing을 가능하게 하는데 핵심적인 역할을한다. 하지만 grammar를 수동으로 작성하는것은 비용이 많이들고 확장성이 떨어진다.</p><p>하지만 SEGA는 input grammar가 필요 없다. 하지만 주어진 search를 위한 initial seed file을 중요하게 생각한다. 이러한 seed file은 blackbox fuzzing에 사용되는 grammar를 사용하여 생성된다.</p><p>또한 blackbox fuzz가 symbolic execution과 constraint solving의 비용 때문에 whitebox fuzz보다 더 빠른 속도로 새로운 테스트 케이스를 실행한다.
그리고 whitebox fuzzing의 symbolic executinon의 부정확성 때문에 whitebox fuzzing에서 발견하지 못한 새로운 path를 찾을 수 있다.</p><h2 id=generational-search-algorithm>Generational Search Algorithm<a hidden class=anchor aria-hidden=true href=#generational-search-algorithm>#</a></h2><p>이 논문의 접근 방식은 dynamic test generation 작업에 기반을 두고 있다. 주요 차이점은 heuristic을 사용하는 generational serach algorithm을 사용하고 large application을 테스트 한다는 것이다. trace-based x86-binary symbolic excution에 의해 가능하다. 이러한 차이점으로 dynamical test generation 보다 더 많은 버그를 발견할 수 있었다.</p><p>SAGE은 dynamic taint analysis를 사용하는 도구와도 다르다. 이러한 도구는 false positive 가 발생할 수 있지만 symbolic execution은 static analysis의 핵심 구성 요소이다.</p><p>static analysis 일반적으로 dynamic analysis보다 효율적이지만 정확도가 떨어지면 이둘은 상호보완적이다. static test generation은 특정 프로그램 경로를 따라가기위해 input vlaue를 계산하려고 시도하지만 프로그램을 실제로 실행하진 않는다. 반면 dynamic test generation은 추가적인 runtime information이 있기에 더 일반적이고 강력하다.</p><h1 id=6-conclusion>6. Conclusion<a hidden class=anchor aria-hidden=true href=#6-conclusion>#</a></h1><p>우리는 dynamic test generation을 위한 새로운 탐색 알고리즘인 generational serach 를 도입하였다. 이 알고리즘은 divergences를 허용하고 비용이 많이드는 symbolic execution 을 더 잘 사용한다.</p><p>SAGE는 이 알고리즘을 통하여 Windows에서 실행되는 다양한 x86코드에서 버글르 찾아내었다.</p><p>SAGE의 행동을 잘 이해하기위한 실험에 있어서 well-formed input file을 사용하는것이 버그를 찾는것에 있어서 중요하다는걸 발견하였다.</p><p>또한 탐색된 세대의 수가 block coverage보다 중요하다는 것을 알게되엇다. 특히 발견된 대부분의 버그들은 낮은 세대에서 발견되었다.</p><p>이러한 결과는 제한된 크기의 셈플에서 나온것이므로 신중하게 다루어야 하지만 새로운 탐색 전략을 제시한다.</p><p>정해진 시간동안 실행하는 대신 초기 seed file에서 작은 수의 세대를 탐색하고 이 test case가 소진되면 새로운 seed file로 넘어갈 수 있다.</p><p>이러한 전략은 발견한 버그의 다른 경로를 찾는 &ldquo;tail"을 잘라내고 같은 시간에 더 많은 고유한 버그를 찾을 수 있을지도 모른다.</p><p>향후 연구에서 이 탐색 방법을 실행하여 우리의 block-coverage hueristic을 다른 seed file에 적용하여 동일한 코드를 여러번 탐색하는것을 피해야 한다.</p><p>중요한 부분은 code coverage만 사용할때보다 depth와 code coverage의 좋바이 더 나은 지표인지 확인해야 한다.</p><h1 id=7-의문점>7. 의문점<a hidden class=anchor aria-hidden=true href=#7-의문점>#</a></h1><ul><li>후속 연구</li><li>소스코드를 볼 수 있을까?</li><li>유망한 (workList 상단) test case가 꼭 input을 bug를 trigger할 가능성이 높은 input일까? score봐야할지도?</li><li></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://246p.github.io/tags/2024/>2024</a></li><li><a href=https://246p.github.io/tags/%EB%85%BC%EB%AC%B8/>논문</a></li><li><a href=https://246p.github.io/tags/%ED%95%99%EB%B6%80%EC%97%B0%EA%B5%AC%EC%83%9D/>학부연구생</a></li><li><a href=https://246p.github.io/tags/whitebox-fuzzing/>whitebox fuzzing</a></li><li><a href=https://246p.github.io/tags/symbolic-execution/>symbolic execution</a></li></ul><nav class=paginav><a class=next href=https://246p.github.io/blog/paper_1/><span class=title>Next »</span><br><span>1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://246p.github.io/>Junlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>