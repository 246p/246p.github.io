<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>3 1 | Junlog</title>
<meta name=keywords content="Tag"><meta name=description content="Context-free grammar CFG : defined with a set of production rules ex) E -> E + E E -> E * E E -> id E -> num
CFG : Derivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps
CFG : Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)"><meta name=author content="Kim-Minjoon"><link rel=canonical href=https://246p.github.io/blog/3-1/><meta name=google-site-verification content="GTM-524D7HPF"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="3 1"><meta property="og:description" content="Context-free grammar CFG : defined with a set of production rules ex) E -> E + E E -> E * E E -> id E -> num
CFG : Derivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps
CFG : Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)"><meta property="og:type" content="article"><meta property="og:url" content="https://246p.github.io/blog/3-1/"><meta property="og:image" content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-01-10T17:47:45+09:00"><meta property="article:modified_time" content="2024-01-10T17:47:45+09:00"><meta property="og:site_name" content="Junlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta name=twitter:title content="3 1"><meta name=twitter:description content="Context-free grammar CFG : defined with a set of production rules ex) E -> E + E E -> E * E E -> id E -> num
CFG : Derivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps
CFG : Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://246p.github.io/post/"},{"@type":"ListItem","position":2,"name":"3 1","item":"https://246p.github.io/blog/3-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"3 1","name":"3 1","description":"Context-free grammar CFG : defined with a set of production rules ex) E -\u0026gt; E + E E -\u0026gt; E * E E -\u0026gt; id E -\u0026gt; num\nCFG : Derivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps\nCFG : Terminal Symbol : can\u0026rsquo;t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)","keywords":["Tag"],"articleBody":"Context-free grammar CFG : defined with a set of production rules ex) E -\u003e E + E E -\u003e E * E E -\u003e id E -\u003e num\nCFG : Derivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps\nCFG : Terminal Symbol : can’t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)\nCFG : Sentence and Language Sentence : Result of derivation that does not contain nay non-terminal Language : set of all derivable sentences 𝑳(𝑮) = {𝒘 | 𝑺⇒ ∗𝒘, 𝒘 consists of terminals}\nLeftmost Derivation : derivation을 할때 가장 왼쪽의 non-terminal 을 변환\nDerivation process중 Parse tree를 만들 수 있음 ex) E ⇒ E + E ⇒ id + E ⇒ id + num\nRegEx vs CFG R = ((id | num) (’ + ’ | ’ * ‘))* (id | num) 와 같이 RegEx로 표현 가능 하지만 brackets : “{}”, “{{}}”, {{{}}}\",… 과 같이 RegEx로 표현 불가능한 것이 존재 또한 RegEx는 Parse Tree를 생성할 수 없음\nAmbiguous Grammar 다음과 같은 경우 여러가지 방법으로 변환이 됨\n우리는 이를 방지하기 위하여 두가지 문제를 해결해야한다.\nEliminate ambiguity (Precedence) Bind * before + id + id * id must be interpreted as id + (id * id) (Associativity) * and + associate to the left id + id + id must be interpreted as (id + id) + id 다음과 같이 CFG를 정의하면 가능하다. Start variable is E E -\u003e E + T | T T -\u003e T * F | F F -\u003e id | num\nGeneral Rewriting Algorithm? ambiguous -\u003e unambiguous로 rewrite하는 algorithm 은 없음 심지어 ambiguous 한지 판단하는 algorithm 또한 없음\nUndecidable problem 우리는 앞으로 unambiguous 하다는 가정하에 풀어감 ##Top-down parsing Parser는 derivation을 추론해야함 (if exist)\nParsing is the process of inferring derivation for the token stream construction of parse tree Top-down parsing\nleftmost derivations root node에서 아래 방향으로 늘려야함 At each step, we must rewrite the left most non-terminal\n이때 어떠한 production rule을 사용할지 골라야함 parsing table : case에 따라 어떤 rule을 사용할지 알려줌 current status + next token을 통해 고를 수 있음 table drivven LL(1) parsing or LL(1) parsing Left-to-right, Leftmost derivation, 1 token lookahead LL(1) Grammar 모든 CFG에 대해서 적용할 수 없음\n어떤 grammar들은 parsing table을 만들 수 없음 LL(1) Grammar : LL(1) parsing이 적용 되는 CFG\n다음 CFG는 LL(1)이 아님 E -\u003e E + T | T T -\u003e T * F | F F -\u003e id | num\nLeft-Recursion CFG has a variable A that appear as the fist symbol in right-hand side of a rule 위 예시에서 E, T는 left-recursive CFG가 left-recursive이면 LL(1)이 될 수 없음 Eliminating Left-Recursion 𝑨 → 𝑨𝜶 | 𝜷 위와 같은 rule을 다음과 rewrite할 수 있다. 𝑨 → 𝜷𝑨′ 𝑨′ → 𝜶𝑨′ | 𝝐 이를 우리의 production rule에 적용해 보자\nLeft-recursion이 되지 않음을 확인할 수 있다.\nLeft- Recursion 이 아니더라도 꼭 LL(1)는 아니다.\n운이 좋게도 우리의 CFG는 LL(1)이 맞다. LL(1) Parsing Example LL(1) parsing process for num + id stack을 이용한다. 아래에서 $는 special marker(terminal)을 의미한다.\nStack Input Tokens Rule E $ num + id $ T E’ $ num + id $ E -\u003e T E’ F T’ E’ $ num + id $ T -\u003e F T' num T’ E’ $ num + id $ F -\u003e num T’ E’ $ + id $ Match and Pop E’ $ + id $ T’ -\u003e 𝜺 + T E’ $ + id $ E’ -\u003e + T E; T E’ $ id $ Match and Pop F T’ E’ $ id $ T -\u003e F T' id T’ E’ $ id $ F -\u003e id T’ E’ $ $ Match and Pop E’ $ $ T’ -\u003e 𝜺 $ $ E’ -\u003e 𝜺 Parsing Table Example Row : non-terminal on stack top Column : first terminal (token) in buffer\nFirst() and Follow() Parsing table을 만들때 First, Follow set을 먼저 만들어야함 First(a) : a를 파생하여 나올 수 있는 문장 중 첫 문자들의 집합 Follow(X) : X를 파생하여 나온 문장 문장 이후 나올 수 있는 문자 들의 집합\nBuilding Parsing Table X -\u003e a\nfor t in First (a), add X -\u003e a to the parsing table in Tap [X, t] if 𝜺 is in First (a), for t in Follow (x), add X -\u003e a to Tap [X, t] construction fail Consider X -\u003e a1 | … | an if First (ai)가 disjoint 하지 않을 경우 table의 하나의 slot에 여러 rule이 들어감\ninvalid parsing table CFG가 LL(1) Grammar가 아니라는 의미 ","wordCount":"758","inLanguage":"en","datePublished":"2024-01-10T17:47:45+09:00","dateModified":"2024-01-10T17:47:45+09:00","author":{"@type":"Person","name":"Kim-Minjoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://246p.github.io/blog/3-1/"},"publisher":{"@type":"Organization","name":"Junlog","logo":{"@type":"ImageObject","url":"https://246p.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://246p.github.io/ accesskey=h title="HOME (Alt + H)"><img src=https://246p.github.io/apple-touch-icon.png alt aria-label=logo height=35>HOME</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://246p.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://246p.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://246p.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://246p.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1Di1J0LxHNuXNiDbwFhOh2XMLAgUJtYlh/view?usp=drive_link" title=CV><span>CV</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://246p.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://246p.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">3 1</h1><div class=post-meta><span title='2024-01-10 17:47:45 +0900 KST'>January 10, 2024</span>&nbsp;·&nbsp;Kim-Minjoon</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#context-free-grammar>Context-free grammar</a><ul><li><a href=#ll1-grammar>LL(1) Grammar</a></li><li><a href=#left-recursion>Left-Recursion</a></li><li><a href=#ll1-parsing-example>LL(1) Parsing Example</a></li><li><a href=#first-and-follow>First() and Follow()</a></li><li><a href=#building-parsing-table>Building Parsing Table</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=context-free-grammar>Context-free grammar<a hidden class=anchor aria-hidden=true href=#context-free-grammar>#</a></h2><p>CFG : defined with a set of production rules
ex)
E -> E + E
E -> E * E
E -> id
E -> num</p><p>CFG : Derivation
ex) E ⇒ E + E ⇒ id + E ⇒ id + num
we will use ⇒* to denote arbitrary number of rewriting steps</p><p>CFG : Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num)
CFG : Non-Terminal Symbol : can be rewritten (E)</p><p>CFG : Sentence and Language
Sentence : Result of derivation that does not contain nay non-terminal
Language : set of all derivable sentences
𝑳(𝑮) = {𝒘 | 𝑺⇒ ∗𝒘, 𝒘 consists of terminals}</p><p>Leftmost Derivation : derivation을 할때 가장 왼쪽의 non-terminal 을 변환</p><p>Derivation process중 Parse tree를 만들 수 있음
ex) E ⇒ E + E ⇒ id + E ⇒ id + num</p><p>RegEx vs CFG
R = ((id | num) (&rsquo; + &rsquo; | &rsquo; * &lsquo;))* (id | num) 와 같이 RegEx로 표현 가능
하지만 brackets : &ldquo;{}&rdquo;, &ldquo;{{}}&rdquo;, {{{}}}",&mldr; 과 같이 RegEx로 표현 불가능한 것이 존재
또한 RegEx는 Parse Tree를 생성할 수 없음</p><p>Ambiguous Grammar
다음과 같은 경우 여러가지 방법으로 변환이 됨</p><p>우리는 이를 방지하기 위하여 두가지 문제를 해결해야한다.</p><ol><li>Eliminate ambiguity</li><li>(Precedence) Bind * before +</li></ol><ul><li>id + id * id must be interpreted as id + (id * id)</li></ul><ol start=3><li>(Associativity) * and + associate to the left</li></ol><ul><li>id + id + id must be interpreted as (id + id) + id</li></ul><blockquote><p>다음과 같이 CFG를 정의하면 가능하다.
Start variable is E
E -> E + T | T
T -> T * F | F
F -> id | num</p></blockquote><p>General Rewriting Algorithm?
ambiguous -> unambiguous로 rewrite하는 algorithm 은 없음
심지어 ambiguous 한지 판단하는 algorithm 또한 없음</p><ul><li>Undecidable problem
우리는 앞으로 unambiguous 하다는 가정하에 풀어감</li></ul><p>##Top-down parsing
Parser는 derivation을 추론해야함 (if exist)</p><ul><li>Parsing is the process of inferring derivation for the token stream</li><li>construction of parse tree</li></ul><p>Top-down parsing</p><ul><li>leftmost derivations</li><li>root node에서 아래 방향으로 늘려야함</li></ul><p>At each step, we must rewrite the left most non-terminal</p><ul><li>이때 어떠한 production rule을 사용할지 골라야함
parsing table : case에 따라 어떤 rule을 사용할지 알려줌</li><li>current status + next token을 통해 고를 수 있음</li><li>table drivven LL(1) parsing or LL(1) parsing<ul><li>Left-to-right, Leftmost derivation, 1 token lookahead</li></ul></li></ul><h3 id=ll1-grammar>LL(1) Grammar<a hidden class=anchor aria-hidden=true href=#ll1-grammar>#</a></h3><p>모든 CFG에 대해서 적용할 수 없음</p><ul><li>어떤 grammar들은 parsing table을 만들 수 없음</li></ul><p>LL(1) Grammar : LL(1) parsing이 적용 되는 CFG</p><p>다음 CFG는 LL(1)이 아님
E -> E + T | T
T -> T * F | F
F -> id | num</p><h3 id=left-recursion>Left-Recursion<a hidden class=anchor aria-hidden=true href=#left-recursion>#</a></h3><ul><li>CFG has a variable A that appear as the fist symbol in right-hand side of a rule
위 예시에서 E, T는 left-recursive
CFG가 left-recursive이면 LL(1)이 될 수 없음</li></ul><p>Eliminating Left-Recursion
𝑨 → 𝑨𝜶 | 𝜷
위와 같은 rule을 다음과 rewrite할 수 있다.
𝑨 → 𝜷𝑨′
𝑨′ → 𝜶𝑨′ | 𝝐
이를 우리의 production rule에 적용해 보자</p><p>Left-recursion이 되지 않음을 확인할 수 있다.</p><p>Left- Recursion 이 아니더라도 꼭 LL(1)는 아니다.</p><ul><li>운이 좋게도 우리의 CFG는 LL(1)이 맞다.</li></ul><h3 id=ll1-parsing-example>LL(1) Parsing Example<a hidden class=anchor aria-hidden=true href=#ll1-parsing-example>#</a></h3><p>LL(1) parsing process for num + id
stack을 이용한다. 아래에서 $는 special marker(terminal)을 의미한다.</p><table><thead><tr><th style=text-align:right>Stack</th><th style=text-align:right>Input Tokens</th><th style=text-align:right>Rule</th></tr></thead><tbody><tr><td style=text-align:right>E $</td><td style=text-align:right>num + id $</td><td style=text-align:right></td></tr><tr><td style=text-align:right>T E&rsquo; $</td><td style=text-align:right>num + id $</td><td style=text-align:right>E -> T E&rsquo;</td></tr><tr><td style=text-align:right>F T&rsquo; E&rsquo; $</td><td style=text-align:right>num + id $</td><td style=text-align:right>T -> F T'</td></tr><tr><td style=text-align:right>num T&rsquo; E&rsquo; $</td><td style=text-align:right>num + id $</td><td style=text-align:right>F -> num</td></tr><tr><td style=text-align:right>T&rsquo; E&rsquo; $</td><td style=text-align:right>+ id $</td><td style=text-align:right>Match and Pop</td></tr><tr><td style=text-align:right>E&rsquo; $</td><td style=text-align:right>+ id $</td><td style=text-align:right>T&rsquo; -> 𝜺</td></tr><tr><td style=text-align:right>+ T E&rsquo; $</td><td style=text-align:right>+ id $</td><td style=text-align:right>E&rsquo; -> + T E;</td></tr><tr><td style=text-align:right>T E&rsquo; $</td><td style=text-align:right>id $</td><td style=text-align:right>Match and Pop</td></tr><tr><td style=text-align:right>F T&rsquo; E&rsquo; $</td><td style=text-align:right>id $</td><td style=text-align:right>T -> F T'</td></tr><tr><td style=text-align:right>id T&rsquo; E&rsquo; $</td><td style=text-align:right>id $</td><td style=text-align:right>F -> id</td></tr><tr><td style=text-align:right>T&rsquo; E&rsquo; $</td><td style=text-align:right>$</td><td style=text-align:right>Match and Pop</td></tr><tr><td style=text-align:right>E&rsquo; $</td><td style=text-align:right>$</td><td style=text-align:right>T&rsquo; -> 𝜺</td></tr><tr><td style=text-align:right>$</td><td style=text-align:right>$</td><td style=text-align:right>E&rsquo; -> 𝜺</td></tr></tbody></table><p>Parsing Table Example
Row : non-terminal on stack top
Column : first terminal (token) in buffer</p><h3 id=first-and-follow>First() and Follow()<a hidden class=anchor aria-hidden=true href=#first-and-follow>#</a></h3><p>Parsing table을 만들때 First, Follow set을 먼저 만들어야함
First(a) : a를 파생하여 나올 수 있는 문장 중 첫 문자들의 집합
Follow(X) : X를 파생하여 나온 문장 문장 이후 나올 수 있는 문자 들의 집합</p><h3 id=building-parsing-table>Building Parsing Table<a hidden class=anchor aria-hidden=true href=#building-parsing-table>#</a></h3><p>X -> a</p><ul><li>for t in First (a), add X -> a to the parsing table in Tap [X, t]</li><li>if 𝜺 is in First (a), for t in Follow (x), add X -> a to Tap [X, t]</li></ul><p>construction fail
Consider X -> a1 | &mldr; | an
if First (ai)가 disjoint 하지 않을 경우 table의 하나의 slot에 여러 rule이 들어감</p><ul><li>invalid parsing table</li><li>CFG가 LL(1) Grammar가 아니라는 의미</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://246p.github.io/tags/tag/>Tag</a></li></ul><nav class=paginav><a class=next href=https://246p.github.io/blog/2/><span class=title>Next »</span><br><span>2. Lexical Analysis</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://246p.github.io/>Junlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>