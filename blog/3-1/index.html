<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>3 1 | Junlog</title>
<meta name=keywords content="Tag"><meta name=description content="Context-free grammar CFG : defined with a set of production rules ex) E -> E + E E -> E * E E -> id E -> num
CFG : Derivation ex) E â‡’ E + E â‡’ id + E â‡’ id + num we will use â‡’* to denote arbitrary number of rewriting steps
CFG : Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)"><meta name=author content="Kim-Minjoon"><link rel=canonical href=https://246p.github.io/blog/3-1/><meta name=google-site-verification content="GTM-524D7HPF"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://246p.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="3 1"><meta property="og:description" content="Context-free grammar CFG : defined with a set of production rules ex) E -> E + E E -> E * E E -> id E -> num
CFG : Derivation ex) E â‡’ E + E â‡’ id + E â‡’ id + num we will use â‡’* to denote arbitrary number of rewriting steps
CFG : Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)"><meta property="og:type" content="article"><meta property="og:url" content="https://246p.github.io/blog/3-1/"><meta property="og:image" content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-01-10T17:47:45+09:00"><meta property="article:modified_time" content="2024-01-10T17:47:45+09:00"><meta property="og:site_name" content="Junlog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true"><meta name=twitter:title content="3 1"><meta name=twitter:description content="Context-free grammar CFG : defined with a set of production rules ex) E -> E + E E -> E * E E -> id E -> num
CFG : Derivation ex) E â‡’ E + E â‡’ id + E â‡’ id + num we will use â‡’* to denote arbitrary number of rewriting steps
CFG : Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://246p.github.io/post/"},{"@type":"ListItem","position":2,"name":"3 1","item":"https://246p.github.io/blog/3-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"3 1","name":"3 1","description":"Context-free grammar CFG : defined with a set of production rules ex) E -\u0026gt; E + E E -\u0026gt; E * E E -\u0026gt; id E -\u0026gt; num\nCFG : Derivation ex) E â‡’ E + E â‡’ id + E â‡’ id + num we will use â‡’* to denote arbitrary number of rewriting steps\nCFG : Terminal Symbol : can\u0026rsquo;t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)","keywords":["Tag"],"articleBody":"Context-free grammar CFG : defined with a set of production rules ex) E -\u003e E + E E -\u003e E * E E -\u003e id E -\u003e num\nCFG : Derivation ex) E â‡’ E + E â‡’ id + E â‡’ id + num we will use â‡’* to denote arbitrary number of rewriting steps\nCFG : Terminal Symbol : canâ€™t be rewritten anymore (+, *, id, num) CFG : Non-Terminal Symbol : can be rewritten (E)\nCFG : Sentence and Language Sentence : Result of derivation that does not contain nay non-terminal Language : set of all derivable sentences ğ‘³(ğ‘®) = {ğ’˜ | ğ‘ºâ‡’ âˆ—ğ’˜, ğ’˜ consists of terminals}\nLeftmost Derivation : derivationì„ í• ë•Œ ê°€ì¥ ì™¼ìª½ì˜ non-terminal ì„ ë³€í™˜\nDerivation processì¤‘ Parse treeë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŒ ex) E â‡’ E + E â‡’ id + E â‡’ id + num\nRegEx vs CFG R = ((id | num) (â€™ + â€™ | â€™ * â€˜))* (id | num) ì™€ ê°™ì´ RegExë¡œ í‘œí˜„ ê°€ëŠ¥ í•˜ì§€ë§Œ brackets : â€œ{}â€, â€œ{{}}â€, {{{}}}\",â€¦ ê³¼ ê°™ì´ RegExë¡œ í‘œí˜„ ë¶ˆê°€ëŠ¥í•œ ê²ƒì´ ì¡´ì¬ ë˜í•œ RegExëŠ” Parse Treeë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŒ\nAmbiguous Grammar ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš° ì—¬ëŸ¬ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ë³€í™˜ì´ ë¨\nìš°ë¦¬ëŠ” ì´ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•˜ì—¬ ë‘ê°€ì§€ ë¬¸ì œë¥¼ í•´ê²°í•´ì•¼í•œë‹¤.\nEliminate ambiguity (Precedence) Bind * before + id + id * id must be interpreted as id + (id * id) (Associativity) * and + associate to the left id + id + id must be interpreted as (id + id) + id ë‹¤ìŒê³¼ ê°™ì´ CFGë¥¼ ì •ì˜í•˜ë©´ ê°€ëŠ¥í•˜ë‹¤. Start variable is E E -\u003e E + T | T T -\u003e T * F | F F -\u003e id | num\nGeneral Rewriting Algorithm? ambiguous -\u003e unambiguousë¡œ rewriteí•˜ëŠ” algorithm ì€ ì—†ìŒ ì‹¬ì§€ì–´ ambiguous í•œì§€ íŒë‹¨í•˜ëŠ” algorithm ë˜í•œ ì—†ìŒ\nUndecidable problem ìš°ë¦¬ëŠ” ì•ìœ¼ë¡œ unambiguous í•˜ë‹¤ëŠ” ê°€ì •í•˜ì— í’€ì–´ê° ##Top-down parsing ParserëŠ” derivationì„ ì¶”ë¡ í•´ì•¼í•¨ (if exist)\nParsing is the process of inferring derivation for the token stream construction of parse tree Top-down parsing\nleftmost derivations root nodeì—ì„œ ì•„ë˜ ë°©í–¥ìœ¼ë¡œ ëŠ˜ë ¤ì•¼í•¨ At each step, we must rewrite the left most non-terminal\nì´ë•Œ ì–´ë– í•œ production ruleì„ ì‚¬ìš©í• ì§€ ê³¨ë¼ì•¼í•¨ parsing table : caseì— ë”°ë¼ ì–´ë–¤ ruleì„ ì‚¬ìš©í• ì§€ ì•Œë ¤ì¤Œ current status + next tokenì„ í†µí•´ ê³ ë¥¼ ìˆ˜ ìˆìŒ table drivven LL(1) parsing or LL(1) parsing Left-to-right, Leftmost derivation, 1 token lookahead LL(1) Grammar ëª¨ë“  CFGì— ëŒ€í•´ì„œ ì ìš©í•  ìˆ˜ ì—†ìŒ\nì–´ë–¤ grammarë“¤ì€ parsing tableì„ ë§Œë“¤ ìˆ˜ ì—†ìŒ LL(1) Grammar : LL(1) parsingì´ ì ìš© ë˜ëŠ” CFG\në‹¤ìŒ CFGëŠ” LL(1)ì´ ì•„ë‹˜ E -\u003e E + T | T T -\u003e T * F | F F -\u003e id | num\nLeft-Recursion CFG has a variable A that appear as the fist symbol in right-hand side of a rule ìœ„ ì˜ˆì‹œì—ì„œ E, TëŠ” left-recursive CFGê°€ left-recursiveì´ë©´ LL(1)ì´ ë  ìˆ˜ ì—†ìŒ Eliminating Left-Recursion ğ‘¨ â†’ ğ‘¨ğœ¶ | ğœ· ìœ„ì™€ ê°™ì€ ruleì„ ë‹¤ìŒê³¼ rewriteí•  ìˆ˜ ìˆë‹¤. ğ‘¨ â†’ ğœ·ğ‘¨â€² ğ‘¨â€² â†’ ğœ¶ğ‘¨â€² | ğ ì´ë¥¼ ìš°ë¦¬ì˜ production ruleì— ì ìš©í•´ ë³´ì\nLeft-recursionì´ ë˜ì§€ ì•ŠìŒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\nLeft- Recursion ì´ ì•„ë‹ˆë”ë¼ë„ ê¼­ LL(1)ëŠ” ì•„ë‹ˆë‹¤.\nìš´ì´ ì¢‹ê²Œë„ ìš°ë¦¬ì˜ CFGëŠ” LL(1)ì´ ë§ë‹¤. LL(1) Parsing Example LL(1) parsing process for num + id stackì„ ì´ìš©í•œë‹¤. ì•„ë˜ì—ì„œ $ëŠ” special marker(terminal)ì„ ì˜ë¯¸í•œë‹¤.\nStack Input Tokens Rule E $ num + id $ T Eâ€™ $ num + id $ E -\u003e T Eâ€™ F Tâ€™ Eâ€™ $ num + id $ T -\u003e F T' num Tâ€™ Eâ€™ $ num + id $ F -\u003e num Tâ€™ Eâ€™ $ + id $ Match and Pop Eâ€™ $ + id $ Tâ€™ -\u003e ğœº + T Eâ€™ $ + id $ Eâ€™ -\u003e + T E; T Eâ€™ $ id $ Match and Pop F Tâ€™ Eâ€™ $ id $ T -\u003e F T' id Tâ€™ Eâ€™ $ id $ F -\u003e id Tâ€™ Eâ€™ $ $ Match and Pop Eâ€™ $ $ Tâ€™ -\u003e ğœº $ $ Eâ€™ -\u003e ğœº Parsing Table Example Row : non-terminal on stack top Column : first terminal (token) in buffer\nFirst() and Follow() Parsing tableì„ ë§Œë“¤ë•Œ First, Follow setì„ ë¨¼ì € ë§Œë“¤ì–´ì•¼í•¨ First(a) : aë¥¼ íŒŒìƒí•˜ì—¬ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ì¥ ì¤‘ ì²« ë¬¸ìë“¤ì˜ ì§‘í•© Follow(X) : Xë¥¼ íŒŒìƒí•˜ì—¬ ë‚˜ì˜¨ ë¬¸ì¥ ë¬¸ì¥ ì´í›„ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ì ë“¤ì˜ ì§‘í•©\nBuilding Parsing Table X -\u003e a\nfor t in First (a), add X -\u003e a to the parsing table in Tap [X, t] if ğœº is in First (a), for t in Follow (x), add X -\u003e a to Tap [X, t] construction fail Consider X -\u003e a1 | â€¦ | an if First (ai)ê°€ disjoint í•˜ì§€ ì•Šì„ ê²½ìš° tableì˜ í•˜ë‚˜ì˜ slotì— ì—¬ëŸ¬ ruleì´ ë“¤ì–´ê°\ninvalid parsing table CFGê°€ LL(1) Grammarê°€ ì•„ë‹ˆë¼ëŠ” ì˜ë¯¸ ","wordCount":"758","inLanguage":"en","datePublished":"2024-01-10T17:47:45+09:00","dateModified":"2024-01-10T17:47:45+09:00","author":{"@type":"Person","name":"Kim-Minjoon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://246p.github.io/blog/3-1/"},"publisher":{"@type":"Organization","name":"Junlog","logo":{"@type":"ImageObject","url":"https://246p.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://246p.github.io/ accesskey=h title="HOME (Alt + H)"><img src=https://246p.github.io/apple-touch-icon.png alt aria-label=logo height=35>HOME</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://246p.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://246p.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://246p.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://246p.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1Di1J0LxHNuXNiDbwFhOh2XMLAgUJtYlh/view?usp=drive_link" title=CV><span>CV</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://246p.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://246p.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">3 1</h1><div class=post-meta><span title='2024-01-10 17:47:45 +0900 KST'>January 10, 2024</span>&nbsp;Â·&nbsp;Kim-Minjoon</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#context-free-grammar>Context-free grammar</a><ul><li><a href=#ll1-grammar>LL(1) Grammar</a></li><li><a href=#left-recursion>Left-Recursion</a></li><li><a href=#ll1-parsing-example>LL(1) Parsing Example</a></li><li><a href=#first-and-follow>First() and Follow()</a></li><li><a href=#building-parsing-table>Building Parsing Table</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=context-free-grammar>Context-free grammar<a hidden class=anchor aria-hidden=true href=#context-free-grammar>#</a></h2><p>CFG : defined with a set of production rules
ex)
E -> E + E
E -> E * E
E -> id
E -> num</p><p>CFG : Derivation
ex) E â‡’ E + E â‡’ id + E â‡’ id + num
we will use â‡’* to denote arbitrary number of rewriting steps</p><p>CFG : Terminal Symbol : can&rsquo;t be rewritten anymore (+, *, id, num)
CFG : Non-Terminal Symbol : can be rewritten (E)</p><p>CFG : Sentence and Language
Sentence : Result of derivation that does not contain nay non-terminal
Language : set of all derivable sentences
ğ‘³(ğ‘®) = {ğ’˜ | ğ‘ºâ‡’ âˆ—ğ’˜, ğ’˜ consists of terminals}</p><p>Leftmost Derivation : derivationì„ í• ë•Œ ê°€ì¥ ì™¼ìª½ì˜ non-terminal ì„ ë³€í™˜</p><p>Derivation processì¤‘ Parse treeë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŒ
ex) E â‡’ E + E â‡’ id + E â‡’ id + num</p><p>RegEx vs CFG
R = ((id | num) (&rsquo; + &rsquo; | &rsquo; * &lsquo;))* (id | num) ì™€ ê°™ì´ RegExë¡œ í‘œí˜„ ê°€ëŠ¥
í•˜ì§€ë§Œ brackets : &ldquo;{}&rdquo;, &ldquo;{{}}&rdquo;, {{{}}}",&mldr; ê³¼ ê°™ì´ RegExë¡œ í‘œí˜„ ë¶ˆê°€ëŠ¥í•œ ê²ƒì´ ì¡´ì¬
ë˜í•œ RegExëŠ” Parse Treeë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŒ</p><p>Ambiguous Grammar
ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš° ì—¬ëŸ¬ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ë³€í™˜ì´ ë¨</p><p>ìš°ë¦¬ëŠ” ì´ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•˜ì—¬ ë‘ê°€ì§€ ë¬¸ì œë¥¼ í•´ê²°í•´ì•¼í•œë‹¤.</p><ol><li>Eliminate ambiguity</li><li>(Precedence) Bind * before +</li></ol><ul><li>id + id * id must be interpreted as id + (id * id)</li></ul><ol start=3><li>(Associativity) * and + associate to the left</li></ol><ul><li>id + id + id must be interpreted as (id + id) + id</li></ul><blockquote><p>ë‹¤ìŒê³¼ ê°™ì´ CFGë¥¼ ì •ì˜í•˜ë©´ ê°€ëŠ¥í•˜ë‹¤.
Start variable is E
E -> E + T | T
T -> T * F | F
F -> id | num</p></blockquote><p>General Rewriting Algorithm?
ambiguous -> unambiguousë¡œ rewriteí•˜ëŠ” algorithm ì€ ì—†ìŒ
ì‹¬ì§€ì–´ ambiguous í•œì§€ íŒë‹¨í•˜ëŠ” algorithm ë˜í•œ ì—†ìŒ</p><ul><li>Undecidable problem
ìš°ë¦¬ëŠ” ì•ìœ¼ë¡œ unambiguous í•˜ë‹¤ëŠ” ê°€ì •í•˜ì— í’€ì–´ê°</li></ul><p>##Top-down parsing
ParserëŠ” derivationì„ ì¶”ë¡ í•´ì•¼í•¨ (if exist)</p><ul><li>Parsing is the process of inferring derivation for the token stream</li><li>construction of parse tree</li></ul><p>Top-down parsing</p><ul><li>leftmost derivations</li><li>root nodeì—ì„œ ì•„ë˜ ë°©í–¥ìœ¼ë¡œ ëŠ˜ë ¤ì•¼í•¨</li></ul><p>At each step, we must rewrite the left most non-terminal</p><ul><li>ì´ë•Œ ì–´ë– í•œ production ruleì„ ì‚¬ìš©í• ì§€ ê³¨ë¼ì•¼í•¨
parsing table : caseì— ë”°ë¼ ì–´ë–¤ ruleì„ ì‚¬ìš©í• ì§€ ì•Œë ¤ì¤Œ</li><li>current status + next tokenì„ í†µí•´ ê³ ë¥¼ ìˆ˜ ìˆìŒ</li><li>table drivven LL(1) parsing or LL(1) parsing<ul><li>Left-to-right, Leftmost derivation, 1 token lookahead</li></ul></li></ul><h3 id=ll1-grammar>LL(1) Grammar<a hidden class=anchor aria-hidden=true href=#ll1-grammar>#</a></h3><p>ëª¨ë“  CFGì— ëŒ€í•´ì„œ ì ìš©í•  ìˆ˜ ì—†ìŒ</p><ul><li>ì–´ë–¤ grammarë“¤ì€ parsing tableì„ ë§Œë“¤ ìˆ˜ ì—†ìŒ</li></ul><p>LL(1) Grammar : LL(1) parsingì´ ì ìš© ë˜ëŠ” CFG</p><p>ë‹¤ìŒ CFGëŠ” LL(1)ì´ ì•„ë‹˜
E -> E + T | T
T -> T * F | F
F -> id | num</p><h3 id=left-recursion>Left-Recursion<a hidden class=anchor aria-hidden=true href=#left-recursion>#</a></h3><ul><li>CFG has a variable A that appear as the fist symbol in right-hand side of a rule
ìœ„ ì˜ˆì‹œì—ì„œ E, TëŠ” left-recursive
CFGê°€ left-recursiveì´ë©´ LL(1)ì´ ë  ìˆ˜ ì—†ìŒ</li></ul><p>Eliminating Left-Recursion
ğ‘¨ â†’ ğ‘¨ğœ¶ | ğœ·
ìœ„ì™€ ê°™ì€ ruleì„ ë‹¤ìŒê³¼ rewriteí•  ìˆ˜ ìˆë‹¤.
ğ‘¨ â†’ ğœ·ğ‘¨â€²
ğ‘¨â€² â†’ ğœ¶ğ‘¨â€² | ğ
ì´ë¥¼ ìš°ë¦¬ì˜ production ruleì— ì ìš©í•´ ë³´ì</p><p>Left-recursionì´ ë˜ì§€ ì•ŠìŒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.</p><p>Left- Recursion ì´ ì•„ë‹ˆë”ë¼ë„ ê¼­ LL(1)ëŠ” ì•„ë‹ˆë‹¤.</p><ul><li>ìš´ì´ ì¢‹ê²Œë„ ìš°ë¦¬ì˜ CFGëŠ” LL(1)ì´ ë§ë‹¤.</li></ul><h3 id=ll1-parsing-example>LL(1) Parsing Example<a hidden class=anchor aria-hidden=true href=#ll1-parsing-example>#</a></h3><p>LL(1) parsing process for num + id
stackì„ ì´ìš©í•œë‹¤. ì•„ë˜ì—ì„œ $ëŠ” special marker(terminal)ì„ ì˜ë¯¸í•œë‹¤.</p><table><thead><tr><th style=text-align:right>Stack</th><th style=text-align:right>Input Tokens</th><th style=text-align:right>Rule</th></tr></thead><tbody><tr><td style=text-align:right>E $</td><td style=text-align:right>num + id $</td><td style=text-align:right></td></tr><tr><td style=text-align:right>T E&rsquo; $</td><td style=text-align:right>num + id $</td><td style=text-align:right>E -> T E&rsquo;</td></tr><tr><td style=text-align:right>F T&rsquo; E&rsquo; $</td><td style=text-align:right>num + id $</td><td style=text-align:right>T -> F T'</td></tr><tr><td style=text-align:right>num T&rsquo; E&rsquo; $</td><td style=text-align:right>num + id $</td><td style=text-align:right>F -> num</td></tr><tr><td style=text-align:right>T&rsquo; E&rsquo; $</td><td style=text-align:right>+ id $</td><td style=text-align:right>Match and Pop</td></tr><tr><td style=text-align:right>E&rsquo; $</td><td style=text-align:right>+ id $</td><td style=text-align:right>T&rsquo; -> ğœº</td></tr><tr><td style=text-align:right>+ T E&rsquo; $</td><td style=text-align:right>+ id $</td><td style=text-align:right>E&rsquo; -> + T E;</td></tr><tr><td style=text-align:right>T E&rsquo; $</td><td style=text-align:right>id $</td><td style=text-align:right>Match and Pop</td></tr><tr><td style=text-align:right>F T&rsquo; E&rsquo; $</td><td style=text-align:right>id $</td><td style=text-align:right>T -> F T'</td></tr><tr><td style=text-align:right>id T&rsquo; E&rsquo; $</td><td style=text-align:right>id $</td><td style=text-align:right>F -> id</td></tr><tr><td style=text-align:right>T&rsquo; E&rsquo; $</td><td style=text-align:right>$</td><td style=text-align:right>Match and Pop</td></tr><tr><td style=text-align:right>E&rsquo; $</td><td style=text-align:right>$</td><td style=text-align:right>T&rsquo; -> ğœº</td></tr><tr><td style=text-align:right>$</td><td style=text-align:right>$</td><td style=text-align:right>E&rsquo; -> ğœº</td></tr></tbody></table><p>Parsing Table Example
Row : non-terminal on stack top
Column : first terminal (token) in buffer</p><h3 id=first-and-follow>First() and Follow()<a hidden class=anchor aria-hidden=true href=#first-and-follow>#</a></h3><p>Parsing tableì„ ë§Œë“¤ë•Œ First, Follow setì„ ë¨¼ì € ë§Œë“¤ì–´ì•¼í•¨
First(a) : aë¥¼ íŒŒìƒí•˜ì—¬ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ì¥ ì¤‘ ì²« ë¬¸ìë“¤ì˜ ì§‘í•©
Follow(X) : Xë¥¼ íŒŒìƒí•˜ì—¬ ë‚˜ì˜¨ ë¬¸ì¥ ë¬¸ì¥ ì´í›„ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ì ë“¤ì˜ ì§‘í•©</p><h3 id=building-parsing-table>Building Parsing Table<a hidden class=anchor aria-hidden=true href=#building-parsing-table>#</a></h3><p>X -> a</p><ul><li>for t in First (a), add X -> a to the parsing table in Tap [X, t]</li><li>if ğœº is in First (a), for t in Follow (x), add X -> a to Tap [X, t]</li></ul><p>construction fail
Consider X -> a1 | &mldr; | an
if First (ai)ê°€ disjoint í•˜ì§€ ì•Šì„ ê²½ìš° tableì˜ í•˜ë‚˜ì˜ slotì— ì—¬ëŸ¬ ruleì´ ë“¤ì–´ê°</p><ul><li>invalid parsing table</li><li>CFGê°€ LL(1) Grammarê°€ ì•„ë‹ˆë¼ëŠ” ì˜ë¯¸</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://246p.github.io/tags/tag/>Tag</a></li></ul><nav class=paginav><a class=next href=https://246p.github.io/blog/2/><span class=title>Next Â»</span><br><span>2. Lexical Analysis</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://246p.github.io/>Junlog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>