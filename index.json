[{"content":"Bottom-up bottom-up parsing을 수행할때는 소괄호를 지원하는 조금 다른 CFG를 사용한다\n피 연산자로 id만 지원함 left-recursion이 있어도 됨 Top-down parsing은 다음과 같은 방식으로 시작된다.\ntree를 만드는 동안 token을 하나씩 읽는다. 끝이 난다면 root node는 start symbol이 된다. 다음은 id1 * id2 에 대한 예시이다. 즉 reversed order Rightmost Derivation이라고 볼 수 있다.\nLR(1) Parsing 매 단계마다 다음 token을 받아올지 production rule을 적용할지 정해야 한다. top-down parsing과 동일하게 parsing table을 사용한다. Three Types of LR(1) Parsing Left-to-right, Rightmost derivation, 1 token lookahead SLR(1) Parsing : Simple LR(1) Parsing 우리가 다룰것 LALR(1) Parsing : Look-Ahead LR(1) Parsing SLR(1)보다 많은 grammar에 적용 가능하다. 많은 언어에서 사용된다. Canonical LR(1) Parsing LALR(1)보다 더 많은 grammar에 적용 가능하다. 복잡하다. LR(1) Grammar ","permalink":"https://246p.github.io/blog/3_2/","summary":"Bottom-up bottom-up parsing을 수행할때는 소괄호를 지원하는 조금 다른 CFG를 사용한다\n피 연산자로 id만 지원함 left-recursion이 있어도 됨 Top-down parsing은 다음과 같은 방식으로 시작된다.\ntree를 만드는 동안 token을 하나씩 읽는다. 끝이 난다면 root node는 start symbol이 된다. 다음은 id1 * id2 에 대한 예시이다. 즉 reversed order Rightmost Derivation이라고 볼 수 있다.\nLR(1) Parsing 매 단계마다 다음 token을 받아올지 production rule을 적용할지 정해야 한다. top-down parsing과 동일하게 parsing table을 사용한다. Three Types of LR(1) Parsing Left-to-right, Rightmost derivation, 1 token lookahead SLR(1) Parsing : Simple LR(1) Parsing 우리가 다룰것 LALR(1) Parsing : Look-Ahead LR(1) Parsing SLR(1)보다 많은 grammar에 적용 가능하다.","title":"3. Syntax analysis (2)"},{"content":"Context-free grammar CFG : defined with a set of production rules ex) E -\u0026gt; E + E E -\u0026gt; E * E E -\u0026gt; id E -\u0026gt; num\nDerivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps\nTerminal Symbol vs Non-Terminal Symbol Terminal Symbol : can\u0026rsquo;t be rewritten anymore (+, *, id, num) Non-Terminal Symbol : can be rewritten (E)\nCFG : Sentence and Language Sentence : Result of derivation that does not contain nay non-terminal\nLanguage : set of all derivable sentences\n𝑳(𝑮) = {𝒘 | 𝑺⇒ ∗𝒘, 𝒘 consists of terminals}\nLeftmost Derivation derivation을 할때 가장 왼쪽의 non-terminal을 먼저 변환하는 규칙\nParse tree Derivation process중 Parse tree를 만들 수 있음\nex) E ⇒ E + E ⇒ id + E ⇒ id + num\nRegEx vs CFG R = ((id | num) (\u0026rsquo; + \u0026rsquo; | \u0026rsquo; * \u0026lsquo;))* (id | num) 와 같이 RegEx로 할 수 있다. 하지만 brackets : \u0026ldquo;{}\u0026rdquo;, \u0026ldquo;{{}}\u0026rdquo;, {{{}}}\u0026quot;,\u0026hellip; 과 같이 RegEx로 표현 불가능한 것이 존재 한다. 또한 RegEx는 Parse Tree를 생성할 수 없다. Ambiguous Grammar derivations 방법에 따라서 서도 다른 parse tree가 만들어진다.\n이와 같은 경우를 막기 위하여 세가지 요소를 고려해야한다.\nEliminate ambiguity (Precedence) Bind * before + id + id * id must be interpreted as id + (id * id) (Associativity) * and + associate to the left id + id + id must be interpreted as (id + id) + id 다음과 같이 CFG를 정의하면 가능하다.\nStart variable is E\nE -\u0026gt; E + T | T\nT -\u0026gt; T * F | F\nF -\u0026gt; id | num\nGeneral Rewriting Algorithm? ambiguous -\u0026gt; unambiguous로 rewrite하는 algorithm은 없다.\n심지어 ambiguous 한지 판단하는 algorithm 또한 없다.\nUndecidable problem 하지만 우리는 unambiguous 하다는 가정하에 진행한다. Top-down parsing Parser는 derivation을 추론해야함 (if exist)\nParsing is the process of inferring derivation for the token stream construction of parse tree Top-down parsing leftmost derivations root node에서 아래 방향으로 늘려야함 At each step, we must rewrite the left most non-terminal\n이때 어떠한 production rule을 사용할지 골라야 한다. parsing table : case에 따라 어떤 rule을 사용할지 알려줌\ncurrent status + next token을 통해 고를 수 있음 table drivven LL(1) parsing or LL(1) parsing Left-to-right, Leftmost derivation, 1 token lookahead LL(1) Grammar LL(1) Grammar 란 LL(1) parsing이 적용 되는 CFG를 의미한다. 모든 CFG에 대해서 적용할 수 는 없다. 즉 어떤 grammar들은 parsing table을 만들 수 없음 다음 CFG는 LL(1)이 아님 E -\u0026gt; E + T | T T -\u0026gt; T * F | F F -\u0026gt; id | num\nLeft-Recursion CFG has a variable A that appear as the fist symbol in right-hand side of a rule\n위 예시에서 E, T는 left-recursive 이다.\nCFG가 left-recursive이면 LL(1)이 될 수 없다.\nEliminating Left-Recursion 𝑨 → 𝑨𝜶 | 𝜷\n위와 같은 rule을 다음과 rewrite할 수 있다.\n𝑨 → 𝜷𝑨′\n𝑨′ → 𝜶𝑨′ | 𝝐 이를 우리의 production rule에 적용해 보자.\nLeft- Recursion 이 아니더라도 꼭 LL(1) Grammer는 아니다. 다행히 운이 좋게도 우리의 CFG는 LL(1) Grammar이다.\nLL(1) Parsing Example num + id 에 대해서 LL(1) parsing을 적용해보자\nStack Input Tokens Rule E $ num + id $ T E\u0026rsquo; $ num + id $ E -\u0026gt; T E\u0026rsquo; F T\u0026rsquo; E\u0026rsquo; $ num + id $ T -\u0026gt; F T' num T\u0026rsquo; E\u0026rsquo; $ num + id $ F -\u0026gt; num T\u0026rsquo; E\u0026rsquo; $ + id $ Match and Pop E\u0026rsquo; $ + id $ T\u0026rsquo; -\u0026gt; 𝜺 + T E\u0026rsquo; $ + id $ E\u0026rsquo; -\u0026gt; + T E; T E\u0026rsquo; $ id $ Match and Pop F T\u0026rsquo; E\u0026rsquo; $ id $ T -\u0026gt; F T' id T\u0026rsquo; E\u0026rsquo; $ id $ F -\u0026gt; id T\u0026rsquo; E\u0026rsquo; $ $ Match and Pop E\u0026rsquo; $ $ T\u0026rsquo; -\u0026gt; 𝜺 $ $ E\u0026rsquo; -\u0026gt; 𝜺 Parsing Table Parsing 을 수행하다보면 Parsing table의 필요성을 느끼게 된다.\nRow : non-terminal on stack top\nColumn : first terminal (token) in buffer\nFirst and Follow Parsing table을 만들기 위해서는 First, Follow set을 먼저 만들어야 한다.\nFirst(a) : a를 파생하여 나올 수 있는 문장 중 첫 문자들의 집합\nFollow(X) : X를 파생하여 나온 문장 문장 이후 나올 수 있는 문자 들의 집합\n다음은 예시이다. Building Parsing Table X -\u0026gt; a 에 대해서 parsing table에 넣는 방법이다.\nfor t in First (a), add X -\u0026gt; a to the parsing table in Tap [X, t] if 𝜺 is in First (a), for t in Follow (x), add X -\u0026gt; a to Tap [X, t] Construction Fail X -\u0026gt; a1 | \u0026hellip; | an 을 생각해 보자\nFirst (ai)들이 disjoint 하지 않을 경우 table의 하나의 slot에 여러 rule이 들어가게 된다. 즉 해당 parsing table을 만들 수 없고 CFG가 LL(1) Grammar가 아니라는 의미이다.\n","permalink":"https://246p.github.io/blog/3_1/","summary":"Context-free grammar CFG : defined with a set of production rules ex) E -\u0026gt; E + E E -\u0026gt; E * E E -\u0026gt; id E -\u0026gt; num\nDerivation ex) E ⇒ E + E ⇒ id + E ⇒ id + num we will use ⇒* to denote arbitrary number of rewriting steps\nTerminal Symbol vs Non-Terminal Symbol Terminal Symbol : can\u0026rsquo;t be rewritten anymore (+, *, id, num) Non-Terminal Symbol : can be rewritten (E)","title":"3. Syntax analysis (1)"},{"content":"Token 문자열을 해당 문자열의 의미하는 연산, 값에 따라 token으로 분류할 수 있다.\nToken Example Keyword int, void, if Identifier a, var_1 Integer 10, 20 Operators +, =, * Whitespace “ “, \\t, \\n Regula Expression Token을 나누는 방법은 Automata를 이용한다. 이에 앞서 Regula Expression (RegEx) 에 대해서 알아볼 필요가 있다.\nRegEx는 Base case와 Inductive case로 구성된다.\nRegula language 𝚺 를 이용하여 symbol들의 집합을 표기한다. ex) binary numbers : 𝚺 = {\u0026lsquo;0\u0026rsquo;,\u0026lsquo;1\u0026rsquo;}, lowercase letters : 𝚺 = {\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026hellip;\u0026lsquo;z\u0026rsquo;}\nWord는 주어진 𝚺의 symbol들의 나열이다. empty word를 나타낼때에는 𝜖을 사용한다. ex) 𝚺 = {\u0026lsquo;0\u0026rsquo;,\u0026lsquo;1\u0026rsquo;,\u0026lsquo;2\u0026rsquo;} -\u0026gt; word : 𝜖, \u0026ldquo;1,\u0026rdquo; ,\u0026ldquo;12\u0026rdquo;, \u0026ldquo;012\u0026rdquo;\nLanguage란 word의 집합을 의미한다. L1 = {\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;aaaab\u0026rdquo;,\u0026hellip;} Base case 빈 문자는 𝜖로 표기한다. 하나의 문자는 \u0026lsquo;c\u0026rsquo; ∈ 𝚺 로 표기한다. Inductive case Union : R1|R2 : R1 or R2 Concat : R1∙R2 : R1 and R2 Repeat : R* : R을 반복 우선순위는 * \u0026gt; ∙ \u0026gt; | 순이다. ex){ 𝝐, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aaa\u0026rdquo;, \u0026hellip;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;bb\u0026rdquo;, \u0026ldquo;bbb\u0026rdquo;, \u0026hellip; }\nFormal Definition of RegEx L(R) : a set defined by R\nDefining Token RegEx를 이용하여 Token을 정의할 수 있다.\ndigit = | \u0026lsquo;0\u0026rsquo; | \u0026lsquo;1\u0026rsquo; | \u0026lsquo;2\u0026rsquo; | \u0026lsquo;3\u0026rsquo; | \u0026lsquo;4\u0026rsquo; | \u0026lsquo;5\u0026rsquo; | \u0026lsquo;6\u0026rsquo; | \u0026lsquo;7\u0026rsquo; | \u0026lsquo;8\u0026rsquo; | \u0026lsquo;9\u0026rsquo;\nletter_ = [ \u0026lsquo;A\u0026rsquo;-\u0026lsquo;Z\u0026rsquo; ] | [ \u0026lsquo;a\u0026rsquo;-\u0026lsquo;z\u0026rsquo; ] | \u0026lsquo;_\u0026rsquo;\nKeyword = \u0026ldquo;int\u0026rdquo; | \u0026ldquo;void\u0026rdquo; | \u0026ldquo;if\u0026rdquo; | \u0026ldquo;else\u0026rdquo; | \u0026hellip;\nInteger = digit\nIdentifier = letter_ ( letter_ | digit )*\nOperator = \u0026ldquo;=\u0026rdquo; | \u0026ldquo;+\u0026rdquo; | \u0026ldquo;-\u0026rdquo; | \u0026hellip;\nWhitespaces = (\u0026quot; \u0026quot; | \u0026ldquo;\\t\u0026rdquo; | \u0026ldquo;\\n\u0026rdquo;)+\nAutomata Finite-state Automata는 NFA, DFA 두 종류가 있다.\nNon-deterministic finite automata (NFA) Initial state, Accepting state가 존재하며 각 state들은 𝜖 또는 𝚺 에 따라 변화한다.\n다음 state로 가는 Outgoing edges들이 같은 symbol을 공유할 수 있다.\nNFA 를 이용하여 RegEx R = (\u0026lsquo;a\u0026rsquo;|\u0026lsquo;b\u0026rsquo;)* ∙ \u0026lsquo;a\u0026rsquo;를 구현해 보면 다음과 같다.\nDeterministic finite automata (DFA) initial state, Accepting state가 존재하며 각 state들은 𝚺에 따라 변화한다.\n다음 State로 가는 Outgoing edges들이 같은 symbol을 공유 할 수 없다.\n𝝐-closure 우리는 RegEx-\u0026gt;NFA-\u0026gt;DFA-\u0026gt;Code(Lexer) 순으로 변환하려고 한다.\n이를 위히 𝝐-closure 라는 개념을 도입한다.\n𝝐-closure(S) : S에서 symbol 없이 도달 할 수 있는 state의 집합 위 그림에서 𝝐-closure({s2,s5}) = {s2,s5,s6} 이다.\nNFA to DFA NFA를 DFA로 변환하기 위해선 NFA의 여러 state를 DFA의 하나의 state에 mapping 해야한다.\nNFA의 s0의 𝝐-closure 계산 𝝐-closure({s0})={s0,s1}, 이는 DFA의 starting state가 된다. S01에서 𝚺의 symbol들에 대해서 𝝐-closure 계산 \u0026lsquo;a\u0026rsquo; : 𝝐-closure({s2})={s2} \u0026lsquo;b\u0026rsquo; : 𝜙 이를 s2에서도 반복한다. \u0026lsquo;a\u0026rsquo; : 𝜙 \u0026lsquo;b\u0026rsquo; : 𝝐-closure({s2})={s1,s3} s13 에서도 반복한다. \u0026lsquo;a\u0026rsquo; : 𝜖-closure( {𝑠1,s3} ) = {𝑠2} \u0026lsquo;b\u0026rsquo; : 𝜙 탐색하지 않은 state가 없으므로 중단한다. accepting state는 NFA와 동일하다. Ambiguity 만약 int =x+10 이라는 문자열을 token으로 구분해 보자. 이때 int는 keyword, indentifier 둘다 해당할 수 있다.\n이러한 모호성을 해소하기 위해서는 각 keyword간에 precedence를 정해주어야 한다.\n","permalink":"https://246p.github.io/blog/2/","summary":"Token 문자열을 해당 문자열의 의미하는 연산, 값에 따라 token으로 분류할 수 있다.\nToken Example Keyword int, void, if Identifier a, var_1 Integer 10, 20 Operators +, =, * Whitespace “ “, \\t, \\n Regula Expression Token을 나누는 방법은 Automata를 이용한다. 이에 앞서 Regula Expression (RegEx) 에 대해서 알아볼 필요가 있다.\nRegEx는 Base case와 Inductive case로 구성된다.\nRegula language 𝚺 를 이용하여 symbol들의 집합을 표기한다. ex) binary numbers : 𝚺 = {\u0026lsquo;0\u0026rsquo;,\u0026lsquo;1\u0026rsquo;}, lowercase letters : 𝚺 = {\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026hellip;\u0026lsquo;z\u0026rsquo;}","title":"2. Lexical Analysis"},{"content":"컴파일러란? 컴파일러는 source language를 target language로 변환한다.\n일반적으로 source = high-level, target = low-level 이다. ex) C -\u0026gt; machine code\nCompiler vs Interpreter Compiler는 input program을 executable form으로 변환한다.\n반면 Interpreter는 input program을 실행한다.\nCompier 컴파일러는 세가지 과정으로 구분할 수 있다.Front-end -\u0026gt; Middle-end -\u0026gt; Back-end\nFront-end Lexer (lexical analysis) 문자열을 token단위로 나눈다. x=y+10; -\u0026gt; VAR \u0026ldquo;X\u0026rdquo;, ASSIGN, VAR \u0026ldquo;y\u0026rdquo;, PLUS, CONST 10\nParser (syntax analysis) abstract syntax tree (AST)를 생성한다. Type Checker (semantic analysis) AST를 분석하여 type이 알맞은지 확인한다. IR Generator 로 이루어져 있다. AST를 IR로 변환한다. Middle-End 실행 시간, 코드 크기, 메모리 사용량 등을 고려하여 IR을 최적화한다.\nBack-End IR을 target language로 변환한다. 이때 Target-dependent optimization 이 일어난다\n","permalink":"https://246p.github.io/blog/1/","summary":"컴파일러란? 컴파일러는 source language를 target language로 변환한다.\n일반적으로 source = high-level, target = low-level 이다. ex) C -\u0026gt; machine code\nCompiler vs Interpreter Compiler는 input program을 executable form으로 변환한다.\n반면 Interpreter는 input program을 실행한다.\nCompier 컴파일러는 세가지 과정으로 구분할 수 있다.Front-end -\u0026gt; Middle-end -\u0026gt; Back-end\nFront-end Lexer (lexical analysis) 문자열을 token단위로 나눈다. x=y+10; -\u0026gt; VAR \u0026ldquo;X\u0026rdquo;, ASSIGN, VAR \u0026ldquo;y\u0026rdquo;, PLUS, CONST 10\nParser (syntax analysis) abstract syntax tree (AST)를 생성한다. Type Checker (semantic analysis) AST를 분석하여 type이 알맞은지 확인한다.","title":"1. overview"},{"content":"1. 소감 하루동안 \u0026ldquo;돌아는 가는\u0026rdquo; 웹사이트를 만들었다.\n웹에 대한 지식이 전무하기 때문에 많은 시행착오가 있었던것 같다.\ntruouble shooting 과정에서 Papermod 위키를 10번은 읽은것 같다.\n아직 다음과 같이 해결해야할 문제가 남아있다.\n2. 해결해야 하는 문제 prev/next가 뜻과 반대로 작용함\n다른 사람의 repository를 본 결과 theme의 자체적 문제일 가능성이 높아보임\nblog 제외한 menu 에서 prev/next 버튼이 없음\nmenu 시스템을 다시 한번 손봐야 할것 같음\n이미지 첨부 안됨\n가장 큰 문제인데 상대 경로를 통한 이미지 첨부가 안됨\n1 ![img](./../../themes/PaperMod/images/screenshot.png) 웹에서 받아오는건 됨\n1 ![img](https://i.pinimg.com/474x/4b/e5/f3/4be5f377959674df9c2fe172df272482.jpg) 3. 추가하고싶은 기능 댓글 기능 구현\nstatic site의 특성상 댓글이 기본 기능으로 없음, Utterance를 사용하면 구현할 수 있음\n방문자수 확인\nHits나 Google Analasys를 이용하여 구현할 수 있을것 같음, 난이도가 낮아보임\n","permalink":"https://246p.github.io/blog/hugo_4/","summary":"1. 소감 하루동안 \u0026ldquo;돌아는 가는\u0026rdquo; 웹사이트를 만들었다.\n웹에 대한 지식이 전무하기 때문에 많은 시행착오가 있었던것 같다.\ntruouble shooting 과정에서 Papermod 위키를 10번은 읽은것 같다.\n아직 다음과 같이 해결해야할 문제가 남아있다.\n2. 해결해야 하는 문제 prev/next가 뜻과 반대로 작용함\n다른 사람의 repository를 본 결과 theme의 자체적 문제일 가능성이 높아보임\nblog 제외한 menu 에서 prev/next 버튼이 없음\nmenu 시스템을 다시 한번 손봐야 할것 같음\n이미지 첨부 안됨\n가장 큰 문제인데 상대 경로를 통한 이미지 첨부가 안됨","title":"4. 중간 점검"},{"content":"1. hugo.yaml 사이트의 전반적인 설정을 저장하는 설정이다. 예시 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 baseURL: \u0026#34;https://246p.github.io/\u0026#34; #기본주소 title: Junlog #이름 paginate: 5 theme: PaperMod enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false googleAnalytics: UA-123-45 minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: Junlog description: \u0026#34;MJ\u0026#39;s Study Log\u0026#34; keywords: [Blog, Portfolio, PaperMod] author: Kim-Minjoon # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: dark # dark, light disableThemeToggle: true sectionPagesMenu: true ShowReadingTime: false ShowShareButtons: false ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true ShowWordCount: false ShowRssButtonInSectionTermList: true UseHugoToc: true disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false ShowToc: true TocOpen: true assets: # disableHLJS: true # to disable highlight.js #disableFingerprinting: true favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;HOME\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 profileMode: enabled: true title: \u0026#34;Hello World\u0026#34; # optional default will be site title subtitle: \u0026#34;Welcome to MJ`s Blog\u0026#34; imageUrl: \u0026#34;\u0026#34; # optional imageTitle: \u0026#34;\u0026#34; # optional imageWidth: 120 # custom size imageHeight: 120 # custom size socialIcons: - name: github url: \u0026#34;https://github.com/246p\u0026#34; - name: linkedin url: \u0026#34;https://www.linkedin.com/in/minjoon-kim-9823101a7/\u0026#34; - name: instagram url: \u0026#34;https://www.instagram.com/minjunkinn/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] menu: # 메뉴에서 이중 디렉토리는 불가능함 main: - identifier: POST name: POST url: /post/ weight: 10 - identifier: hacking name: hacking url: /hacking/ weight: 20 - identifier: blog name: blog url: /blog/ weight: 30 - identifier: CV name: CV url: https://docs.google.com/document/d/1ZByTPJ0BOfy14Zpwjisc0QT0JuTDOpcl/edit?usp=sharing\u0026amp;ouid=104987107477019496766\u0026amp;rtpof=true\u0026amp;sd=true weight: 40 pygmentsUseClasses: true markup: highlight: noClasses: false # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # style: monokai 2. Page.md 게시물을 작성할때 페이지의 정보에 대한 설정이다. 예시코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 title: \u0026#34;1. Hugo 시작\u0026#34; date: 2024-01-06T18:12:26+09:00 #weight: 1 # aliases: [\u0026#34;/first\u0026#34;] tags: [\u0026#34;Hugo\u0026#34;, \u0026#34;Papermod\u0026#34;, Blog] author: \u0026#34;Kim-Minjoon\u0026#34; # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors showToc: true TocOpen: true draft: false # 글쓰기 아이콘 hidemeta: false # 시간, 작성자 등 comments: false #description: \u0026#34;부제목\u0026#34; #부재목 canonicalURL: \u0026#34;https://canonical.url/to/page\u0026#34; disableHLJS: false # to disable highlightjs disableShare: true # 아래 공유 관련 sns 메뉴 hideSummary: false #home에서 글 내용 안보이게 searchHidden: false #글 검색 허용 ShowReadingTime: false # 읽은 시간 ShowBreadCrumbs: true # Home \u0026gt;\u0026gt; posts 내용 ShowPostNavLinks: true ShowWordCount: false # 단어 수 ShowRssButtonInSectionTermList: true UseHugoToc: true cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # image path/url alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; # alt text caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; # display caption under cover relative: false # when using page bundles set this to true hidden: true # only hide on current single page --- 3. default.md blog/archetypes/defaul.md 파일에 새로 생성되는 파일에 대한 기본 설정을 저장할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 --- title: \u0026#34;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} #weight: 1 # aliases: [\u0026#34;/first\u0026#34;] tags: [\u0026#34;Tag\u0026#34;] author: \u0026#34;Kim-Minjoon\u0026#34; # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors showToc: true TocOpen: true draft: false # 글쓰기 아이콘 hidemeta: false # 시간, 작성자 등 comments: false #description: \u0026#34;부제목\u0026#34; #부제목 canonicalURL: \u0026#34;https://canonical.url/to/page\u0026#34; disableHLJS: false # to disable highlightjs disableShare: true # 아래 공유 관련 sns 메뉴 hideSummary: false #home에서 글 내용 안보이게 searchHidden: false #글 검색 허용 ShowReadingTime: false # 읽은 시간 ShowBreadCrumbs: true # Home \u0026gt;\u0026gt; posts 내용 ShowPostNavLinks: true ShowWordCount: false # 단어 수 ShowRssButtonInSectionTermList: true UseHugoToc: true cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # image path/url alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; # alt text caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; # display caption under cover relative: false # when using page bundles set this to true hidden: true # only hide on current single page --- ","permalink":"https://246p.github.io/blog/hugo_3/","summary":"1. hugo.yaml 사이트의 전반적인 설정을 저장하는 설정이다. 예시 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 baseURL: \u0026#34;https://246p.","title":"3. Papermod 설정"},{"content":"0. Markdown이란 github에 들어가본 사람이라면 한번쯤 .md 확장자 파일을 본 적 있을 것이다. markdown은 간단한 문법으로 쉽게 쓰고 읽을 수 있다. 다음과 같은 장단점이 존재한다.\n장점\n간결하다 텍스트 에디터로 쉽게 작성 가능하다. 다양한 프로그램과 플랫폼에서 활용할 수 있다. 단점\n표준이 없다. 모든 HTML을 표기할 수 없다. 1. 문법 Header 다음과 같이 제목을 표기할 수 있다.\n1 2 3 # Header 1 ## Header 2 ### Header 3 Header 1 Header 2 Header 3 BlockQuote 1 2 3 \u0026gt;first \u0026gt; \u0026gt; second \u0026gt; \u0026gt; \u0026gt; third first\nsecond\nthird\nList 1 2 3 1. first 2. second 3. third first second third 순서를 바꾸어도 순서\u0026rsquo;만\u0026rsquo; 정렬된다.\n1 2 3 1. first 3. third 2. second first third second 순서없는 list (*, +, -) 1 2 3 * first * second * third first second third code 다음과 같이 코드 들여쓰기를 할 수 있다.\n1 2 3 ```c printf(\u0026#34;hello world\\n\u0026#34;); ``` 1 printf(\u0026#34;hello world\\n\u0026#34;); vertical bar 1 2 --- *** link 1 2 [Title](link) [Google](https://google.com) Google\n2. 사용되는곳 가볍고 많은곳에 사용된다는 점에 있어서 Github, Stack Overflow, Velog, Obsidian, Discord 등 개발자가 많이 사용하는 플렛폼에서 많이 사용된다.\n","permalink":"https://246p.github.io/blog/hugo_2/","summary":"0. Markdown이란 github에 들어가본 사람이라면 한번쯤 .md 확장자 파일을 본 적 있을 것이다. markdown은 간단한 문법으로 쉽게 쓰고 읽을 수 있다. 다음과 같은 장단점이 존재한다.\n장점\n간결하다 텍스트 에디터로 쉽게 작성 가능하다. 다양한 프로그램과 플랫폼에서 활용할 수 있다. 단점\n표준이 없다. 모든 HTML을 표기할 수 없다. 1. 문법 Header 다음과 같이 제목을 표기할 수 있다.\n1 2 3 # Header 1 ## Header 2 ### Header 3 Header 1 Header 2 Header 3 BlockQuote 1 2 3 \u0026gt;first \u0026gt; \u0026gt; second \u0026gt; \u0026gt; \u0026gt; third first","title":"2. MarkDown 문법"},{"content":"0. 들어가며 먼저 github.io를 이용하여 블로그를 구축하기위해서 SSG(Static Site Generator)를 정해야 한다. 대표적으로 Jkelly(Ruby), Eleventy(Node.js), Hugo(Go) 중 Hugo를 선택하였다. 한국어 레퍼런스가 부족하다는 단점이 있지만 속도측면에서 가장 빠르기 때문이다.\n이 글은 Mac 사용자를 기준으로 작성되었다.\n1. hugo 설치하기 먼저 home brew를 이용하여 hugo를 설치해야 한다.\n1 brew install hugo 만약 home brew가 설치되어 있지 않다면 다음 명령을 사용하자\n1 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 2. github repository 만들기 hugo 를 이용하여 사이트를 제작하기 위해서는 repository 2개가 필요하다.\nblog : 사이트를 빌드 하기 위한 파일들을 저장한다.\n246p.github.io : 빌드된 사이트의 코드를 저장한다.\n3. 사이트 생성하기 1 hugo new site blog --format yaml 원하는 테마를 고른다 테마는 다음 사이트에서 확인할 수 있다.\n나는 마이너한 언어기도 하고 한글로 작성된 블로그가 잘 없어서 기술문서가 상세히 작성된 Papermod를 선택하였다. -WiKi\n테마를 적용한다.\n1 2 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 echo \u0026#34;theme: Papermod\u0026#34; \u0026gt;\u0026gt; hugo.yaml 이제 로컬 환경에서 만들어진 사이트를 시험해본다.\n1 git hugo server -D localhost:1313 에 접속하여 사이트가 작동되는지 확인할 수 있다.\n4. github에 업로드하기 다음은 사이트를 github와 연결해야한다.\n1 2 3 4 git init ID=$(git config --global user.name) git remote add origin https://github.com/$ID/blog.git git submodule add -b master --force https://github.com/$ID/$ID.github.io.git public 이제 빌드를 할 차례이다. 빌드는 앞으로 많이 사용할 예정이므로 스크립트를 작성해보자\n1 2 vi deploy.sh chmod 777 deploy.sh vim을 이용하여 다음 스크립트를 입력하자\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying update to github...\\033[0m\u0026#34; hugo -t PaperMod cd public git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push -u origin main cd .. git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push -u origin main 다음 명령어를 실행하여 github에 업로드하자.\n1 ./deploy.sh 5. 게시물 만들기 새로운 게시물을 만들때 다음과 같은 명령으로 만들 수 있다.\n1 hugo new post/new_post.md ","permalink":"https://246p.github.io/blog/hugo_1/","summary":"0. 들어가며 먼저 github.io를 이용하여 블로그를 구축하기위해서 SSG(Static Site Generator)를 정해야 한다. 대표적으로 Jkelly(Ruby), Eleventy(Node.js), Hugo(Go) 중 Hugo를 선택하였다. 한국어 레퍼런스가 부족하다는 단점이 있지만 속도측면에서 가장 빠르기 때문이다.\n이 글은 Mac 사용자를 기준으로 작성되었다.\n1. hugo 설치하기 먼저 home brew를 이용하여 hugo를 설치해야 한다.\n1 brew install hugo 만약 home brew가 설치되어 있지 않다면 다음 명령을 사용하자\n1 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 2. github repository 만들기 hugo 를 이용하여 사이트를 제작하기 위해서는 repository 2개가 필요하다.","title":"1. Hugo 시작"},{"content":"2학년 겨울 방학에 들어가기 앞서 나만의 공부 내용을 정리할만한 블로그를 만들어 보고싶다는 생각을 하게 되었다.\n개인 서버를 이용하여 웹사이트를 구축할까도 생각해보았지만 도메인 호스팅 비용, 서버유지관리 등 측면에서 github.io를 선택하게 되었다.\n앞으로 주 1회 이상 매주 공부한 내용을 포스팅할 예정이다.\n","permalink":"https://246p.github.io/blog/hugo_0/","summary":"2학년 겨울 방학에 들어가기 앞서 나만의 공부 내용을 정리할만한 블로그를 만들어 보고싶다는 생각을 하게 되었다.\n개인 서버를 이용하여 웹사이트를 구축할까도 생각해보았지만 도메인 호스팅 비용, 서버유지관리 등 측면에서 github.io를 선택하게 되었다.\n앞으로 주 1회 이상 매주 공부한 내용을 포스팅할 예정이다.","title":"블로그를 시작하면서"}]