<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>학부연구생 on Junlog</title>
    <link>https://246p.github.io/categories/%ED%95%99%EB%B6%80%EC%97%B0%EA%B5%AC%EC%83%9D/</link>
    <description>Recent content in 학부연구생 on Junlog</description>
    <image>
      <title>Junlog</title>
      <url>https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true</url>
      <link>https://github.com/246p/blog/blob/main/Hugo/blog/Cover.png?raw=true</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 07 Feb 2024 10:13:45 +0900</lastBuildDate>
    <atom:link href="https://246p.github.io/categories/%ED%95%99%EB%B6%80%EC%97%B0%EA%B5%AC%EC%83%9D/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3. Angora: Efficient Fuzzing by Principled Search</title>
      <link>https://246p.github.io/blog/paper_3/</link>
      <pubDate>Wed, 07 Feb 2024 10:13:45 +0900</pubDate>
      <guid>https://246p.github.io/blog/paper_3/</guid>
      <description>Angora: Efficient Fuzzing by Principled Search
0. Abstract fuzzing은 소프트웨어 버그를 찾기 위해 널리 사용되고 있다. 그러나 최신의 fuzzer의 성능은 기대에 못미치기도 한다.
symbolic execution 기반 : high quality input , 속도가 느림 random muatation 기반 : low quality input, 속도가 빠름 이 논문에서는 새로운 mutation-based fuzzer인 Angora를 제시한다.
Angora의 목표는 symbolic execution 없이 path constraint를 해결함으로 branch coverage를 증가시키는 것이다. 다음과 같은 핵심 기술을 도입하였다.
scalable byte-level taint tracking context-sensetive branch count search based on gradient descent input legnth exploration LAVA-M data set에서 거의 모든 injected bug를 찾았고 다른 모든 fuzzer보다 더 많은 bug를 찾았다.</description>
    </item>
    <item>
      <title>2. Automated Whitebox Fuzz Testing</title>
      <link>https://246p.github.io/blog/paper_2/</link>
      <pubDate>Fri, 02 Feb 2024 01:26:16 +0900</pubDate>
      <guid>https://246p.github.io/blog/paper_2/</guid>
      <description>Automated Whitebox Fuzz Testing
0. Abstract fuzz testing은 소프트웨어 보안 취약점을 찾는 효과적인 기술이다. 전통적인 fuzzer들은 well-formed input에 random mutations을 적용하고 결과값을 테스트한다. 이 논문에서는 Symbolic execution과 Dynamic test generation을 적용하여 alternative whitebox fuzz testing을 구현하였다.
이 논문에서는 well-formed input에 따라 실제로 실행되는 것을 기록하고, symbolicaly evalution하고, 프로그램이 입력을 어떻게 사용하는지 확인하여 입력에 대한 제약조건을 수집한다. 수집한 제약조건들을 하나씩 부정하고 constraint solver를 이용하여 solve한다. 이를 통해 프로그램에서 다른 경로를 실행하는 새로운 input을 생성한다.</description>
    </item>
    <item>
      <title>1. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution</title>
      <link>https://246p.github.io/blog/paper_1/</link>
      <pubDate>Fri, 02 Feb 2024 01:26:10 +0900</pubDate>
      <guid>https://246p.github.io/blog/paper_1/</guid>
      <description>All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution
0. Abstract Dynamic taint analysis &amp;amp; forward Symbolic execution을 이용하여 다음과 같은 일을 많이 수행함
1. Input Filter Generation 2. Test case generation 3. Vulnerabiliry discovery 이와 관련하여 이 논문은 두가지 파트로 되어있음
1. dynamic taint analysis와 forward symbolic execution을 수행할 수 있는 general language 제시 2. 이를 구현함에 있어서 important implementation choices, common pitfalls, considerations 1.</description>
    </item>
    <item>
      <title>0. 읽을 논문</title>
      <link>https://246p.github.io/blog/paper_0/</link>
      <pubDate>Thu, 01 Feb 2024 10:13:41 +0900</pubDate>
      <guid>https://246p.github.io/blog/paper_0/</guid>
      <description>Abstract 요약 Penetrating conditionals REDQUEEN: Fuzzing with Input-to-State Correspondence Link
최근 몇년간 fuzz 기반 automated software testing이 대두되고 있다. 특히 feedback-driven fuzz testing은 magic byte와 checksum은의 문제가 있다.
비용이많이드는 taint tracking 과 symbolic execution이 있다. 하지만 이러한 방법은 source code에 대한 접근, environment (OS나 library function call)에 대한 엄밀한 정보가 필요하다.
이 논문에서 taint tracking과 symbolic execution에 비해 가벼우면서 효과적인 대안을 소개한다. 이 방법은 large binary application과 알려지지 않은 environment에 쉽게 확장 가능하다.</description>
    </item>
    <item>
      <title>4. 함수 정의와 호출</title>
      <link>https://246p.github.io/blog/pl_4/</link>
      <pubDate>Wed, 24 Jan 2024 13:38:09 +0900</pubDate>
      <guid>https://246p.github.io/blog/pl_4/</guid>
      <description>4. 함수 정의와 호출 앞에서 선언한 언어를 확장하여 함수를 정의한다.
4.1 문법구조 프로그램에서 함수를 사용하려면 함수 생성(선언)과 호출을 지원해야한다.
E -&amp;gt; n | E1 + E2 | E1 - E2 | E1 * E2 | E1 / E2 | x | let x = E1 in E2 | if E1 then E2 else E3 | iszero E | fun x E 함수 생성식 | E1 E2 함수 호출식 fun x E x를 인자로 받아서 E의 계산 결과를 반환하는 함수를 정의하는 구문이다.</description>
    </item>
    <item>
      <title>3. 변수와 환경</title>
      <link>https://246p.github.io/blog/pl_3/</link>
      <pubDate>Wed, 24 Jan 2024 13:37:54 +0900</pubDate>
      <guid>https://246p.github.io/blog/pl_3/</guid>
      <description>3. 변수와 환경 3.1 문법구조 우리가 1장에서 선언한 정수형 언어를 다음과 같이 확장한다.
E -&amp;gt; n | E1 + E2 | E1 - E2 | E1 * E2 | E1 / E2 | x 변수 | let x = E1 in E2 let식 | if E1 then E2 else E3 조건식 | iszero E bool식 x 먼저 프로그램에서 식이 올 수 있는 위치에 변수 x를 사용할 수 있도록 하였다.
let x = E1 in E2 변수 x를 선언하는 식이다.</description>
    </item>
    <item>
      <title>1. 귀납법</title>
      <link>https://246p.github.io/blog/pl_1/</link>
      <pubDate>Wed, 24 Jan 2024 13:37:50 +0900</pubDate>
      <guid>https://246p.github.io/blog/pl_1/</guid>
      <description>1.귀납법 1.1 집합의 귀납적 정의 귀납법을 이용하여 집합을 정의할 수 있다.
S를 다음을 만족하는 가장 &amp;lsquo;작은&amp;rsquo; 자연수 집합으로 정의해보자
0 ∈ S n ∈ S ⇒ n + 3 ∈ S {0,1,2,3,4,&amp;hellip;} 도 만족하지만 {0,3,6,9,&amp;hellip;}가 가장 작은 집합이다.
추론 규칙 추론 규칙을 이용한다면 다음과 같이 정의할 수 있다.
n ∈ S ------- ---------- 0 ∈ S (n + 3) ∈ S 추론규칙을 CFG를 이용하여 표현하기도 한다.
n → 0 | n + 3 1.</description>
    </item>
    <item>
      <title>1</title>
      <link>https://246p.github.io/blog/fsharp_1/</link>
      <pubDate>Wed, 17 Jan 2024 12:57:33 +0900</pubDate>
      <guid>https://246p.github.io/blog/fsharp_1/</guid>
      <description>F#이란? </description>
    </item>
  </channel>
</rss>
